<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Руководство SSH</title>

<meta name="description" content="Руководство SSH">
<meta name="keywords" content="Руководство SSH">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">Руководство SSH</h1>
<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#SSH" accesskey="n" rel="next">SSH</a>, Previous: <a href="dir.html#Top" accesskey="p" rel="prev">(dir)</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; </p>
</div>
<a name="SSH-verkhnii-uzel"></a>
<h1 class="top">SSH верхний узел</h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#SSH" accesskey="1">SSH</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSHD" accesskey="2">SSHD</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH_005fCONFIG" accesskey="3">SSH_CONFIG</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSHD_005fCONFIG" accesskey="4">SSHD_CONFIG</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SCP_00281_0029" accesskey="5">SCP(1)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SFTP_00281_0029" accesskey="6">SFTP(1)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH_002dADD_00281_0029" accesskey="7">SSH-ADD(1)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH_002dAGENT" accesskey="8">SSH-AGENT</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH_002dARGV0" accesskey="9">SSH-ARGV0</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH_002dKEYGEN">SSH-KEYGEN</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH_002dKEYSCAN">SSH-KEYSCAN</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH_002dKEYSIGN">SSH-KEYSIGN</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ssh_002dconfig_002dexample">ssh-config-example</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#sshd_005fconfig_002dexample">sshd_config-example</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#sshd_005fconfig_005fexample-2">sshd_config_example 2</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1">Руководство 1</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2">Руководство 2</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="SSH"></a>
<div class="header">
<p>
Next: <a href="#SSHD" accesskey="n" rel="next">SSHD</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH-1"></a>
<h2 class="chapter">1 SSH</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh — OpenSSH SSH клиент (программа удаленного входа)
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>ssh [-<a href="#man_005fssh_005fssh-1">1</a><a href="#man_005fssh_005fssh-2">2</a><a href="#man_005fssh_005fssh-4">4</a><a href="#man_005fssh_005fssh-6">6</a><a href="#man_005fssh_005fssh-A">A</a><a href="#man_005fssh_005fssh-a">a</a><a href="#man_005fssh_005fssh-_002dC">-C</a><a href="#man_005fssh_005fssh-f">f</a><a href="#man_005fssh_005fssh-G">G</a><a href="#man_005fssh_005fssh-g">g</a><a href="#man_005fssh_005fssh-K">K</a><a href="#man_005fssh_005fssh-k">k</a><a href="#man_005fssh_005fssh-M">M</a><a href="#man_005fssh_005fssh-N">N</a><a href="#man_005fssh_005fssh-n">n</a><a href="#man_005fssh_005fssh-q">q</a><a href="#man_005fssh_005fssh-s">s</a><a href="#man_005fssh_005fssh-T">T</a><a href="#man_005fssh_005fssh-t">t</a><a href="#man_005fssh_005fssh-V">V</a><a href="#man_005fssh_005fssh-v">v</a><a href="#man_005fssh_005fssh-X">X</a><a href="#man_005fssh_005fssh-x">x</a><a href="#man_005fssh_005fssh-Y">Y</a><a href="#man_005fssh_005fssh-y">y</a>] [<a href="#man_005fssh_005fssh-_002db-bind_005faddress">-b bind_address</a>] [<a href="#man_005fssh_005fssh-_002dc-cipher_005fspec">-c cipher_spec</a>]
         [<a href="#man_005fssh_005fssh-_002dD-_005bbind_005faddress_003a_005dport">-D [bind_address:]port</a>] [<a href="#man_005fssh_005fssh-_002dE-log_005ffile">-E log_file</a>] [<a href="#man_005fssh_005fssh-_002de-escape_005fchar">-e escape_char</a>]
         [<a href="#man_005fssh_005fssh-_002dF-configfile">-F configfile</a>] [<a href="#man_005fssh_005fssh-_002dI-pkcs11">-I pkcs11</a>] [<a href="#man_005fssh_005fssh-_002di-identity_005ffile">-i identity_file</a>] [<a href="#man_005fssh_005fssh-_041f_0435_0440_0435_043d_0430_043f_0440_0430_0432_043b_0435_043d_0438_0435-_043b_043e_043a_0430_043b_044c_043d_043e_0433_043e-_0441_043e_0435_0434_0438_043d_0435_043d_0438_044f">-L address</a>]
         [<a href="#man_005fssh_005fssh-_002dl-login_005fname">-l login_name</a>] [<a href="#man_005fssh_005fssh-_002dm-mac_005fspec">-m mac_spec</a>] [<a href="#man_005fssh_005fssh-_002dO-ctl_005fcmd">-O ctl_cmd</a>] [<a href="#man_005fssh_005fssh-_002do-option">-o option</a>] [<a href="#man_005fssh_005fssh-_002dp-port">-p port</a>]
         [<a href="#man_005fssh_005fssh-_002dQ-query_005foption">-Q query_option</a>] [<a href="#man_005fssh_005fssh-_041f_0435_0440_0435_043d_0430_043f_0440_0430_0432_043b_0435_043d_0438_0435-_0443_0434_0430_043b_0435_043d_043d_043e_0433_043e-_0441_043e_0435_0434_0438_043d_0435_043d_0438_044f">-R address</a>] [<a href="#man_005fssh_005fssh-_002dS-ctl_005fpath">-S ctl_path</a>] [<a href="#man_005fssh_005fssh-_002dW-host_003aport">-W host:port</a>]
         [<a href="#man_005fssh_005fssh-_002dw-local_005ftun_005b_003aremote_005ftun_005d">-w local_tun[:remote_tun]</a>] [user@]hostname [command]
</p></dd>
<dt>Переменные окружения ssh</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fperemen_005fokruj-DISPLAY">DISPLAY</a>
     <a href="#man_005fssh_005fperemen_005fokruj-HOME">HOME</a>
     <a href="#man_005fssh_005fperemen_005fokruj-LOGNAME">LOGNAME</a>
     <a href="#man_005fssh_005fperemen_005fokruj-MAIL">MAIL</a>
     <a href="#man_005fssh_005fperemen_005fokruj-PATH">PATH</a>
     <a href="#man_005fssh_005fperemen_005fokruj-SSH_005fASKPASS">SSH_ASKPASS</a>
     <a href="#man_005fssh_005fperemen_005fokruj-SSH_005fAUTH_005fSOCK">SSH_AUTH_SOCK</a>
     <a href="#man_005fssh_005fperemen_005fokruj-SSH_005fCONNECTION">SSH_CONNECTION</a>
     <a href="#man_005fssh_005fperemen_005fokruj-SSH_005fORIGINAL_005fCOMMAND">SSH_ORIGINAL_COMMAND</a>
     <a href="#man_005fssh_005fperemen_005fokruj-SSH_005fTTY">SSH_TTY</a>
     <a href="#man_005fssh_005fperemen_005fokruj-TZ">TZ</a>
     <a href="#man_005fssh_005fperemen_005fokruj-USER">USER</a>
</pre></div>
</dd>
<dt>Список файлов</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002erhosts">~/.rhosts</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002eshosts">~/.shosts</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002f">~/.ssh/</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fauthorized_005fkeys">~/.ssh/authorized_keys</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fconfig">~/.ssh/config</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fenvironment">~/.ssh/environment</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_0424_0430_0439_043b_044b-_0437_0430_043a_0440_044b_0442_044b_0445-_0447_0430_0441_0442_0435_0439-_043a_043b_044e_0447_0430-_0430_0443_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438">Файлы закрытых частей ключа аунтификации</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_0424_0430_0439_043b_044b-_043e_0442_043a_0440_044b_0442_043e_0439-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0430-_0430_0443_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438">Файлы открытой части ключа аунтификации</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fknown_005fhosts">~/.ssh/known_hosts</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002frc">~/.ssh/rc</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_002fetc_002fhosts_002eequiv">/etc/hosts.equiv</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fshosts_002eequiv">/etc/ssh/shosts.equiv</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fssh_005fconfig">/etc/ssh/ssh_config</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_0424_0430_0439_043b_044b-_0437_0430_043a_0440_044b_0442_043e_0439-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0430_0443_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438-_043d_0430-_043e_0441_043d_043e_0432_0430_043d_0438_0438-_0445_043e_0441_0442_0430">Файлы закрытой части ключей аунтификации на основании хоста</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fssh_005fknown_005fhosts">/etc/ssh/ssh_known_hosts</a>
     <a href="#man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fsshrc">/etc/ssh/sshrc</a>
     
</pre></div>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh (SSH-клиент) - это программа для входа на удаленный компьютер и выполнения
     команд на удаленном компьютере. Она предназначена для обеспечения безопасной
     зашифрованной связи между двумя ненадежными узлами через небезопасную сеть.
     Соединения X11, произвольные TCP-порты и сокеты UNIX-домена также могут быть
     перенаправлены по защищенному каналу.
</p>
<p>SSH подключается и входит в указанное имя хоста (с необязательным именем
     пользователя). Пользователь должен подтвердить свою личность на удаленном компьютере
     одним из нескольких способов (см. Ниже).
</p>
<p>Если указана команда, она выполняется на удаленном хосте вместо оболочки входа
     в систему.
</p>
<p>Варианты следующие:
</p><dl compact="compact">
<dt>-1 <a name="man_005fssh_005fssh-1"></a></dt>
<dd><p>Заставляет ssh использовать только протокол версии 1.
</p>
</dd>
<dt>-2 <a name="man_005fssh_005fssh-2"></a></dt>
<dd><p>Заставляет ssh использовать только протокол версии 2.
</p>
</dd>
<dt>-4 <a name="man_005fssh_005fssh-4"></a></dt>
<dd><p>Заставляет ssh использовать только адреса IPv4.
</p>
</dd>
<dt>-6 <a name="man_005fssh_005fssh-6"></a></dt>
<dd><p>Заставляет ssh использовать только адреса IPv6.
</p>
</dd>
<dt>-A <a name="man_005fssh_005fssh-A"></a></dt>
<dd><p>Включает переадресацию соединения с агентом аутентификации. Это также
             может быть указано для каждого хоста в файле конфигурации.
</p>
<p>Переадресация агента должна быть включена с осторожностью. Пользователи с
             возможностью обхода прав доступа к файлам на удаленном хосте (для сокета
             UNIX-домена агента) могут получить доступ к локальному агенту через
             переадресованное соединение. Злоумышленник не может получить материал ключа
             от агента, однако он может выполнять операции с ключами, которые позволяют
             им проходить проверку подлинности с использованием идентификаторов,
             загруженных в агент.
</p>
</dd>
<dt>-a <a name="man_005fssh_005fssh-a"></a></dt>
<dd><p>Отключает переадресацию соединения агента аутентификации.
</p>
</dd>
<dt>-b bind_address <a name="man_005fssh_005fssh-_002db-bind_005faddress"></a></dt>
<dd><p>Используйте bind_address на локальной машине в качестве адреса
             источника соединения. Полезно только в системах с более чем
             одним адресом.
</p>
</dd>
<dt>-C <a name="man_005fssh_005fssh-_002dC"></a></dt>
<dd><p>Запрашивает сжатие всех данных (включая stdin, stdout, stderr, и
             данные для переадресованных соединений X11, TCP и UNIX-доменов). Алгоритм
             сжатия тот же, что и в gzip(1), и “level” можно контролировать с помощью
             параметра CompressionLevel для версии протокола 1. Сжатие желательно на
             модемных линиях и других медленных соединениях, но только в быстрых сетях
             замедлит работу. Значение по умолчанию может быть установлено для каждого
             хоста отдельно в файлах конфигурации; см. вариант Compression.
</p>
</dd>
<dt>-c cipher_spec <a name="man_005fssh_005fssh-_002dc-cipher_005fspec"></a></dt>
<dd><p>Выбирает спецификацию шифра для шифрования сеанса.
</p>
<p>Протокол версии 1 позволяет указывать один шифр. Поддерживаемые значения:
             “3des”, “blowfish”, и “des”. Для протокола версии 2, cipher_spec - это
             список шифров, разделенных запятыми, в порядке предпочтения. См.
             Ключевое слово Ciphers в ssh_config(5) для получения дополнительной
             информации.
</p>
</dd>
<dt>-D [bind_address:]port <a name="man_005fssh_005fssh-_002dD-_005bbind_005faddress_003a_005dport"></a></dt>
<dd><p>Определяет локальную переадресацию портов на уровне приложения “dynamic”.
             Это работает путем выделения сокета для прослушивания порта на локальной
             стороне, необязательно привязанного к указанному bind_address. Всякий раз,
             когда устанавливается соединение с этим портом, оно перенаправляется по
             безопасному каналу, а затем протокол приложения используется для определения
             того, к чему подключаться с удаленного компьютера. В настоящее время
             поддерживаются протоколы SOCKS4 и SOCKS5, и ssh будет действовать как сервер
             SOCKS. Только root может пересылать привилегированные порты. Переадресация
             динамических портов также может быть указана в файле конфигурации.
</p>
<p>Адреса IPv6 можно указать, заключив адрес в квадратные скобки. Только
             суперпользователь может пересылать привилегированные порты. По умолчанию
             локальный порт привязан в соответствии с настройкой GatewayPorts. Однако
             явный bind_address может использоваться для привязки соединения к
             определенному адресу. bind_address из “localhost” указывает, что
             прослушивающий порт должен быть привязан только для локального использования,
             в то время как пустой адрес или ‘*’ указывает, что порт должен быть доступен
             со всех интерфейсов.
</p>
</dd>
<dt>-E log_file <a name="man_005fssh_005fssh-_002dE-log_005ffile"></a></dt>
<dd><p>Добавлять журналы отладки в log_file вместо стандартной ошибки.
</p>
</dd>
<dt>-e escape_char <a name="man_005fssh_005fssh-_002de-escape_005fchar"></a></dt>
<dd><p>Устанавливает escape-символ для сеансов с pty (по умолчанию: ‘~’).
             Экранирующий символ распознается только в начале строки. Экранирующий
             символ, за которым следует точка (‘.’), закрывает соединение; затем
             control-Z приостанавливает соединение; а затем сам отправляет escape-символ
             один раз. Установка символа в “none” отключает любые экранирования и делает
             сеанс полностью прозрачным.
</p>
</dd>
<dt>-F configfile <a name="man_005fssh_005fssh-_002dF-configfile"></a></dt>
<dd><p>Определяет альтернативный файл конфигурации для каждого пользователя. Если
             файл конфигурации указан в командной строке, системный файл конфигурации
             (/etc/ssh/ssh_config) будет проигнорирован. По умолчанию для файла
             конфигурации для каждого пользователя используется ~/.ssh/config.
</p>
</dd>
<dt>-f <a name="man_005fssh_005fssh-f"></a></dt>
<dd><p>Просит ssh перейти в фоновый режим непосредственно перед выполнением команды.
             Это полезно, если пользователь хочет сделать это в фоновом режиме. Это
             подразумевает -n. Рекомендуемый способ запуска программ X11 на удаленном
             сайте - это что-то вроде ssh -f host xterm.
</p>
<p>Если при конфигурирования конфигурации ExitOnForwardFailure задано
             значение“yes”, клиент, запущенный с -f, будет ожидать успешной установки
             всех удаленных портов, прежде чем перейти в фоновый режим.
</p>
</dd>
<dt>-G <a name="man_005fssh_005fssh-G"></a></dt>
<dd><p>Заставляет ssh распечатать свою конфигурацию после оценки блоков Host и
             Match и выйти.
</p>
</dd>
<dt>-g <a name="man_005fssh_005fssh-g"></a></dt>
<dd><p>Позволяет удаленным хостам подключаться к локальным перенаправленным портам.
             Если используется мультиплексное соединение, то эта опция должна быть
             указана в главном процессе.
</p>
</dd>
<dt>-I pkcs11 <a name="man_005fssh_005fssh-_002dI-pkcs11"></a></dt>
<dd><p>Укажите общую библиотеку PKCS#11, которую ssh должен использовать для связи
             с маркером PKCS#11, предоставляющим личный ключ RSA пользователя.
</p>
</dd>
<dt>-i identity_file <a name="man_005fssh_005fssh-_002di-identity_005ffile"></a></dt>
<dd><p>Выбирает файл, из которого читается идентификатор (закрытый ключ) для
             аутентификации с открытым ключом. По умолчанию используется
</p><div class="display">
<pre class="display">             ~/.ssh/identity для версии протокола 1 и
             ~/.ssh/id_dsa,
             ~/.ssh/id_ecdsa,
             ~/.ssh/id_ed25519 и
             ~/.ssh/id_rsa
</pre></div>
<p>для версии протокола 2. Файлы идентификации также могут быть
             указаны для каждого хоста в файле конфигурации. Можно иметь несколько
             параметров -i (и несколько идентификаторов, указанных в файлах конфигурации).
             Если в директиве CertificateFile явно не указаны сертификаты, ssh также
             попытается загрузить информацию о сертификате из имени файла, полученного
             путем добавления -cert.pub к именам идентификаторов.
</p>
</dd>
<dt>-K <a name="man_005fssh_005fssh-K"></a></dt>
<dd><p>Включает аутентификацию на основе GSSAPI и пересылку (делегирование) учетных
             данных GSSAPI на сервер.
</p>
</dd>
<dt>-k <a name="man_005fssh_005fssh-k"></a></dt>
<dd><p>Отключает пересылку (делегирование) учетных данных GSSAPI на сервер.
</p></dd>
<dt>Перенаправление локального соединения <a name="man_005fssh_005fssh-_041f_0435_0440_0435_043d_0430_043f_0440_0430_0432_043b_0435_043d_0438_0435-_043b_043e_043a_0430_043b_044c_043d_043e_0433_043e-_0441_043e_0435_0434_0438_043d_0435_043d_0438_044f"></a></dt>
<dd><div class="display">
<pre class="display">     -L [bind_address:]port:host:hostport
     -L [bind_address:]port:remote_socket
     -L local_socket:host:hostport
     -L local_socket:remote_socket
</pre></div>
<p>Указывает, что соединения с данным портом TCP или сокетом Unix на локальном
             (клиентском) хосте должны быть перенаправлены на данный хост и порт или
             сокет Unix на удаленной стороне. Это работает путем выделения сокета для
             прослушивания либо порта TCP на локальной стороне, необязательно привязанного
             к указанному bind_address, либо к сокету Unix. Всякий раз, когда
             устанавливается соединение с локальным портом или сокетом, соединение
             перенаправляется по защищенному каналу, и соединение устанавливается либо
             с хост-порта хост-порта, либо с Unix-сокетом remote_socket с
             удаленной машины.
</p>
<p>Переадресация портов также может быть указана в файле конфигурации. Только
             суперпользователь может пересылать привилегированные порты. Адреса IPv6 можно
             указать, заключив адрес в квадратные скобки.
</p>
<p>По умолчанию локальный порт привязан в соответствии с настройкой GatewayPorts.
             Однако явный bind_address может использоваться для привязки соединения к
             определенному адресу. bind_address из “localhost” указывает, что
             прослушивающий порт должен быть привязан только для локального использования,
             в то время как пустой адрес или ‘*’ указывает, что порт должен быть доступен
             со всех интерфейсов.
</p>
</dd>
<dt>-l login_name <a name="man_005fssh_005fssh-_002dl-login_005fname"></a></dt>
<dd><p>Указывает пользователя для входа в систему как на удаленном компьютере.
             Это также может быть указано для каждого хоста в файле конфигурации.
</p>
</dd>
<dt>-M <a name="man_005fssh_005fssh-M"></a></dt>
<dd><p>Помещает ssh-клиент в режим “master” для совместного использования соединения.
             Несколько опций -M переводят ssh в режим “master” с подтверждением,
             необходимым перед тем, как будут приняты подчиненные соединения. Обратитесь
             к описанию ControlMaster в ssh_config(5) для деталей.
</p>
</dd>
<dt>-m mac_spec <a name="man_005fssh_005fssh-_002dm-mac_005fspec"></a></dt>
<dd><p>Разделенный запятыми список алгоритмов MAC (код аутентификации сообщения),
             указанный в порядке предпочтения. Смотрите ключевое слово MACs для получения
             дополнительной информации.
</p>
</dd>
<dt>-N <a name="man_005fssh_005fssh-N"></a></dt>
<dd><p>Не выполняйте удаленную команду. Это полезно только для переадресации портов.
</p>
</dd>
<dt>-n <a name="man_005fssh_005fssh-n"></a></dt>
<dd><p>Перенаправляет stdin из /dev/null (фактически, предотвращает чтение
             из stdin). Это необходимо использовать, когда ssh запускается в фоновом
             режиме. Обычная хитрость заключается в том, чтобы использовать это для
             запуска программ X11 на удаленной машине. Например,
             ssh -n shadows.cs.hut.fi emacs &amp; запустит emacs на
             shadows.cs.hut.fi, и соединение X11 будет автоматически перенаправлено
             по зашифрованному каналу. Программа ssh будет помещена в фоновый режим.
             (Это не работает, если ssh нужно запросить пароль или фразу-пароль;
             см. Также параметр -f.)
</p>
</dd>
<dt>-O ctl_cmd <a name="man_005fssh_005fssh-_002dO-ctl_005fcmd"></a></dt>
<dd><p>Управлять активным ведущим процессом мультиплексирования соединений. Когда
             указана опция -O, аргумент ctl_cmd интерпретируется и передается ведущему
             процессу. Допустимые команды:
</p><div class="display">
<pre class="display">             “check” (проверьте, что основной процесс запущен),
             “forward” (переадресация запросов без выполнения команд),
             “cancel” (отмена переадресаций),
             “exit” (запрос на выход мастера) и
             “stop” (запрос мастера на прекращение приема дальнейшие
             запросы мультиплексирования).
</pre></div>
</dd>
<dt>-o option <a name="man_005fssh_005fssh-_002do-option"></a></dt>
<dd><p>Может использоваться для задания параметров в формате, используемом в файле
             конфигурации. Это полезно для указания параметров, для которых нет отдельного
             флага командной строки. Для получения полной информации о параметрах,
             перечисленных ниже, и их возможных значений, смотри ssh_config(5).
</p><div class="display">
<pre class="display">      <a href="#man_005fssh_005fssh_005fconfig-AddKeysToAgent">AddKeysToAgent</a>
      <a href="#man_005fssh_005fssh_005fconfig-AddressFamily">AddressFamily</a>
      <a href="#man_005fssh_005fssh_005fconfig-BatchMode">BatchMode</a>
      <a href="#man_005fssh_005fssh_005fconfig-BindAddress">BindAddress</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalDomains">CanonicalDomains</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeFallbackLocal">CanonicalizeFallbackLocal</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeHostname">CanonicalizeHostname</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeMaxDots">CanonicalizeMaxDots</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizePermittedCNAMEs">CanonicalizePermittedCNAMEs</a>
      <a href="#man_005fssh_005fssh_005fconfig-CertificateFile">CertificateFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-ChallengeResponseAuthentication">ChallengeResponseAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-CheckHostIP">CheckHostIP</a>
      <a href="#man_005fssh_005fssh_005fconfig-Cipher">Cipher</a>
      <a href="#man_005fssh_005fssh_005fconfig-Ciphers">Ciphers</a>
      <a href="#man_005fssh_005fssh_005fconfig-ClearAllForwardings">ClearAllForwardings</a>
      <a href="#man_005fssh_005fssh_005fconfig-Compression">Compression</a>
      <a href="#man_005fssh_005fssh_005fconfig-CompressionLevel">CompressionLevel</a>
      <a href="#man_005fssh_005fssh_005fconfig-ConnectionAttempts">ConnectionAttempts</a>
      <a href="#man_005fssh_005fssh_005fconfig-ConnectTimeout">ConnectTimeout</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlMaster">ControlMaster</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlPath">ControlPath</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlPersist">ControlPersist</a>
      <a href="#man_005fssh_005fssh_005fconfig-DynamicForward">DynamicForward</a>
      <a href="#man_005fssh_005fssh_005fconfig-EscapeChar">EscapeChar</a>
      <a href="#man_005fssh_005fssh_005fconfig-ExitOnForwardFailure">ExitOnForwardFailure</a>
      <a href="#man_005fssh_005fssh_005fconfig-FingerprintHash">FingerprintHash</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardAgent">ForwardAgent</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardX11">ForwardX11</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardX11Timeout">ForwardX11Timeout</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardX11Trusted">ForwardX11Trusted</a>
      <a href="#man_005fssh_005fssh_005fconfig-GatewayPorts">GatewayPorts</a>
      <a href="#man_005fssh_005fssh_005fconfig-GlobalKnownHostsFile">GlobalKnownHostsFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIAuthentication">GSSAPIAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIDelegateCredentials">GSSAPIDelegateCredentials</a>
      <a href="#man_005fssh_005fssh_005fconfig-HashKnownHosts">HashKnownHosts</a>
      <a href="#man_005fssh_005fssh_005fconfig-Host">Host</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostbasedAuthentication">HostbasedAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostbasedKeyTypes">HostbasedKeyTypes</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostKeyAlgorithms">HostKeyAlgorithms</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostKeyAlias">HostKeyAlias</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostName">HostName</a>
      <a href="#man_005fssh_005fssh_005fconfig-IdentityFile">IdentityFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-IdentitiesOnly">IdentitiesOnly</a>
      <a href="#man_005fssh_005fssh_005fconfig-IPQoS">IPQoS</a>
      <a href="#man_005fssh_005fssh_005fconfig-KbdInteractiveAuthentication">KbdInteractiveAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-KbdInteractiveDevices">KbdInteractiveDevices</a>
      <a href="#man_005fssh_005fssh_005fconfig-KexAlgorithms">KexAlgorithms</a>
      <a href="#man_005fssh_005fssh_005fconfig-LocalCommand">LocalCommand</a>
      <a href="#man_005fssh_005fssh_005fconfig-LocalForward">LocalForward</a>
      <a href="#man_005fssh_005fssh_005fconfig-LogLevel">LogLevel</a>
      <a href="#man_005fssh_005fssh_005fconfig-MACs">MACs</a>
      <a href="#man_005fssh_005fssh_005fconfig-Match">Match</a>
      <a href="#man_005fssh_005fssh_005fconfig-NoHostAuthenticationForLocalhost">NoHostAuthenticationForLocalhost</a>
      <a href="#man_005fssh_005fssh_005fconfig-NumberOfPasswordPrompts">NumberOfPasswordPrompts</a>
      <a href="#man_005fssh_005fssh_005fconfig-PasswordAuthentication">PasswordAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-PermitLocalCommand">PermitLocalCommand</a>
      <a href="#man_005fssh_005fssh_005fconfig-PKCS11Provider">PKCS11Provider</a>
      <a href="#man_005fssh_005fssh_005fconfig-Port">Port</a>
      <a href="#man_005fssh_005fssh_005fconfig-PreferredAuthentications">PreferredAuthentications</a>
      <a href="#man_005fssh_005fssh_005fconfig-Protocol">Protocol</a>
      <a href="#man_005fssh_005fssh_005fconfig-ProxyCommand">ProxyCommand</a>
      <a href="#man_005fssh_005fssh_005fconfig-ProxyUseFdpass">ProxyUseFdpass</a>
      <a href="#man_005fssh_005fssh_005fconfig-PubkeyAcceptedKeyTypes">PubkeyAcceptedKeyTypes</a>
      <a href="#man_005fssh_005fssh_005fconfig-PubkeyAuthentication">PubkeyAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-RekeyLimit">RekeyLimit</a>
      <a href="#man_005fssh_005fssh_005fconfig-RemoteForward">RemoteForward</a>
      <a href="#man_005fssh_005fssh_005fconfig-RequestTTY">RequestTTY</a>
      <a href="#man_005fssh_005fssh_005fconfig-RhostsRSAAuthentication">RhostsRSAAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-RSAAuthentication">RSAAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-SendEnv">SendEnv</a>
      <a href="#man_005fssh_005fssh_005fconfig-ServerAliveInterval">ServerAliveInterval</a>
      <a href="#man_005fssh_005fssh_005fconfig-ServerAliveCountMax">ServerAliveCountMax</a>
      <a href="#man_005fssh_005fssh_005fconfig-StreamLocalBindMask">StreamLocalBindMask</a>
      <a href="#man_005fssh_005fssh_005fconfig-StreamLocalBindUnlink">StreamLocalBindUnlink</a>
      <a href="#man_005fssh_005fssh_005fconfig-StrictHostKeyChecking">StrictHostKeyChecking</a>
      <a href="#man_005fssh_005fssh_005fconfig-TCPKeepAlive">TCPKeepAlive</a>
      <a href="#man_005fssh_005fssh_005fconfig-Tunnel">Tunnel</a>
      <a href="#man_005fssh_005fssh_005fconfig-TunnelDevice">TunnelDevice</a>
      <a href="#man_005fssh_005fssh_005fconfig-UpdateHostKeys">UpdateHostKeys</a>
      <a href="#man_005fssh_005fssh_005fconfig-UsePrivilegedPort">UsePrivilegedPort</a>
      <a href="#man_005fssh_005fssh_005fconfig-User">User</a>
      <a href="#man_005fssh_005fssh_005fconfig-UserKnownHostsFile">UserKnownHostsFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-VerifyHostKeyDNS">VerifyHostKeyDNS</a>
      <a href="#man_005fssh_005fssh_005fconfig-VisualHostKey">VisualHostKey</a>
      <a href="#man_005fssh_005fssh_005fconfig-XAuthLocation">XAuthLocation</a>

</pre></div>
</dd>
<dt>-p port <a name="man_005fssh_005fssh-_002dp-port"></a></dt>
<dd><p>Порт для подключения на удаленном хосте. Это может быть указано для
             каждого хоста в файле конфигурации.
</p>
</dd>
<dt>-Q query_option <a name="man_005fssh_005fssh-_002dQ-query_005foption"></a></dt>
<dd><p>Запрашивает ssh для алгоритмов, поддерживаемых для указанной версии 2.
             Доступные функции:
</p><div class="display">
<pre class="display">             cipher (поддерживаемые симметричные шифры),
             cipher-auth (поддерживаемые симметричные шифры, которые поддерживают
             аутентифицированное шифрование),
             mac (поддерживаемые коды целостности сообщений),
             kex (алгоритмы обмена ключами) ),
             key (типы ключей),
             key-cert (типы ключей сертификатов),
             key-plain (типы ключей без сертификатов) и
             protocol-version (поддерживаемые версии протокола SSH).
</pre></div>
</dd>
<dt>-q <a name="man_005fssh_005fssh-q"></a></dt>
<dd><p>Бесшумный режим. Вызывает подавление большинства предупреждений и
             диагностических сообщений.
</p></dd>
<dt>Перенаправление удаленного соединения <a name="man_005fssh_005fssh-_041f_0435_0440_0435_043d_0430_043f_0440_0430_0432_043b_0435_043d_0438_0435-_0443_0434_0430_043b_0435_043d_043d_043e_0433_043e-_0441_043e_0435_0434_0438_043d_0435_043d_0438_044f"></a></dt>
<dd><div class="display">
<pre class="display">     -R [bind_address:]port:host:hostport
     -R [bind_address:]port:local_socket
     -R remote_socket:host:hostport
     -R remote_socket:local_socket
</pre></div>
<p>Указывает, что соединения с указанным портом TCP или сокетом Unix на
             удаленном (серверном) хосте должны перенаправляться на данный хост и порт
             или сокет Unix на локальной стороне. Это работает путем выделения сокета
             для прослушивания либо порта TCP, либо сокета Unix на удаленной стороне.
             Всякий раз, когда устанавливается соединение с этим портом или сокетом Unix,
             соединение перенаправляется по безопасному каналу, и соединение
             устанавливается либо с хост-портом хоста, либо с local_socket с
             локальной машины.
</p>
<p>Переадресация портов также может быть указана в файле конфигурации.
             Привилегированные порты могут быть перенаправлены только при входе в систему
             как root на удаленной машине. Адреса IPv6 можно указать, заключив адрес
             в квадратные скобки.
</p>
<p>По умолчанию прослушивающие сокеты TCP на сервере будут привязаны только
             к интерфейсу обратной связи. Это может быть отменено указанием bind_address.
             Пустой bind_address или адрес ‘*’ указывает, что удаленный сокет должен
             прослушивать все интерфейсы. Задание удаленного bind_address будет успешным,
             только если включена опция GatewayPorts на сервере(смотри sshd_config(5)).
</p>
<p>Если аргумент порта - ‘0’, порт прослушивания будет динамически выделяться
             на сервере и сообщаться клиенту во время выполнения. При использовании
             вместе с -O forward выделенный порт будет выведен на стандартный вывод.
</p>
</dd>
<dt>-S ctl_path <a name="man_005fssh_005fssh-_002dS-ctl_005fpath"></a></dt>
<dd><p>Определяет расположение управляющего сокета для разделения соединений или
             строку “none” для отключения совместного использования соединений.
             Обратитесь к описанию ControlPath и ControlMaster в
             ssh_config(5) для деталей.
</p>
</dd>
<dt>-s <a name="man_005fssh_005fssh-s"></a></dt>
<dd><p>Может использоваться для запроса вызова подсистемы в удаленной системе.
             Подсистемы облегчают использование SSH в качестве безопасного транспорта
             для других приложений (например, sftp(1)). Подсистема указана как
             удаленная команда.
</p>
</dd>
<dt>-T <a name="man_005fssh_005fssh-T"></a></dt>
<dd><p>Отключить выделение псевдо-терминала.
</p>
</dd>
<dt>-t <a name="man_005fssh_005fssh-t"></a></dt>
<dd><p>Принудительное псевдо-терминальное размещение. Это может использоваться
             для выполнения произвольных программ на экране на удаленном компьютере,
             что может быть очень полезным, например, при реализации сервисов меню.
             Несколько опций -t вызывают распределение tty, даже если ssh не имеет
             локального tty.
</p>
</dd>
<dt>-V <a name="man_005fssh_005fssh-V"></a></dt>
<dd><p>Показать номер версии и выйти.
</p>
</dd>
<dt>-v <a name="man_005fssh_005fssh-v"></a></dt>
<dd><p>Детальный режим. Заставляет ssh печатать отладочные сообщения о его
             ходе. Это полезно при отладке проблем с подключением, аутентификацией
             и настройкой. Несколько опций -v увеличивают многословие. Максимум 3.
</p>
</dd>
<dt>-W host:port <a name="man_005fssh_005fssh-_002dW-host_003aport"></a></dt>
<dd><p>Просит, чтобы стандартный ввод и вывод на клиенте был перенаправлен на хост
             через порт по безопасному каналу. Подразумевает -N, -T, ExitOnForwardFailure
             и ClearAllForwardings.
</p>
</dd>
<dt>-w local_tun[:remote_tun] <a name="man_005fssh_005fssh-_002dw-local_005ftun_005b_003aremote_005ftun_005d"></a></dt>
<dd><p>Запрашивает переадресацию туннельных устройств с указанными устройствами
             tun(4) между клиентом (local_tun) и сервером (remote_tun).
</p>
<p>Устройства могут быть указаны с помощью числового идентификатора или
             ключевого слова “any”, которое использует следующее доступное туннельное
             устройство. Если remote_tun не указан, по умолчанию используется “any”.
             См. Также директивы Tunnel и TunnelDevice в ssh_config(5). Если директива
             Tunnel не установлена, она устанавливается в режим туннеля по умолчанию,
             то есть “point-to-point”.
</p>
</dd>
<dt>-X <a name="man_005fssh_005fssh-X"></a></dt>
<dd><p>Включает пересылку X11. Это также может быть указано для каждого хоста
             в файле конфигурации.
</p>
<p>Пересылка X11 должна быть включена с осторожностью. Пользователи с
             возможностью обхода прав доступа к файлам на удаленном хосте (для базы
             данных авторизации X пользователя) могут получить доступ к локальному
             дисплею X11 через переадресованное соединение. Затем злоумышленник сможет
             выполнять такие действия, как мониторинг нажатия клавиш.
</p>
<p>По этой причине пересылка X11 по умолчанию ограничена расширением
             X11 SECURITY. Пожалуйста, обратитесь к опции ssh -Y и директиве
             ForwardX11Trusted в ssh_config(5) для получения
             дополнительной информации.
</p>
<p>(Специфично для Debian: на пересылку X11 по умолчанию не распространяются
             ограничения расширения X11 SECURITY, поскольку в этом режиме в настоящий
             момент происходит сбой слишком многих программ. Установите для параметра
             ForwardX11Trusted значение “no”, чтобы восстановить поведение восходящего
             потока. Это может измениться в будущем в зависимости от клиента. побочные
             улучшения.)
</p>
</dd>
<dt>-x <a name="man_005fssh_005fssh-x"></a></dt>
<dd><p>Отключает пересылку X11.
</p>
</dd>
<dt>-Y <a name="man_005fssh_005fssh-Y"></a></dt>
<dd><p>Включает доверенную пересылку X11. Переадресация доверенных X11 не
             контролируется расширением X11 SECURITY.
</p>
<p>(Специфично для Debian: эта опция ничего не делает в конфигурации по
             умолчанию: она эквивалентна “ForwardX11Trusted yes”, который является
             значением по умолчанию, как описано выше. Установите параметр
             ForwardX11Trusted в “no”, чтобы восстановить поведение восходящего потока.
             Это может измениться в будущем в зависимости от клиента усовершенствования.)
</p>
</dd>
<dt>-y <a name="man_005fssh_005fssh-y"></a></dt>
<dd><p>Отправьте информацию журнала с помощью системного модуля syslog(3). По
             умолчанию эта информация отправляется в stderr.
</p>
<p>ssh может дополнительно получить данные конфигурации из файла конфигурации для
     каждого пользователя и общесистемного файла конфигурации. Формат файла и параметры
     конфигурации описаны в ssh_config (5).
</p></dd>
</dl>
</dd>
<dt>AUTHENTICATION</dt>
<dd><p>SSSS-клиент OpenSSH поддерживает протоколы SSH 1 и 2. По умолчанию
     используется только протокол 2, хотя это можно изменить с помощью
     параметра Protocol в параметрах ssh_config(5) или -1 и -2 (см. Выше).
     Протокол 1 не должен использоваться и предлагается только для поддержки
     устаревших устройств. Он страдает от ряда криптографических недостатков и
     не поддерживает многие расширенные функции, доступные для протокола 2.
</p>
<p>Для аутентификации доступны следующие методы: аутентификация на основе
     GSSAPI, аутентификация на основе хоста, аутентификация с открытым ключом,
     аутентификация по запросу и аутентификации по паролю. Методы аутентификации
     пробуются в указанном выше порядке, хотя PreferredAuthentications может
     использоваться для изменения порядка по умолчанию.
</p>
<p>Аутентификация на основе хоста работает следующим образом: если машина,
     с которой пользователь входит в систему, указана в списке /etc/hosts.equiv
     или /etc/ssh/shosts.equiv на удаленном компьютере, а имена пользователей
     совпадают с обеих сторон или если файлы ~/.rhosts или ~/.shosts существуют
     в домашнем хранилище пользователя каталог на удаленном компьютере и содержит
     строку, содержащую имя клиентского компьютера и имя пользователя на этом
     компьютере, пользователь считается для входа в систему. Кроме того, сервер
     должен иметь возможность проверять ключ хоста клиента (см. Описание
     /etc/ssh/ssh_known_hosts и ~/.ssh/known_hosts ниже), чтобы разрешить вход
     в систему. Этот метод аутентификации закрывает дыры в безопасности из-за
     спуфинга IP, спуфинга DNS и спуфинга маршрутизации. [Примечание для
     администратора: /etc/hosts.equiv, ~/.rhosts и протокол rlogin/rsh в целом
     являются изначально опасными и должны быть отключены, если требуется
     безопасность.]
</p>
<p>Аутентификация с открытым ключом работает следующим образом: схема основана
     на криптографии с открытым ключом, использующей криптосистемы, где шифрование
     и дешифрование выполняются с использованием отдельных ключей, и невозможно
     получить ключ дешифрования из ключа шифрования. Идея состоит в том, что каждый
     пользователь создает пару открытый/закрытый ключ для аутентификации. Сервер
     знает открытый ключ, и только пользователь знает закрытый ключ. ssh
     автоматически реализует протокол аутентификации с открытым ключом, используя
     один из алгоритмов DSA, ECDSA, Ed25519 или RSA. Раздел HISTORY в ssl(8)
     (на не-OpenBSD системах,  смотри
     http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8#HISTORY) содержит
     краткое обсуждение алгоритмов DSA и RSA.
</p>
<p>В файле ~/.ssh/authorized_keys перечислены открытые ключи, которые разрешены
     для входа. Когда пользователь входит в систему, программа ssh сообщает серверу,
     какую пару ключей он хотел бы использовать для аутентификации. Клиент подтверждает,
     что у него есть доступ к закрытому ключу, а сервер проверяет, разрешено ли
     соответствующему открытому ключу принять учетную запись.
</p>
<p>Пользователь создает свою пару ключей, запустив ssh-keygen(1). Это хранит закрытый
     ключ в:
</p><div class="display">
<pre class="display">           ~/.ssh/identity (protocol 1),
           ~/.ssh/id_dsa (DSA),
           ~/.ssh/id_ecdsa (ECDSA),
           ~/.ssh/id_ed25519 (Ed25519), или
           ~/.ssh/id_rsa (RSA)

     и хранит открытый ключ в:
           ~/.ssh/identity.pub (protocol 1),
           ~/.ssh/id_dsa.pub (DSA),
           ~/.ssh/id_ecdsa.pub (ECDSA),
           ~/.ssh/id_ed25519.pub (Ed25519), или
           ~/.ssh/id_rsa.pub (RSA)
</pre></div>
<p>в домашнем каталоге пользователя. Затем пользователь должен скопировать
     открытый ключ в ~/.ssh/authorized_keys в своем домашнем каталоге на
     удаленном компьютере. Файл author_keys соответствует обычному ~/.rhosts file
     и имеет один ключ на строку, хотя строки могут быть очень длинными. После
     этого пользователь может войти без указания пароля.
</p>
<p>Вариант аутентификации с открытым ключом доступен в форме аутентификации: вместо
     набора открытых/закрытых ключей используются подписанные сертификаты. Преимущество
     этого заключается в том, что вместо многих открытых/закрытых ключей можно
     использовать один доверенный центр сертификации. См. Раздел CERTIFICATES в
     ssh-keygen(1) для получения дополнительной информации.
</p>
<p>Наиболее удобный способ использовать открытый ключ или проверку подлинности
     сертификата может быть с агентом проверки подлинности. См. Ssh-agent (1) и
     (необязательно) директиву AddKeysToAgent в ssh_config(5) для получения
     дополнительной информации.
</p>
<p>Аутентификация по запросу-ответу работает следующим образом: сервер
     отправляет произвольный текст &quot;challenge&quot; и запрашивает ответ. Примеры
     аутентификации «запрос-ответ» включают BSD Authentication (см. login.conf(5))
     и PAM (некоторые не-OpenBSD системы).
</p>
<p>Наконец, в случае сбоя других методов аутентификации ssh запрашивает у
     пользователя пароль. Пароль отправляется на удаленный хост для проверки;
     однако, так как все коммуникации зашифрованы, пароль не может быть виден
     кем-то, кто слушает в сети.
</p>
<p>ssh автоматически поддерживает и проверяет базу данных, содержащую идентификацию
     всех хостов, с которыми она когда-либо использовалась. Ключи хоста хранятся в
     ~/.ssh/known_hosts в домашнем каталоге пользователя. Кроме того, файл
     /etc/ssh/ssh_known_hosts автоматически проверяется на наличие известных хостов.
     Любые новые хосты автоматически добавляются в файл пользователя.  Если
     идентификация хоста когда-либо изменяется, ssh предупреждает об этом и
     отключает аутентификацию по паролю, чтобы предотвратить подделку сервера или
     атаки «человек посередине», которые в противном случае могли бы использоваться
     для обхода шифрования. Опция StrictHostKeyChecking может использоваться
     для управления входами в систему на компьютерах, ключ хоста которых
     неизвестен или изменился.
</p>
<p>Когда идентификация пользователя была принята сервером, сервер либо
     выполняет данную команду в неинтерактивном сеансе, либо, если команда
     не указана, входит в систему на компьютере и предоставляет пользователю
     обычную оболочку в виде интерактивного сеанса. Вся связь с удаленной
     командой или оболочкой будет автоматически зашифрована.
</p>
<p>Если интерактивный сеанс запрашивается, ssh по умолчанию будет запрашивать
     псевдотерминал (pty) только для интерактивных сеансов, когда он у клиента.
     Флаги -T и -t могут быть использованы для переопределения этого поведения.
</p>
<p>Если псевдотерминал был выделен, пользователь может использовать escape-символы,
     указанные ниже.
</p>
<p>Если псевдотерминал не был выделен, сеанс прозрачен и может использоваться
     для надежной передачи двоичных данных. В большинстве систем установка
     escape-символа “none” также сделает сеанс прозрачным, даже если
     используется tty.
</p>
<p>Сеанс завершается, когда команда или оболочка на удаленной машине завершаются,
     и все соединения X11 и TCP были закрыты.
</p>
</dd>
<dt>ESCAPE CHARACTERS</dt>
<dd><p>Когда запрашивается псевдотерминал, ssh поддерживает ряд функций, используя
     escape-символ.
</p>
<p>Один символ тильды может быть отправлен как ~~ или после тильды за символом,
     отличным от описанного ниже. Экранирующий символ всегда должен следовать за
     новой строкой, чтобы интерпретироваться как специальный. Экранирующий символ
     может быть изменен в файлах конфигурации с помощью директивы конфигурации
     EscapeChar или в командной строке с помощью опции -e.
</p>
<p>Поддерживаемое экранирование (при условии использования ‘~’ по умолчанию):
</p><dl compact="compact">
<dt>~.</dt>
<dd><p>Отключить.
</p>
</dd>
<dt>~^Z</dt>
<dd><p>SSH в фоновом режиме.
</p>
</dd>
<dt>~#</dt>
<dd><p>Список переадресованных соединений.
</p>
</dd>
<dt>~&amp;</dt>
<dd><p>Фоновый ssh ​​при выходе из системы при ожидании завершения сеансов
             переадресованного соединения/X11.
</p>
</dd>
<dt>~?</dt>
<dd><p>Показать список escape-символов.
</p>
</dd>
<dt>~B</dt>
<dd><p>Отправьте BREAK в удаленную систему (полезно только в том случае, если
             узел поддерживает его).
</p>
</dd>
<dt>~C</dt>
<dd><p>Откройте командную строку. В настоящее время это позволяет добавлять
             переадресацию портов с использованием параметров -L, -R и -D (см. Выше).
             Это также позволяет отменять существующие переадресации портов с помощью:
</p><div class="display">
<pre class="display">             -KL[bind_address:]port для локальных,
             -KR[bind_address:]port для удаленных и
             -KD[bind_address:]port для динамических переадресаций портов.
</pre></div>
<p>!command позволяет пользователю выполнять локальную команду, если в
             ssh_config(5) включена опция PermitLocalCommand. Базовая помощь
             доступна с использованием опции -h.
</p>
</dd>
<dt>~R</dt>
<dd><p>Запросить повторное соединение (полезно, только если узел поддерживает его).
</p>
</dd>
<dt>~V</dt>
<dd><p>Уменьшите детализацию (LogLevel), когда ошибки записываются в stderr.
</p>
</dd>
<dt>~v</dt>
<dd><p>Увеличьте детализацию (LogLevel), когда ошибки записываются в stderr.
</p></dd>
</dl>
</dd>
<dt>TCP FORWARDING</dt>
<dd><p>Пересылка произвольных TCP-соединений по безопасному каналу может быть указана
     либо в командной строке, либо в файле конфигурации. Одним из возможных применений
     пересылки TCP является защищенное соединение с почтовым сервером; другой проходит
     через брандмауэры.
</p>
<p>В приведенном ниже примере мы рассмотрим шифрование связи между клиентом и
     сервером IRC, даже если сервер IRC не поддерживает напрямую зашифрованную связь.
     Это работает следующим образом: пользователь подключается к удаленному хосту,
     используя ssh, указывая порт, который будет использоваться для переадресации
     соединений на удаленный сервер. После этого можно запустить службу, которая
     должна быть зашифрована на клиентском компьютере, подключаясь к тому же
     локальному порту, и ssh зашифрует и перешлет соединение.
</p>
<p>В следующем примере туннелируется сеанс IRC с клиентского компьютера
     “127.0.0.1” (localhost) на удаленный сервер “server.example.com”:
</p><div class="display">
<pre class="display">         $ ssh -f -L 1234:localhost:6667 server.example.com sleep 10
         $ irc -c &rsquo;#users&rsquo; -p 1234 pinky 127.0.0.1
</pre></div>
<p>Это туннелирует соединение с IRC-сервером “server.example.com”, соединяя
     канал “#users” с псевдонимом «pinky», используя порт 1234. Неважно, какой
     порт используется, если он больше 1023 (помните, только root может открывать
     сокеты на привилегированных портах ) и не конфликтует с портами, которые
     уже используются. Соединение перенаправляется на порт 6667 на удаленном
     сервере, поскольку это стандартный порт для служб IRC.
</p>
<p>Опция -f запускает в фоне ssh и удаленную команду “sleep 10”, чтобы дать время
     (10 секунд, в примере) для запуска службы, которая должна быть туннелирована.
     Если в течение указанного времени соединения не установлены, ssh завершит работу.
</p>
</dd>
<dt>X11 FORWARDING</dt>
<dd><p>Если для переменной ForwardX11 установлено значение “yes” (или см. Описание
     параметров -X, -x, и -Y выше), а пользователь использует X11 (установлена ​​
     переменная окружения DISPLAY), соединение с дисплеем X11 автоматически
     перенаправляется на удаленную сторону таким образом, что любые программы X11,
     запущенные из оболочки (или команды), будут проходить через зашифрованный
     канал, а соединение с реальным сервером X будет осуществляться с локальной
     машины. Пользователь не должен вручную устанавливать DISPLAY. Переадресацию
     соединений X11 можно настроить в командной строке или в файлах конфигурации.
</p>
<p>Значение DISPLAY, установленное ssh, будет указывать на сервер, но с
     номером дисплея больше нуля. Это нормально и происходит потому, что
     ssh создает сервер “proxy” X на сервере для пересылки соединений по
     зашифрованному каналу.
</p>
<p>ssh также автоматически настроит данные Xauthority на компьютере сервера. Для
     этого он сгенерирует случайный cookie-файл авторизации, сохранит его в
     Xauthority на сервере и проверит, что все переадресованные соединения содержат
     этот cookie-файл, и заменит его реальным cookie-файлом при открытии соединения.
     Настоящий куки-файл аутентификации никогда не отправляется на сервер (и в
     обычном режиме куки не отправляются).
</p>
<p>Если для переменной ForwardAgent задано значение “yes” (или см. Описание
     параметров -A и -a выше) и пользователь использует агент аутентификации,
     соединение с агентом автоматически перенаправляется на удаленную сторону.
</p>
</dd>
<dt>VERIFYING HOST KEYS</dt>
<dd><p>При первом подключении к серверу пользователю предоставляется отпечаток
     открытого ключа сервера (если не включена опция StrictHostKeyChecking).
     Отпечатки ключа могут быть определены с помощью ssh-keygen(1):
</p><div class="display">
<pre class="display">           $ ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key
</pre></div>
<p>Если отпечаток ключа уже известен, его можно сопоставить, а ключ можно принять
     или отклонить. Если для сервера доступны только устаревшие (MD5) отпечатки
     ключей, можно использовать опцию ssh-keygen (1) -E для понижения алгоритма
     идентификации для соответствия.
</p>
<p>Из-за сложности сравнения ключей хоста, просто взглянув на строки отпечатка ключа,
     существует также поддержка визуального сравнения ключей хоста с использованием
     произвольной графики. Если для параметра VisualHostKey установлено значение “yes”,
     при каждом входе на сервер небольшое изображение ASCII отображается независимо от
     того, является ли сеанс интерактивным или нет. Изучая шаблон, который создает
     известный сервер, пользователь может легко обнаружить, что ключ хоста изменился,
     когда отображается совершенно другой шаблон. Однако, поскольку эти шаблоны не
     являются однозначными, шаблон, который похож на запомненный шаблон, только дает
     хорошую вероятность того, что ключ хоста является тем же, а не гарантированным
     доказательством.
</p>
<p>Чтобы получить список отпечатков ключей и их случайный рисунок для всех
     известных хостов, можно использовать следующую командную строку:
</p><div class="display">
<pre class="display">           $ ssh-keygen -lv -f ~/.ssh/known_hosts
</pre></div>
<p>Если отпечаток пальца неизвестен, доступен альтернативный метод проверки: отпечатки
     ключей SSH проверяются DNS. Дополнительная запись ресурса (RR), SSHFP, добавляется
     в файл зоны, и подключающийся клиент может сопоставить отпечаток с указанным ключом.
</p>
<p>В этом примере мы подключаем клиента к серверу “host.example.com”. Записи
     ресурса SSHFP сначала должны быть добавлены в файл зоны для host.example.com:
</p><div class="display">
<pre class="display">           $ ssh-keygen -r host.example.com.
</pre></div>
<p>Выходные строки должны быть добавлены в файл зоны. Чтобы убедиться, что зона
     отвечает на запросы отпечатков ключей:
</p><div class="display">
<pre class="display">           $ dig -t SSHFP host.example.com
</pre></div>
<p>Наконец клиент подключается:
</p><div class="display">
<pre class="display">           $ ssh -o &quot;VerifyHostKeyDNS ask&quot; host.example.com
           [...]
           Matching host key fingerprint found in DNS.
           Are you sure you want to continue connecting (yes/no)?
           (Соответствующий отпечаток ключа хоста найден в DNS. Вы
           уверены, что хотите продолжить подключение (да/нет)?)
</pre></div>
<p>См. Параметр VerifyHostKeyDNS в ssh_config(5) для получения
     дополнительной информации.
</p>
</dd>
<dt>SSH-BASED VIRTUAL PRIVATE NETWORKS</dt>
<dd><p>ssh поддерживает туннелирование виртуальной частной сети (VPN) с использованием
     псевдоустройства tun(4), что позволяет безопасно соединять две сети. Параметр
     конфигурации sshd_config (5) PermitTunnel контролирует, поддерживает ли сервер
     это и на каком уровне (трафик уровня 2 или 3).
</p>
<p>В следующем примере клиентская сеть 10.0.50.0/24 соединяется с удаленной сетью
     10.0.99.0/24, используя двухточечное соединение от 10.1.1.1 до 10.1.1.2, при
     условии, что сервер SSH, работающий на шлюзе с удаленной сетью на 192.168.1.15,
     разрешает это.
</p>
<p>На клиенте:
</p><div class="display">
<pre class="display">           # ssh -f -w 0:1 192.168.1.15 true
           # ifconfig tun0 10.1.1.1 10.1.1.2 netmask 255.255.255.252
           # route add 10.0.99.0/24 10.1.1.2
</pre></div>
<p>На сервере:
</p><div class="display">
<pre class="display">           # ifconfig tun1 10.1.1.2 10.1.1.1 netmask 255.255.255.252
           # route add 10.0.50.0/24 10.1.1.1
</pre></div>
<p>Клиентский доступ может быть более точно настроен с помощью файла
     /root/.ssh/authorized_keys (см. Ниже) и опции сервера PermitRootLogin.
     Следующая запись разрешает соединения на устройстве tun (4) 1 от
     пользователя “jane” и на устройстве tun 2 от пользователя “john”,
     если для PermitRootLogin установлено значение “forced-commands-only”:
</p><div class="display">
<pre class="display">       tunnel=&quot;1&quot;,command=&quot;sh /etc/netstart tun1&quot; ssh-rsa ... jane
       tunnel=&quot;2&quot;,command=&quot;sh /etc/netstart tun2&quot; ssh-rsa ... john
</pre></div>
<p>Поскольку настройка на основе SSH влечет за собой значительные издержки,
     она может быть более подходящей для временных настроек, таких как
     беспроводные VPN. Больше постоянных VPN лучше предоставляют такие
     инструменты, как ipsecctl(8) и isakmpd(8).
</p>
</dd>
<dt>ENVIRONMENT</dt>
<dd><p>ssh обычно устанавливает следующие переменные окружения:
</p><dl compact="compact">
<dt>DISPLAY <a name="man_005fssh_005fperemen_005fokruj-DISPLAY"></a></dt>
<dd><p>Переменная DISPLAY указывает местоположение
                           сервера X11. Он автоматически устанавливает ssh
                           для указания значения в форме “hostname:n”, где
                           “hostname” указывает хост, на котором работает
                           оболочка, а ‘n’ - целое число ≥ 1. ssh использует
                           как специальное значение для пересылки соединений X11
                           по защищенному каналу. Пользователь обычно не должен явно
                           устанавливать DISPLAY, так как это сделает соединение X11
                           небезопасным (и потребует от пользователя вручную
                           скопировать все необходимые куки авторизации).
</p>
</dd>
<dt>HOME <a name="man_005fssh_005fperemen_005fokruj-HOME"></a></dt>
<dd><p>Установите путь к домашнему каталогу пользователя.
</p>
</dd>
<dt>LOGNAME <a name="man_005fssh_005fperemen_005fokruj-LOGNAME"></a></dt>
<dd><p>Синоним для USER; установить для совместимости с
                           системами, которые используют эту переменную.
</p>
</dd>
<dt>MAIL <a name="man_005fssh_005fperemen_005fokruj-MAIL"></a></dt>
<dd><p>Установите путь к почтовому ящику пользователя.
</p>
</dd>
<dt>PATH <a name="man_005fssh_005fperemen_005fokruj-PATH"></a></dt>
<dd><p>Установите значение по умолчанию PATH, как указано при
                           компиляции ssh.
</p>
</dd>
<dt>SSH_ASKPASS <a name="man_005fssh_005fperemen_005fokruj-SSH_005fASKPASS"></a></dt>
<dd><p>Если ssh требуется фраза-пароль, она будет считывать
                           фразу-пароль с текущего терминала, если она была запущена
                           с терминала. Если ssh не имеет связанного с ним терминала,
                           но установлены DISPLAY и SSH_ASKPASS, он выполнит программу,
                           указанную SSH_ASKPASS, и откроет окно X11, чтобы прочитать
                           фразу-пароль. Это особенно полезно при вызове ssh из
                           .xsession или связанного скрипта. (Обратите внимание, что
                           на некоторых машинах может потребоваться перенаправить ввод
                           с /dev/null для выполнения этой работы.)
</p>
</dd>
<dt>SSH_AUTH_SOCK <a name="man_005fssh_005fperemen_005fokruj-SSH_005fAUTH_005fSOCK"></a></dt>
<dd><p>Определяет путь к сокету UNIX-домена, используемому
                           для связи с агентом.
</p>
</dd>
<dt>SSH_CONNECTION <a name="man_005fssh_005fperemen_005fokruj-SSH_005fCONNECTION"></a></dt>
<dd><p>Определяет клиентскую и серверную стороны соединения.
                           Переменная содержит четыре значения, разделенных пробелом:
                           IP-адрес клиента, номер порта клиента, IP-адрес сервера и
                           номер порта сервера.
</p>
</dd>
<dt>SSH_ORIGINAL_COMMAND <a name="man_005fssh_005fperemen_005fokruj-SSH_005fORIGINAL_005fCOMMAND"></a></dt>
<dd><p>Эта переменная содержит исходную командную строку, если
                           выполняется принудительная команда. Может использоваться
                           для извлечения исходных аргументов.
</p>
</dd>
<dt>SSH_TTY <a name="man_005fssh_005fperemen_005fokruj-SSH_005fTTY"></a></dt>
<dd><p>Для него задается имя tty (путь к устройству), связанного с
                           текущей оболочкой или командой. Если текущий сеанс не имеет
                           tty, эта переменная не установлена.
</p>
</dd>
<dt>TZ <a name="man_005fssh_005fperemen_005fokruj-TZ"></a></dt>
<dd><p>Эта переменная указывает текущую часовую зону, если она
                           была установлена ​​при запуске демона (то есть демон передает
                           значение новым соединениям).
</p>
</dd>
<dt>USER <a name="man_005fssh_005fperemen_005fokruj-USER"></a></dt>
<dd><p>Установите имя пользователя, входящего в систему.
</p></dd>
</dl>
<p>Кроме того, ssh читает ~/.ssh/environment и добавляет строки формата
     “VARNAME=value” в среду, если файл существует, и пользователям разрешено
     изменять свою среду. Для получения дополнительной информации см. Параметр
     PermitUserEnvironment в sshd_config(5).
</p>
</dd>
<dt>FILES</dt>
<dd><dl compact="compact">
<dt>~/.rhosts <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002erhosts"></a></dt>
<dd><p>Этот файл используется для аутентификации на основе хоста (см. Выше). На
             некоторых машинах этот файл может потребоваться для чтения всем, если
             домашний каталог пользователя находится в разделе NFS, потому что sshd(8)
             читает его как root. Кроме того, этот файл должен принадлежать пользователю
             и не должен иметь права на запись для кого-либо еще. Рекомендуемое
             разрешение для большинства машин - чтение и запись для пользователя
             и недоступно для других.
</p>
</dd>
<dt>~/.shosts <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002eshosts"></a></dt>
<dd><p>Этот файл используется точно так же, как .rhosts, но разрешает
             аутентификацию на основе хоста без разрешения входа с помощью rlogin/rsh.
</p>
</dd>
<dt>~/.ssh/ <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002f"></a></dt>
<dd><p>Этот каталог является местоположением по умолчанию для всей
             пользовательской информации о конфигурации и аутентификации. Не
             существует общего требования хранить все содержимое этого каталога
             в секрете, но рекомендуемые разрешения чтения/записи/выполнения для
             пользователя и недоступны для других.
</p>
</dd>
<dt>~/.ssh/authorized_keys <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fauthorized_005fkeys"></a></dt>
<dd><p>Перечисляет открытые ключи (DSA, ECDSA, Ed25519, RSA), которые можно
             использовать для входа в систему от имени этого пользователя. Формат
             этого файла описан на странице руководства sshd(8). Этот файл не
             является высокочувствительным, но рекомендуемые разрешения для чтения
             и записи для пользователя и недоступны для других.
</p>
</dd>
<dt>~/.ssh/config <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fconfig"></a></dt>
<dd><p>Это файл конфигурации для каждого пользователя. Формат файла и параметры
             конфигурации описаны в ssh_config(5). Из-за возможного злоупотребления
             этот файл должен иметь строгие разрешения: чтение/запись для пользователя
             и недоступность для записи другими. Это может быть доступно для записи
             в группе при условии, что рассматриваемая группа содержит только пользователя.
</p>
</dd>
<dt>~/.ssh/environment <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fenvironment"></a></dt>
<dd><p>Содержит дополнительные определения для переменных среды;
             см. ENVIRONMENT, выше.
</p></dd>
<dt>Файлы закрытых частей ключа аунтификации <a name="man_005fssh_005fperemen_005fokruj-_0424_0430_0439_043b_044b-_0437_0430_043a_0440_044b_0442_044b_0445-_0447_0430_0441_0442_0435_0439-_043a_043b_044e_0447_0430-_0430_0443_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438"></a></dt>
<dd><div class="display">
<pre class="display">     ~/.ssh/identity
     ~/.ssh/id_dsa
     ~/.ssh/id_ecdsa
     ~/.ssh/id_ed25519
     ~/.ssh/id_rsa
</pre></div>
<p>Содержит закрытый ключ для аутентификации. Эти файлы содержат
             конфиденциальные данные и должны быть доступны для чтения
             пользователем, но недоступны для других (чтение/запись/выполнение).
             ssh просто проигнорирует файл закрытого ключа, если он доступен другим.
             Можно указать ключевую фразу при создании ключа, который будет
             использоваться для шифрования конфиденциальной части этого файла
             с использованием 3DES.
</p></dd>
<dt>Файлы открытой части ключа аунтификации <a name="man_005fssh_005fperemen_005fokruj-_0424_0430_0439_043b_044b-_043e_0442_043a_0440_044b_0442_043e_0439-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0430-_0430_0443_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438"></a></dt>
<dd><div class="display">
<pre class="display">     ~/.ssh/identity.pub
     ~/.ssh/id_dsa.pub
     ~/.ssh/id_ecdsa.pub
     ~/.ssh/id_ed25519.pub
     ~/.ssh/id_rsa.pub
</pre></div>
<p>Содержат открытый ключ для аутентификации. Эти файлы не являются
             конфиденциальными и могут (но не обязательно) быть доступными для
             чтения любому.
</p>
</dd>
<dt>~/.ssh/known_hosts <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002fknown_005fhosts"></a></dt>
<dd><p>Содержит список ключей хоста для всех хостов, в которые вошел пользователь,
             которых еще нет в общесистемном списке известных ключей хоста. Смотрите
             sshd(8) для более подробной информации о формате этого файла.
</p>
</dd>
<dt>~/.ssh/rc <a name="man_005fssh_005fperemen_005fokruj-_007e_002f_002essh_002frc"></a></dt>
<dd><p>Команды в этом файле выполняются ssh, когда пользователь входит в систему,
             непосредственно перед запуском оболочки пользователя (или команды).
             Обратитесь к странице справочника sshd(8) за дополнительной информацией.
</p>
</dd>
<dt>/etc/hosts.equiv <a name="man_005fssh_005fperemen_005fokruj-_002fetc_002fhosts_002eequiv"></a></dt>
<dd><p>Этот файл предназначен для аутентификации на основе хоста (см. Выше). Это
             должно быть доступно для записи только пользователю root.
</p>
</dd>
<dt>/etc/ssh/shosts.equiv <a name="man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fshosts_002eequiv"></a></dt>
<dd><p>Этот файл используется точно так же, как hosts.equiv, но допускает
             аутентификацию на основе хоста без разрешения входа с помощью
             rlogin/rsh.
</p>
</dd>
<dt>/etc/ssh/ssh_config <a name="man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fssh_005fconfig"></a></dt>
<dd><p>Общесистемный файл конфигурации. Формат файла и параметры конфигурации
             описаны в ssh_config(5).
</p></dd>
<dt>Файлы закрытой части ключей аунтификации на основании хоста <a name="man_005fssh_005fperemen_005fokruj-_0424_0430_0439_043b_044b-_0437_0430_043a_0440_044b_0442_043e_0439-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0430_0443_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438-_043d_0430-_043e_0441_043d_043e_0432_0430_043d_0438_0438-_0445_043e_0441_0442_0430"></a></dt>
<dd><div class="display">
<pre class="display">     /etc/ssh/ssh_host_key
     /etc/ssh/ssh_host_dsa_key
     /etc/ssh/ssh_host_ecdsa_key
     /etc/ssh/ssh_host_ed25519_key
     /etc/ssh/ssh_host_rsa_key
</pre></div>
<p>Эти файлы содержат приватные части ключей хоста и используются для
             аутентификации на основе хоста.
</p>
</dd>
<dt>/etc/ssh/ssh_known_hosts <a name="man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fssh_005fknown_005fhosts"></a></dt>
<dd><p>Общесистемный список известных ключей хоста. Этот файл должен быть
             подготовлен системным администратором, чтобы он содержал открытые
             ключи хостов всех компьютеров в организации. Это должно быть читаемым
             во всем мире. Смотрите sshd (8) для более подробной информации о
             формате этого файла.
</p>
</dd>
<dt>/etc/ssh/sshrc <a name="man_005fssh_005fperemen_005fokruj-_002fetc_002fssh_002fsshrc"></a></dt>
<dd><p>Команды в этом файле выполняются ssh, когда пользователь входит в
             систему, непосредственно перед запуском оболочки пользователя
             (или команды). Обратитесь к странице справочника sshd(8) за
             дополнительной информацией.
</p></dd>
</dl>
</dd>
<dt>EXIT STATUS</dt>
<dd><p>ssh завершается со статусом выхода удаленной команды или с 255, если
     произошла ошибка.
</p>
</dd>
<dt>SEE ALSO</dt>
<dd><p>scp(1), sftp(1), ssh-add(1), ssh-agent(1), ssh-argv0(1), ssh-keygen(1),
     ssh-keyscan(1), tun(4), ssh_config(5), ssh-keysign(8), sshd(8)
</p>
</dd>
<dt>STANDARDS</dt>
<dd><p>S. Lehtinen and C. Lonvick, The Secure Shell (SSH) Protocol Assigned
     Numbers, RFC 4250, January 2006.
</p>
<p>T. Ylonen and C. Lonvick, The Secure Shell (SSH) Protocol Architecture,
     RFC 4251, January 2006.
</p>
<p>T. Ylonen and C. Lonvick, The Secure Shell (SSH) Authentication Protocol,
     RFC 4252, January 2006.
</p>
<p>T. Ylonen and C. Lonvick, The Secure Shell (SSH) Transport Layer
     Protocol, RFC 4253, January 2006.
</p>
<p>T. Ylonen and C. Lonvick, The Secure Shell (SSH) Connection Protocol, RFC
     4254, January 2006.
</p>
<p>J. Schlyter and W. Griffin, Using DNS to Securely Publish Secure Shell
     (SSH) Key Fingerprints, RFC 4255, January 2006.
</p>
<p>F. Cusack and M. Forssen, Generic Message Exchange Authentication for the
     Secure Shell Protocol (SSH), RFC 4256, January 2006.
</p>
<p>J. Galbraith and P. Remaker, The Secure Shell (SSH) Session Channel Break
     Extension, RFC 4335, January 2006.
</p>
<p>M. Bellare, T. Kohno, and C. Namprempre, The Secure Shell (SSH) Transport
     Layer Encryption Modes, RFC 4344, January 2006.
</p>
<p>B. Harris, Improved Arcfour Modes for the Secure Shell (SSH) Transport
     Layer Protocol, RFC 4345, January 2006.
</p>
<p>M. Friedl, N. Provos, and W. Simpson, Diffie-Hellman Group Exchange for
     the Secure Shell (SSH) Transport Layer Protocol, RFC 4419, March 2006.
</p>
<p>J. Galbraith and R. Thayer, The Secure Shell (SSH) Public Key File
     Format, RFC 4716, November 2006.
</p>
<p>D. Stebila and J. Green, Elliptic Curve Algorithm Integration in the
     Secure Shell Transport Layer, RFC 5656, December 2009.
</p>
<p>A. Perrig and D. Song, Hash Visualization: a New Technique to improve
     Real-World Security, 1999, International Workshop on Cryptographic
     Techniques and E-Commerce (CrypTEC &rsquo;99).
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.
</p>
<p>BSD                            February 17, 2016                           BSD
</p></dd>
</dl>
<hr>
<a name="SSHD"></a>
<div class="header">
<p>
Next: <a href="#SSH_005fCONFIG" accesskey="n" rel="next">SSH_CONFIG</a>, Previous: <a href="#SSH" accesskey="p" rel="prev">SSH</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSHD-1"></a>
<h2 class="chapter">2 SSHD</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>sshd — OpenSSH SSH демон
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>sshd [-<a href="#man_005fssh_005fsshd-4">4</a><a href="#man_005fssh_005fsshd-6">6</a><a href="#man_005fssh_005fsshd-D">D</a><a href="#man_005fssh_005fsshd-d">d</a><a href="#man_005fssh_005fsshd-e">e</a><a href="#man_005fssh_005fsshd-i">i</a><a href="#man_005fssh_005fsshd-q">q</a><a href="#man_005fssh_005fsshd-T">T</a><a href="#man_005fssh_005fsshd-t">t</a>] [<a href="#man_005fssh_005fsshd-_002db-bits">-b bits</a>] [<a href="#man_005fssh_005fsshd-_002dC-connection_005fspec">-C connection_spec</a>]
          [<a href="#man_005fssh_005fsshd-_002dc-host_005fcertificate_005ffile">-c host_certificate_file</a>] [<a href="#man_005fssh_005fsshd-_002dE-log_005ffile">-E log_file</a>] [<a href="#man_005fssh_005fsshd-_002df-config_005ffile">-f config_file</a>]
          [<a href="#man_005fssh_005fsshd-_002dg-login_005fgrace_005ftime">-g login_grace_time</a>] [<a href="#man_005fssh_005fsshd-_002dh-host_005fkey_005ffile">-h host_key_file</a>] [<a href="#man_005fssh_005fsshd-_002dk-key_005fgen_005ftime">-k key_gen_time</a>]
          [<a href="#man_005fssh_005fsshd-_002do-option">-o option</a>] [<a href="#man_005fssh_005fsshd-_002dp-port">-p port</a>] [<a href="#man_005fssh_005fsshd-_002du-len">-u len</a>]
</p></dd>
<dt>Ключевые слова файла аунтификации</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fsshd_005fauth_005ffile-agent_002dforwarding">agent-forwarding</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-cert_002dauthority">cert-authority</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-command_003d_0022command_0022">command=&quot;command&quot;</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-environment_003d_0022NAME_003dvalue_0022">environment=&quot;NAME=value&quot;</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-from_003d_0022pattern_002dlist_0022">from=&quot;pattern-list&quot;</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-no_002dagent_002dforwarding">no-agent-forwarding</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-no_002dport_002dforwarding">no-port-forwarding</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-no_002dpty">no-pty</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-no_002duser_002drc">no-user-rc</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-no_002dX11_002dforwarding">no-X11-forwarding</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-permitopen_003d_0022host_003aport_0022">permitopen=&quot;host:port&quot;</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-port_002dforwarding">port-forwarding</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-principals_003d_0022principals_0022">principals=&quot;principals&quot;</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-pty">pty</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-restrict">restrict</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-tunnel_003d_0022n_0022">tunnel=&quot;n&quot;</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-user_002drc">user-rc</a>
     <a href="#man_005fssh_005fsshd_005fauth_005ffile-X11_002dforwarding">X11-forwarding</a>
</pre></div>
</dd>
<dt>Список Файлов</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002ehushlogin">~/.hushlogin</a>
     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002erhosts">~/.rhosts</a>
     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002eshosts">~/.shosts</a>
     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002f">~/.ssh/</a>
     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002fauthorized_005fkeys">~/.ssh/authorized_keys</a>
     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002fenvironment">~/.ssh/environment</a>
     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002fknown_005fhosts">~/.ssh/known_hosts</a>
     <a href="#man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002frc">~/.ssh/rc</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fhosts_002eallow-_002fetc_002fhosts_002edeny">/etc/hosts.allow  /etc/hosts.deny</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fhosts_002eequiv">/etc/hosts.equiv</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fmoduli">/etc/ssh/moduli</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fmotd">/etc/motd</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fnologin">/etc/nologin</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fshosts_002eequiv">/etc/ssh/shosts.equiv</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041f_0440_0438_0432_0430_0442_043d_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_key</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041f_0440_0438_0432_0430_0442_043d_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_dsa_key</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041f_0440_0438_0432_0430_0442_043d_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_ecdsa_key</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041f_0440_0438_0432_0430_0442_043d_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_ed25519_key</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041f_0440_0438_0432_0430_0442_043d_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_rsa_key</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041e_0442_043a_0440_044b_0442_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_key.pub</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041e_0442_043a_0440_044b_0442_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_dsa_key.pub</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041e_0442_043a_0440_044b_0442_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_ecdsa_key.pub</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041e_0442_043a_0440_044b_0442_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_ed25519_key.pub</a>
     <a href="#man_005fssh_005fsshd_005ffile-_041e_0442_043a_0440_044b_0442_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430">/etc/ssh/ssh_host_rsa_key.pub</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fssh_005fknown_005fhosts">/etc/ssh/ssh_known_hosts</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fsshd_005fconfig">/etc/ssh/sshd_config</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fsshrc">/etc/ssh/sshrc</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fvar_002frun_002fsshd">/var/run/sshd</a>
     <a href="#man_005fssh_005fsshd_005ffile-_002fvar_002frun_002fsshd_002epid">/var/run/sshd.pid</a>
     
</pre></div>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>sshd (OpenSSH Daemon) - это программа-демон для ssh(1). Вместе эти программы заменяют
     rlogin и rsh и обеспечивают безопасную зашифрованную связь между двумя ненадежными
     хостами по небезопасной сети.
</p>
<p>sshd прослушивает соединения от клиентов. Обычно он запускается при загрузке с
     /etc/init.d/ssh (или /etc/init/ssh.conf в системах, использующих демон инициализации
     Upstart). Он создает новый демон для каждого входящего соединения. Разветвленные
     демоны управляют обменом ключами, шифрованием, аутентификацией, выполнением команд и
     обменом данными.
</p>
<p>sshd может быть настроен с использованием параметров командной строки или файла
     конфигурации (по умолчанию sshd_config(5)); параметры командной строки переопределяют
     значения, указанные в файле конфигурации. sshd перечитывает свой файл конфигурации,
     когда он получает сигнал зависания, SIGHUP, выполняя себя с именем и параметрами, с
     которыми он был запущен, например, /usr/sbin/sshd.
</p>
<p>Варианты следующие:
</p><dl compact="compact">
<dt>-4 <a name="man_005fssh_005fsshd-4"></a></dt>
<dd><p>Заставляет sshd использовать только адреса IPv4.
</p>
</dd>
<dt>-6 <a name="man_005fssh_005fsshd-6"></a></dt>
<dd><p>Заставляет sshd использовать только адреса IPv6.
</p>
</dd>
<dt>-b bits <a name="man_005fssh_005fsshd-_002db-bits"></a></dt>
<dd><p>Определяет количество бит в ключе сервера эфемерного протокола версии 1
             (по умолчанию 1024).
</p>
</dd>
<dt>-C connection_spec <a name="man_005fssh_005fsshd-_002dC-connection_005fspec"></a></dt>
<dd><p>Укажите параметры подключения для использования в расширенном тестовом
             режиме -T. Если предусмотрено, любые директивы Match в файле конфигурации,
             которые будут применяться к указанному пользователю, хосту и адресу, будут
             установлены до того, как конфигурация будет записана в стандартный вывод.
             Параметры подключения поставляются в виде пар keyword=value
             (ключевоеСлово=значение). Ключевые слова - “user”, “host”, “laddr”,
             “lport”, и “addr”. Все они обязательны и могут поставляться в любом порядке,
             с несколькими опциями -C или в виде списка через запятую.
</p>
</dd>
<dt>-c host_certificate_file <a name="man_005fssh_005fsshd-_002dc-host_005fcertificate_005ffile"></a></dt>
<dd><p>Указывает путь к файлу сертификата для идентификации sshd во время обмена
             ключами. Файл сертификата должен соответствовать файлу ключа хоста, указанному
             с помощью опции -h или директивы конфигурации HostKey.
</p>
</dd>
<dt>-D <a name="man_005fssh_005fsshd-D"></a></dt>
<dd><p>Если указан этот параметр, sshd не будет отключаться и не станет демоном. Это
             позволяет легко контролировать sshd.
</p>
</dd>
<dt>-d <a name="man_005fssh_005fsshd-d"></a></dt>
<dd><p>Режим отладки. Сервер отправляет подробный отладочный вывод со стандартной
             ошибкой и не помещает себя в фоновый режим. Сервер также не будет
             разветвляться и будет обрабатывать только одно соединение. Эта опция
             предназначена только для отладки на сервере. Несколько опций -d повышают
             уровень отладки. Максимум 3.
</p>
</dd>
<dt>-E log_file <a name="man_005fssh_005fsshd-_002dE-log_005ffile"></a></dt>
<dd><p>Добавьте журналы отладки в log_file вместо системного журнала.
</p>
</dd>
<dt>-e <a name="man_005fssh_005fsshd-e"></a></dt>
<dd><p>Записывать журналы отладки в стандартную ошибку вместо системного журнала.
</p>
</dd>
<dt>-f config_file <a name="man_005fssh_005fsshd-_002df-config_005ffile"></a></dt>
<dd><p>Определяет имя файла конфигурации. По умолчанию используется
             /etc/ssh/sshd_config. sshd отказывается запускаться, если нет
             файла конфигурации.
</p>
</dd>
<dt>-g login_grace_time <a name="man_005fssh_005fsshd-_002dg-login_005fgrace_005ftime"></a></dt>
<dd><p>Предоставляет льготное время для аутентификации клиентов (по умолчанию 120
             секунд). Если клиенту не удается аутентифицировать пользователя в течение
             этих нескольких секунд, сервер отключается и завершает работу. Нулевое
             значение указывает на отсутствие ограничений.
</p>
</dd>
<dt>-h host_key_file <a name="man_005fssh_005fsshd-_002dh-host_005fkey_005ffile"></a></dt>
<dd><p>Указывает файл, из которого читается ключ хоста. Эта опция должна быть
             указана, если sshd не запускается от имени пользователя root (поскольку
             обычные файлы ключей хоста обычно не читаются никем, кроме root). По умолчанию
             используется /etc/ssh/ssh_host_key для версии протокола 1 и
             /etc/ssh/ssh_host_dsa_key, /etc/ssh/ssh_host_ecdsa_key.
             /etc/ssh/ssh_host_ed25519_key и /etc/ssh/ssh_host_rsa_key для протокола
             версии 2. Можно иметь несколько файлов ключей хоста для разных версий
             протокола и алгоритмов ключей хоста.
</p>
</dd>
<dt>-i <a name="man_005fssh_005fsshd-i"></a></dt>
<dd><p>Указывает, что sshd запускается из inetd(8). Если протокол SSH 1 включен,
             sshd обычно не следует запускать из inetd, потому что ему нужно сгенерировать
             ключ сервера, прежде чем он сможет ответить клиенту, а это может занять
             некоторое время. Клиентам, возможно, придется ждать слишком долго, если ключ
             был обновлен каждый раз.
</p>
</dd>
<dt>-k key_gen_time <a name="man_005fssh_005fsshd-_002dk-key_005fgen_005ftime"></a></dt>
<dd><p>Указывает, как часто регенерируется ключ сервера эфемерного протокола
             версии 1 (по умолчанию 3600 секунд или один час). Мотивация для регенерации
             ключа довольно часто заключается в том, что ключ нигде не хранится, и примерно
             через час становится невозможным восстановить ключ для расшифровки
             перехваченных сообщений, даже если машина взломана или физически захвачена.
             Нулевое значение указывает, что ключ никогда не будет восстановлен.
</p>
</dd>
<dt>-o option <a name="man_005fssh_005fsshd-_002do-option"></a></dt>
<dd><p>Может использоваться для задания параметров в формате, используемом в файле
             конфигурации. Это полезно для указания параметров, для которых нет отдельного
             флага командной строки. Для получения полной информации о параметрах и их
             значениях, смотри sshd_config(5).
</p>
</dd>
<dt>-p port <a name="man_005fssh_005fsshd-_002dp-port"></a></dt>
<dd><p>Указывает порт, на котором сервер прослушивает соединения (по умолчанию 22).
             Допускается использование нескольких портов. Порты, указанные в файле
             конфигурации с параметром Port, игнорируются, если указан порт командной
             строки. Порты, указанные с помощью опции ListenAddress, переопределяют порты
             командной строки.
</p>
</dd>
<dt>-q <a name="man_005fssh_005fsshd-q"></a></dt>
<dd><p>Бесшумный режим. Ничего не отправляется в системный журнал. Обычно начало,
             аутентификация и завершение каждого соединения регистрируются.
</p>
</dd>
<dt>-T <a name="man_005fssh_005fsshd-T"></a></dt>
<dd><p>Расширенный тестовый режим. Проверьте правильность файла конфигурации,
             выведите действующую конфигурацию в стандартный вывод и затем выйдите.
             Опционально, правила соответствия могут применяться путем указания параметров
             соединения с использованием одного или нескольких параметров -C.
</p>
</dd>
<dt>-t <a name="man_005fssh_005fsshd-t"></a></dt>
<dd><p>Тестовый режим. Только проверяйте действительность файла конфигурации и
             работоспособность ключей. Это полезно для надежного обновления sshd,
             поскольку параметры конфигурации могут измениться.
</p>
</dd>
<dt>-u len <a name="man_005fssh_005fsshd-_002du-len"></a></dt>
<dd><p>Эта опция используется для указания размера поля в структуре utmp, которая
             содержит имя удаленного хоста. Если разрешенное имя хоста длиннее len, вместо
             него будет использоваться десятичное значение с точками. Это позволяет узлам
             с очень длинными именами узлов, выходящими за пределы этого поля, по-прежнему
             идентифицироваться однозначно. Указание -u0 указывает, что в файл utmp следует
             помещать только десятичные адреса с точками. -u0 также можно использовать для
             предотвращения выполнения sshd запросов DNS, если этого не требует механизм
             или конфигурация аутентификации. Механизмы аутентификации, для которых может
             потребоваться DNS, включают в себя RhostsRSAAuthentication,
             HostbasedAuthentication и используют опцию from=&quot;pattern-list&quot; в файле ключа.
             Параметры конфигурации, для которых требуется DNS, включают использование
             шаблона USER@HOST в AllowUsers или DenyUsers.
</p></dd>
</dl>
</dd>
<dt>AUTHENTICATION</dt>
<dd><p>OpenSSH SSH-демон поддерживает протоколы SSH 1 и 2. По умолчанию используется только
     протокол 2, хотя это можно изменить с помощью опции Protocol в sshd_config(5).
     Протокол 1 не должен использоваться и предлагается только для поддержки устаревших
     устройств.
</p>
<p>Каждый хост имеет специфичный для хоста ключ, используемый для идентификации хоста.
     Частичная прямая защита для протокола 1 обеспечивается через дополнительный ключ
     сервера, обычно 1024 бита, генерируемый при запуске сервера. Этот ключ обычно
     восстанавливается каждый час, если он использовался, и никогда не сохраняется на
     диске. Каждый раз, когда клиент подключается, демон отвечает своими открытыми ключами
     хоста и сервера. Клиент сравнивает ключ хоста RSA с собственной базой данных, чтобы
     убедиться, что он не изменился. Затем клиент генерирует 256-битное случайное число.
     Он шифрует это случайное число, используя ключ хоста и ключ сервера, и отправляет
     зашифрованное число на сервер. Затем обе стороны используют это случайное число в
     качестве ключа сеанса, который используется для шифрования всех дальнейших сообщений
     в сеансе. Остальная часть сеанса шифруется с использованием обычного шифра, в
     настоящее время Blowfish или 3DES, причем 3DES используется по умолчанию. Клиент
     выбирает используемый алгоритм шифрования из предложенных сервером.
</p>
<p>Для протокола 2 прямая защита обеспечивается посредством соглашения о ключе
     Диффи-Хеллмана. Это ключевое соглашение приводит к общему сеансовому ключу. Остальная
     часть сеанса шифруется с использованием симметричного шифра, в настоящее время
     128-битного AES, Blowfish, 3DES, CAST128, Arcfour, 192-битного AES или 256-битного
     AES. Клиент выбирает используемый алгоритм шифрования из предложенных сервером. Кроме
     того, целостность сеанса обеспечивается посредством криптографического кода
     аутентификации сообщений (hmac-md5, hmac-sha1, umac-64, umac-128, hmac -pymm160,
     hmac-sha2-256 или hmac-sha2-512).
</p>
<p>Наконец, сервер и клиент входят в диалог аутентификации. Клиент пытается
     аутентифицировать себя, используя аутентификацию на основе хоста, аутентификацию
     по публичному ключу, аутентификацию по запросу-запросу или аутентификацию по паролю.
</p>
<p>Независимо от типа аутентификации, учетная запись проверяется, чтобы убедиться, что
     она доступна. Учетная запись недоступна, если она заблокирована, указана в DenyUsers
     или ее группа указана в DenyGroups. Определение заблокированной учетной записи зависит
     от системы. Некоторые платформы имеют свою собственную базу данных учетных записей
     (например, AIX), а некоторые модифицируют поле passwd (‘*LK*’ в Solaris и UnixWare,
     ‘*’ в HP-UX, содержащее ‘Nologin’ в Tru64, ведущее ‘*LOCKED*’ во FreeBSD и ведущее
     ‘!’ в большинстве Linux). Если существует требование отключить проверку подлинности
     по паролю для учетной записи, оставляя открытым публичный ключ, тогда в поле passwd
     должно быть указано что-то отличное от этих значений (например, ‘NP’ или ‘*NP*’).
</p>
<p>Если клиент успешно аутентифицирует себя, вводится диалог для подготовки сеанса. В
     это время клиент может запросить такие вещи, как выделение псевдотерминала, пересылка
     соединений X11, переадресация соединений TCP или переадресация соединения агента
     аутентификации по безопасному каналу.
</p>
<p>После этого клиент либо запрашивает оболочку, либо выполняет команду. Затем стороны
     переходят в режим сеанса. В этом режиме любая сторона может отправлять данные в любое
     время, и такие данные пересылаются в/из оболочки или команды на стороне сервера,
     а пользовательский терминал - на стороне клиента.
</p>
<p>Когда пользовательская программа завершает работу и все переадресованные X11 и другие
     соединения закрываются, сервер отправляет клиенту статус завершения команды, и обе
     стороны завершают работу.
</p>
</dd>
<dt>LOGIN PROCESS</dt>
<dd><p>Когда пользователь успешно входит в систему, sshd делает следующее:
</p><div class="display">
<pre class="display">           1.   Если для входа используется tty, а команда не указана, печатается
                время последнего входа в систему и /etc/motd (если это не запрещено
                в файле конфигурации или с помощью ~/.hushlogin; см. Раздел FILES).

           2.   Если логин на tty, записывает время входа.

           3.   Проверяет /etc/nologin; если он существует, печатает содержимое и
                завершает работу (если не root).

           4.   Изменения для запуска с правами обычного пользователя.

           5.   Устанавливает основную среду.

           6.   Читает файл ~/.ssh/environment, если он существует, и пользователям
                разрешено изменять свою среду. Смотрите параметр PermitUserEnvironment
                в sshd_config(5).

           7.   Изменения в домашнем каталоге пользователя.

           8.   Если ~/.ssh/rc существует и опция sshd_config(5) PermitUserRC установлена,
                она запускается; иначе, если /etc/ssh/sshrc существует, запускает его; в
                противном случае работает xauth. Файлы “rc” получают протокол
                аутентификации X11 и cookie при стандартном вводе. Смотрите SSHRC ниже.

           9.   Запускает пользовательскую оболочку или команду. Все команды выполняются
                в оболочке пользователя, как указано в базе данных системных паролей.
</pre></div>
</dd>
<dt>SSHRC</dt>
<dd><p>Если файл ~/.ssh/rc существует, sh(1) запускает его после чтения файлов среды, но до
     запуска оболочки или команды пользователя. Он не должен выдавать никакого вывода на
     стандартный вывод; Вместо этого следует использовать stderr. Если используется
     переадресация X11, она получит пару &quot;proto cookie&quot; на своем стандартном входе (и
     DISPLAY в своей среде). Сценарий должен вызывать xauth(1), потому что sshd не будет
     автоматически запускать xauth для добавления файлов cookie X11.
</p>
<p>Основная цель этого файла - запуск любых процедур инициализации, которые могут
     потребоваться до того, как домашний каталог пользователя станет доступен; AFS
     является частным примером такой среды.
</p>
<p>Этот файл, вероятно, будет содержать некоторый код инициализации, сопровождаемый
     чем-то вроде:
</p><div class="display">
<pre class="display">        if read proto cookie &amp;&amp; [ -n &quot;$DISPLAY&quot; ]; then
                if [ &lsquo;echo $DISPLAY | cut -c1-10&lsquo; = &rsquo;localhost:&rsquo; ]; then
                        # X11UseLocalhost=yes
                        echo add unix:&lsquo;echo $DISPLAY |
                            cut -c11-&lsquo; $proto $cookie
                else
                        # X11UseLocalhost=no
                        echo add $DISPLAY $proto $cookie
                fi | xauth -q -
        fi
</pre></div>
<p>Если этот файл не существует, запускается /etc/ssh/sshrc, и если он также не
     существует, xauth используется для добавления cookie.
</p>
</dd>
<dt>AUTHORIZED_KEYS FILE FORMAT</dt>
<dd><p>AuthorizedKeysFile указывает файлы, содержащие открытые ключи для аутентификации
     с открытым ключом; если эта опция не указана, по умолчанию используется
     ~/.ssh/authorized_keys и ~/.ssh/authorized_keys2. Каждая строка файла содержит
     один ключ (пустые строки и строки, начинающиеся с ‘#’, игнорируются как комментарии).
     Открытые ключи протокола 1 состоят из следующих разделенных пробелами полей:
     параметры, биты, экспонента, модуль, комментарий. Открытый ключ протокола 2 состоит
     из: параметров, типа ключа, ключа в кодировке base64, комментария. Поле параметров
     является необязательным; его наличие определяется тем, начинается ли строка с цифры
     или нет (поле опций никогда не начинается с цифры). Поля биты, экспонента, модуль и
     комментарий дают ключ RSA для версии протокола 1; поле комментария ни для чего не
     используется (но может быть удобным для пользователя, чтобы идентифицировать ключ).
     Для протокола версии 2 тип ключа - “ecdsa-sha2-nistp256”, “ecdsa-sha2-nistp384”,
     “ecdsa-sha2-nistp521”, “ssh-ed25519”, “ssh-dss” или “ssh-rsa”.
</p>
<p>Обратите внимание, что строки в этом файле обычно имеют длину несколько сотен байтов
     (из-за размера кодировки открытого ключа) до предела 8 килобайт, что позволяет
     использовать ключи DSA до 8 килобит и ключи RSA до 16 килобит. Вы не хотите вводить
     их; вместо этого скопируйте файл identity.pub, id_dsa.pub, id_ecdsa.pub,
     id_ed25519.pub, или id_rsa.pub и отредактируйте его.
</p>
<p>sshd обеспечивает минимальный размер модуля ключа RSA для протоколов 1 и 2 протокола
     длиной 768 бит.
</p>
<p>Опции (если есть) состоят из разделенных запятыми спецификаций опций. Пробелы не
     допускаются, кроме как в двойных кавычках. Поддерживаются следующие спецификации
     параметров (обратите внимание, что ключевые слова параметров учитывают регистр):
</p><dl compact="compact">
<dt>agent-forwarding <a name="man_005fssh_005fsshd_005fauth_005ffile-agent_002dforwarding"></a></dt>
<dd><p>Включите переадресацию агента аутентификации, ранее отключенную
             параметром restrict.
</p>
</dd>
<dt>cert-authority <a name="man_005fssh_005fsshd_005fauth_005ffile-cert_002dauthority"></a></dt>
<dd><p>Указывает, что указанный ключ является центром сертификации (CA), которому
             доверяют для проверки подписанных сертификатов для аутентификации
             пользователя.
</p>
<p>Сертификаты могут кодировать ограничения доступа, аналогичные этим ключевым
             параметрам. Если присутствуют как ограничения сертификата, так и параметры
             ключа, применяется наиболее ограничительное объединение.
</p>
</dd>
<dt>command=&quot;command&quot; <a name="man_005fssh_005fsshd_005fauth_005ffile-command_003d_0022command_0022"></a></dt>
<dd><p>Указывает, что команда выполняется всякий раз, когда этот ключ используется
             для аутентификации. Команда, предоставленная пользователем (если есть),
             игнорируется. Команда запускается на pty, если клиент запрашивает pty; в
             противном случае он запускается без tty. Если требуется 8-битный чистый канал,
             нельзя запрашивать pty или указывать no-pty. Цитата может быть включена в
             команду, заключив ее в обратный слеш. Эта опция может быть полезна для
             ограничения определенных открытых ключей для выполнения только определенной
             операции. Пример может быть ключом, который разрешает удаленное резервное
             копирование, но не более того. Обратите внимание, что клиент может указать
             пересылку TCP и/или X11, если они явно не запрещены. Команда, изначально
             предоставленная клиентом, доступна в переменной окружения
             SSH_ORIGINAL_COMMAND. Обратите внимание, что этот параметр применяется к
             выполнению оболочки, команды или подсистемы. Также обратите внимание, что эта
             команда может быть заменена либо директивой ForceCommand sshd_config(5), либо
             командой, встроенной в сертификат.
</p>
</dd>
<dt>environment=&quot;NAME=value&quot; <a name="man_005fssh_005fsshd_005fauth_005ffile-environment_003d_0022NAME_003dvalue_0022"></a></dt>
<dd><p>Указывает, что строка должна быть добавлена ​​в среду при входе в систему с
             использованием этого ключа. Переменные среды, установленные таким образом,
             переопределяют другие значения среды по умолчанию. Допускается несколько
             вариантов этого типа. Обработка среды по умолчанию отключена и управляется с
             помощью опции PermitUserEnvironment. Эта опция автоматически отключается,
             если включен UseLogin.
</p>
</dd>
<dt>from=&quot;pattern-list&quot; <a name="man_005fssh_005fsshd_005fauth_005ffile-from_003d_0022pattern_002dlist_0022"></a></dt>
<dd><p>Указывает, что в дополнение к аутентификации с открытым ключом в списке
             шаблонов, разделенных запятыми, должно присутствовать либо каноническое имя
             удаленного хоста, либо его IP-адрес. Смотрите PATTERNS в ssh_config(5) для
             получения дополнительной информации о шаблонах.
</p>
<p>В дополнение к сопоставлению с подстановочными знаками, которое может
             применяться к именам хостов или адресам, раздел из from может сопоставлять
             адреса IP с использованием CIDR address/masklen нотации.
</p>
<p>Целью этой опции является необязательное повышение безопасности:
             аутентификация с открытым ключом сама по себе не доверяет сети или серверам
             имен или чему-либо (кроме ключа); однако, если кто-то как-то украл ключ, ключ
             позволяет злоумышленнику войти в систему из любой точки мира. Эта
             дополнительная опция делает использование украденного ключа более сложным
             (серверы имен и/или маршрутизаторы должны быть скомпрометированы в
             дополнение только к ключу).
</p>
</dd>
<dt>no-agent-forwarding <a name="man_005fssh_005fsshd_005fauth_005ffile-no_002dagent_002dforwarding"></a></dt>
<dd><p>Запрещает переадресацию агента аутентификации, когда этот ключ используется
             для аутентификации.
</p>
</dd>
<dt>no-port-forwarding <a name="man_005fssh_005fsshd_005fauth_005ffile-no_002dport_002dforwarding"></a></dt>
<dd><p>Запрещает пересылку TCP, когда этот ключ используется для аутентификации.
             Любые запросы клиента на переадресацию порта будут возвращать ошибку. Это
             может быть использовано, например, в связи с опцией команды.
</p>
</dd>
<dt>no-pty <a name="man_005fssh_005fsshd_005fauth_005ffile-no_002dpty"></a></dt>
<dd><p>Предотвращает распределение tty (запрос на выделение pty не будет выполнен).
</p>
</dd>
<dt>no-user-rc <a name="man_005fssh_005fsshd_005fauth_005ffile-no_002duser_002drc"></a></dt>
<dd><p>Отключает выполнение ~/.ssh/rc.
</p>
</dd>
<dt>no-X11-forwarding <a name="man_005fssh_005fsshd_005fauth_005ffile-no_002dX11_002dforwarding"></a></dt>
<dd><p>Запрещает пересылку X11, когда этот ключ используется для аутентификации.
             Любые запросы клиента X11 на пересылку возвращают ошибку.
</p>
</dd>
<dt>permitopen=&quot;host:port&quot; <a name="man_005fssh_005fsshd_005fauth_005ffile-permitopen_003d_0022host_003aport_0022"></a></dt>
<dd><p>Ограничьте переадресацию локального порта с помощью ssh(1) -L, чтобы он
             мог подключаться только к указанному хосту и порту. Адреса IPv6 можно указать,
             заключив адрес в квадратные скобки. Можно использовать несколько вариантов
             разрешения, разделенных запятыми. Для указанных имен хостов не выполняется
             сопоставление шаблонов, они должны быть буквальными доменами или адресами.
             Спецификация порта * соответствует любому порту.
</p>
</dd>
<dt>port-forwarding <a name="man_005fssh_005fsshd_005fauth_005ffile-port_002dforwarding"></a></dt>
<dd><p>Включить переадресацию портов, ранее отключенную ограничением
</p>
</dd>
<dt>principals=&quot;principals&quot; <a name="man_005fssh_005fsshd_005fauth_005ffile-principals_003d_0022principals_0022"></a></dt>
<dd><p>В строке удостоверяющего центра указываются разрешенные участники для
             удостоверяющей аутентификации в виде списка через запятую. Для принятия
             сертификата в списке сертификатов должно быть указано хотя бы одно имя из
             списка. Эта опция игнорируется для ключей, которые не помечены как доверенные
             подписчики сертификатов при использовании опции cert-author.
</p>
</dd>
<dt>pty <a name="man_005fssh_005fsshd_005fauth_005ffile-pty"></a></dt>
<dd><p>Разрешает распределение tty, ранее отключенное опцией restrict.
</p>
</dd>
<dt>restrict <a name="man_005fssh_005fsshd_005fauth_005ffile-restrict"></a></dt>
<dd><p>Включите все ограничения, то есть отключите порт, агент и переадресацию X11,
             а также отключите распределение PTY и выполнение ~/.ssh/rc. Если какие-либо
             будущие возможности ограничения будут добавлены в файлы authorized_keys, они
             будут включены в этот набор.
</p>
</dd>
<dt>tunnel=&quot;n&quot; <a name="man_005fssh_005fsshd_005fauth_005ffile-tunnel_003d_0022n_0022"></a></dt>
<dd><p>Принудительно подключите устройство tun(4) к серверу. Без этой опции будет
             использоваться следующее доступное устройство, если клиент
             запрашивает туннель.
</p>
</dd>
<dt>user-rc <a name="man_005fssh_005fsshd_005fauth_005ffile-user_002drc"></a></dt>
<dd><p>Включает выполнение ~/.ssh/rc, ранее отключенного опцией restrict.
</p>
</dd>
<dt>X11-forwarding <a name="man_005fssh_005fsshd_005fauth_005ffile-X11_002dforwarding"></a></dt>
<dd><p>Разрешает переадресацию X11, ранее отключенную опцией restrict.
</p></dd>
</dl>
<p>Пример файла author_keys:
</p><div class="display">
<pre class="display">        # Комментарии разрешены в начале строки
        ssh-rsa AAAAB3Nza...LiPk== user@example.net
        from=&quot;*.sales.example.net,!pc.sales.example.net&quot; ssh-rsa
        AAAAB2...19Q== john@example.net
        command=&quot;dump /home&quot;,no-pty,no-port-forwarding ssh-dss
        AAAAC3...51R== example.net
        permitopen=&quot;192.0.2.1:80&quot;,permitopen=&quot;192.0.2.2:25&quot; ssh-dss
        AAAAB5...21S==
        tunnel=&quot;0&quot;,command=&quot;sh /etc/netstart tun0&quot; ssh-rsa AAAA...==
        jane@example.net
        restrict,command=&quot;uptime&quot; ssh-rsa AAAA1C8...32Tv==
        user@example.net
        restrict,pty,command=&quot;nethack&quot; ssh-rsa AAAA1f8...IrrC5==
        user@example.net
</pre></div>
</dd>
<dt>SSH_KNOWN_HOSTS FILE FORMAT</dt>
<dd><p>Файлы /etc/ssh/ssh_known_hosts и ~/.ssh/known_hosts содержат открытые ключи
     хостов для всех известных хостов. Глобальный файл должен быть подготовлен
     администратором (необязательно), а файл для каждого пользователя поддерживается
     автоматически: всякий раз, когда пользователь подключается с неизвестного хоста,
     его ключ добавляется в файл для каждого пользователя.
</p>
<p>Каждая строка в этих файлах содержит следующие поля: markers (optional),
     hostnames, bits, exponent, modulus, comment. Поля разделены пробелами.
</p>
<p>Маркер является необязательным, но если он присутствует, то он должен быть одним
     из “@cert-authority”, чтобы указать, что строка содержит ключ центра сертификации
     (CA), или “@revoked”, чтобы указать, что ключ, содержащийся в строке, отозван и
     не должен когда-либо быть принятым. В ключевой строке должен использоваться только
     один маркер.
</p>
<p>Имена хостов - это список шаблонов, разделенных запятыми (‘*’ и ‘?’ выступают в
     качестве подстановочных знаков); каждый шаблон в свою очередь сопоставляется с
     каноническим именем хоста (при аутентификации клиента) или с предоставленным
     пользователем именем (при аутентификации сервера). Образцу также может предшествовать
     ‘!’ для обозначения отрицания: если имя хоста соответствует отрицательному шаблону,
     оно не принимается (этой строкой), даже если оно соответствует другому шаблону в
     строке. Имя хоста или адрес могут быть заключены в квадратные скобки ‘[’ и ‘]’,
     за которыми следует ‘:’ и нестандартный номер порта.
</p>
<p>Альтернативно, имена хостов могут храниться в хешированной форме, которая скрывает
     имена хостов и адреса, если содержимое файла будет раскрыто. Хэшированные имена
     хостов начинаются с символа ‘|’. В одной строке может отображаться только одно
     хэшированное имя хоста, и ни один из указанных выше операторов отрицания или
     подстановочных знаков не может быть применен.
</p>
<p>Биты, экспонента и модуль берутся непосредственно из ключа хоста RSA; они могут быть
     получены, например, из /etc/ssh/ssh_host_key.pub. Необязательное поле комментария
     продолжается до конца строки и не используется.
</p>
<p>Строки, начинающиеся с ‘#’ и пустые строки, игнорируются как комментарии.
</p>
<p>При выполнении аутентификации хоста аутентификация принимается, если любая
     совпадающая строка имеет правильный ключ; либо тот, который точно соответствует,
     либо, если сервер предоставил сертификат для аутентификации, ключ центра сертификации,
     подписавшего сертификат. Чтобы ключ был доверенным как центр сертификации, он должен
     использовать маркер «@ cert-author», описанный выше.
</p>
<p>Известный файл hosts также предоставляет возможность помечать ключи как отозванные,
     например, когда известно, что связанный закрытый ключ был украден. Отмененные ключи
     указываются с помощью маркера “@revoked” в начале ключевой строки и никогда не
     принимаются для аутентификации или в качестве центра сертификации, но вместо этого
     выдают предупреждение от ssh(1) при их обнаружении.
</p>
<p>Допустимо (но не рекомендуется) иметь несколько строк или разных ключей хоста для
     одних и тех же имен. Это неизбежно произойдет, когда в файл будут помещены короткие
     формы имен хостов из разных доменов. Возможно, файлы содержат противоречивую
     информацию; Аутентификация принимается, если из любого файла можно найти
     достоверную информацию.
</p>
<p>Обратите внимание, что строки в этих файлах обычно состоят из сотен символов, и вы
     определенно не хотите вводить ключи хоста вручную. Скорее, сгенерируйте их с помощью
     сценария, ssh-keyscan(1) или взяв /etc/ssh/ssh_host_key.pub и добавив имена хостов
     впереди. ssh-keygen (1) также предлагает некоторое базовое автоматическое
     редактирование для ~/.ssh/known_hosts, включая удаление хостов, соответствующих
     имени хоста, и преобразование всех имен хостов в их хешированные представления.
</p>
<p>Пример ssh_known_hosts file:
</p><div class="display">
<pre class="display">        # Комментарии разрешены в начале строки
        closenet,...,192.0.2.53 1024 37 159...93 closenet.example.net
        cvs.example.net,192.0.2.10 ssh-rsa AAAA1234.....=
        # Хешированное имя хоста
        |1|JfKTdBh7rNbXkVAQCRp4OQoPfmI=|USECr3SWf1JUPsms5AqfD5QfxkM= ssh-rsa
        AAAA1234.....=
        # Отмененный ключ
        @revoked * ssh-rsa AAAAB5W...
        # Ключ CA, принятый для любого хоста в *.mydomain.com или *.mydomain.org
        @cert-authority *.mydomain.org,*.mydomain.com ssh-rsa AAAAB5W...
</pre></div>
</dd>
<dt>FILES</dt>
<dd><dl compact="compact">
<dt>~/.hushlogin <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002ehushlogin"></a></dt>
<dd><p>Этот файл используется для подавления печати времени последнего входа и
             /etc/motd, если включены PrintLastLog и PrintMotd соответственно. Не
             подавляет печать баннера, указанного Баннером.
</p>
</dd>
<dt>~/.rhosts <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002erhosts"></a></dt>
<dd><p>Этот файл используется для аутентификации на основе хоста (см. ssh(1) для
             получения дополнительной информации). На некоторых машинах этот файл должен
             быть доступен для чтения всем, если домашний каталог пользователя находится в
             разделе NFS, потому что sshd читает его как root. Кроме того, этот файл должен
             принадлежать пользователю и не должен иметь права на запись для кого-либо еще.
             Рекомендуемое разрешение для большинства машин - чтение и запись для
             пользователя и недоступно для других.
</p>
</dd>
<dt>~/.shosts <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002eshosts"></a></dt>
<dd><p>Этот файл используется точно так же, как .rhosts, но разрешает
             аутентификацию на основе хоста без разрешения входа с помощью rlogin/rsh.
</p>
</dd>
<dt>~/.ssh/ <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002f"></a></dt>
<dd><p>Этот каталог является местоположением по умолчанию для всей пользовательской
             информации о конфигурации и аутентификации. Не существует общего требования
             хранить все содержимое этого каталога в секрете, но рекомендуемые разрешения
             для чтения/записи/выполнения для пользователя и недоступны для других.
</p>
</dd>
<dt>~/.ssh/authorized_keys <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002fauthorized_005fkeys"></a></dt>
<dd><p>Перечисляет открытые ключи (DSA, ECDSA, Ed25519, RSA), которые можно
             использовать для входа в систему от имени этого пользователя. Формат этого
             файла описан выше. Содержимое файла не очень чувствительно, но рекомендуемые
             разрешения для чтения и записи для пользователя и не доступны для других.
</p>
<p>Если этот файл, ~/.ssh directory или домашний каталог пользователя доступны
             для записи другим пользователям, то этот файл может быть изменен или заменен
             неавторизованными пользователями. В этом случае sshd не позволит использовать
             его, если для параметра StrictModes не установлено значение “no”.
</p>
</dd>
<dt>~/.ssh/environment <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002fenvironment"></a></dt>
<dd><p>Этот файл считывается в среду при входе в систему (если он существует). Он
             может содержать только пустые строки, строки комментариев (начинающиеся с ‘#’)
             и строки присваивания вида name=value. Файл должен быть доступен для записи
             только пользователю; это не должно быть доступно для чтения кем-либо еще.
             Обработка среды по умолчанию отключена и управляется с помощью опции
             PermitUserEnvironment.
</p>
</dd>
<dt>~/.ssh/known_hosts <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002fknown_005fhosts"></a></dt>
<dd><p>Содержит список ключей хоста для всех хостов, в которые вошел пользователь,
             которых еще нет в общесистемном списке известных ключей хоста. Формат этого
             файла описан выше. Этот файл должен быть доступен для записи только
             пользователю root / владельца и может, но не обязательно, быть доступным
             для чтения всем.
</p>
</dd>
<dt>~/.ssh/rc <a name="man_005fssh_005fsshd_005ffile-_007e_002f_002essh_002frc"></a></dt>
<dd><p>Содержит процедуры инициализации, которые должны быть выполнены до того,
             как домашний каталог пользователя станет доступным. Этот файл должен быть
             доступен для записи только пользователю, и не должен быть доступен для
             чтения кем-либо еще.
</p></dd>
<dt>/etc/hosts.allow  /etc/hosts.deny <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fhosts_002eallow-_002fetc_002fhosts_002edeny"></a></dt>
<dd><p>Элементы управления доступом, которые должны быть реализованы с помощью
             tcp-wrappers, определены здесь. Дальнейшие подробности описаны в
             hosts_access(5).
</p>
</dd>
<dt>/etc/hosts.equiv <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fhosts_002eequiv"></a></dt>
<dd><p>Этот файл предназначен для аутентификации на основе хоста (см. ssh(1)).
             Это должно быть доступно для записи только пользователю root.
</p>
</dd>
<dt>/etc/ssh/moduli <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fmoduli"></a></dt>
<dd><p>Содержит группы Диффи-Хеллмана, используемые для метода обмена ключами
             &quot;Diffie-Hellman Group Exchange&quot;. Формат файла описан в moduli(5). Если в
             этом файле не найдено пригодных для использования групп, будут использоваться
             фиксированные внутренние группы.
</p>
</dd>
<dt>/etc/motd <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fmotd"></a></dt>
<dd><p>Смотри motd(5).
</p>
</dd>
<dt>/etc/nologin <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fnologin"></a></dt>
<dd><p>Если этот файл существует, sshd не разрешает входить кому-либо, кроме
             пользователя root. Содержимое этого файла отображается всем, кто пытается
             войти в систему, и соединения без полномочий root отклоняются. Файл должен
             быть доступен для чтения всем.
</p>
</dd>
<dt>/etc/ssh/shosts.equiv <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fshosts_002eequiv"></a></dt>
<dd><p>Этот файл используется точно так же, как hosts.equiv, но допускает
             аутентификацию на основе хоста без разрешения входа с помощью rlogin/rsh.
</p></dd>
<dt>Приватные части ключей хоста <a name="man_005fssh_005fsshd_005ffile-_041f_0440_0438_0432_0430_0442_043d_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430"></a></dt>
<dd><div class="display">
<pre class="display">             /etc/ssh/ssh_host_key
             /etc/ssh/ssh_host_dsa_key
             /etc/ssh/ssh_host_ecdsa_key
             /etc/ssh/ssh_host_ed25519_key
             /etc/ssh/ssh_host_rsa_key 
</pre></div>
<p>Эти файлы содержат приватные части ключей хоста. Эти файлы должны принадлежать
             только пользователю root, быть доступными для чтения только пользователю root
             и недоступны для других. Обратите внимание, что sshd не запускается, если эти
             файлы являются group/world-accessible.
</p></dd>
<dt>Открытые части ключей хоста <a name="man_005fssh_005fsshd_005ffile-_041e_0442_043a_0440_044b_0442_044b_0435-_0447_0430_0441_0442_0438-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430"></a></dt>
<dd><div class="display">
<pre class="display">             /etc/ssh/ssh_host_key.pub
             /etc/ssh/ssh_host_dsa_key.pub
             /etc/ssh/ssh_host_ecdsa_key.pub
             /etc/ssh/ssh_host_ed25519_key.pub
             /etc/ssh/ssh_host_rsa_key.pub
</pre></div>
<p>Эти файлы содержат открытые части ключей хоста. Эти файлы должны быть
             доступны для чтения всем пользователям, но доступны для записи только
             пользователю root. Их содержимое должно соответствовать соответствующим
             частным частям. Эти файлы на самом деле не используются ни для чего; они
             предоставляются для удобства пользователя, поэтому их содержимое можно
             скопировать в известные файлы хостов. Эти файлы создаются с использованием
             ssh-keygen(1).
</p>
</dd>
<dt>/etc/ssh/ssh_known_hosts <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fssh_005fknown_005fhosts"></a></dt>
<dd><p>Общесистемный список известных ключей хоста. Этот файл должен быть
             подготовлен системным администратором, чтобы он содержал открытые ключи
             хостов всех компьютеров в организации. Формат этого файла описан выше. Этот
             файл должен быть доступен для записи только пользователю root/владельца и
             должен быть доступен для чтения всем пользователям.
</p>
</dd>
<dt>/etc/ssh/sshd_config <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fsshd_005fconfig"></a></dt>
<dd><p>Содержит данные конфигурации для sshd. Формат файла и параметры конфигурации
             описаны в sshd_config(5).
</p>
</dd>
<dt>/etc/ssh/sshrc <a name="man_005fssh_005fsshd_005ffile-_002fetc_002fssh_002fsshrc"></a></dt>
<dd><p>Подобно ~/.ssh/rc, его можно использовать для глобальной инициализации
             времени входа в систему для конкретного компьютера. Этот файл должен быть
             доступен для записи только пользователю root и должен быть доступен для
             чтения всем.
</p>
</dd>
<dt>/var/run/sshd <a name="man_005fssh_005fsshd_005ffile-_002fvar_002frun_002fsshd"></a></dt>
<dd><p>Каталог chroot(2), используемый sshd во время разделения привилегий на
             этапе предварительной аутентификации. Каталог не должен содержать никаких
             файлов и должен принадлежать пользователю root, без групповой доступности
             для записи.
</p>
</dd>
<dt>/var/run/sshd.pid <a name="man_005fssh_005fsshd_005ffile-_002fvar_002frun_002fsshd_002epid"></a></dt>
<dd><p>Содержит идентификатор процесса sshd, который прослушивает соединения (если
             несколько демонов запущены одновременно для разных портов, он содержит
             идентификатор процесса, запущенного последним). Содержимое этого файла не
             является конфиденциальным; это может быть читаемым во всем мире.
</p></dd>
</dl>
</dd>
<dt>SEE ALSO</dt>
<dd><p>scp(1), sftp(1), ssh(1), ssh-add(1), ssh-agent(1), ssh-keygen(1),
     ssh-keyscan(1), chroot(2), hosts_access(5), moduli(5), sshd_config(5),
     inetd(8), sftp-server(8)
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.  Niels Provos and Markus Friedl contributed support
     for privilege separation.
</p>
<p>BSD                            February 17, 2016                           BSD
</p></dd>
</dl>
<hr>
<a name="SSH_005fCONFIG"></a>
<div class="header">
<p>
Next: <a href="#SSHD_005fCONFIG" accesskey="n" rel="next">SSHD_CONFIG</a>, Previous: <a href="#SSHD" accesskey="p" rel="prev">SSHD</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH_005fCONFIG-1"></a>
<h2 class="chapter">3 SSH_CONFIG</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh_config — Файлы конфигурации клиента OpenSSH SSH
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><div class="display">
<pre class="display">     ~/.ssh/config
     /etc/ssh/ssh_config
</pre></div>
</dd>
<dt>Ключевые слова</dt>
<dd><div class="display">
<pre class="display">      <a href="#man_005fssh_005fssh_005fconfig-Host">Host</a>
      <a href="#man_005fssh_005fssh_005fconfig-Match">Match</a>
      <a href="#man_005fssh_005fssh_005fconfig-AddKeysToAgent">AddKeysToAgent</a>
      <a href="#man_005fssh_005fssh_005fconfig-AddressFamily">AddressFamily</a>
      <a href="#man_005fssh_005fssh_005fconfig-BatchMode">BatchMode</a>
      <a href="#man_005fssh_005fssh_005fconfig-BindAddress">BindAddress</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalDomains">CanonicalDomains</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeFallbackLocal">CanonicalizeFallbackLocal</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeHostname">CanonicalizeHostname</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeMaxDots">CanonicalizeMaxDots</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizePermittedCNAMEs">CanonicalizePermittedCNAMEs</a>
      <a href="#man_005fssh_005fssh_005fconfig-CertificateFile">CertificateFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-ChallengeResponseAuthentication">ChallengeResponseAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-CheckHostIP">CheckHostIP</a>
      <a href="#man_005fssh_005fssh_005fconfig-Cipher">Cipher</a>
      <a href="#man_005fssh_005fssh_005fconfig-Ciphers">Ciphers</a>
      <a href="#man_005fssh_005fssh_005fconfig-ClearAllForwardings">ClearAllForwardings</a>
      <a href="#man_005fssh_005fssh_005fconfig-Compression">Compression</a>
      <a href="#man_005fssh_005fssh_005fconfig-CompressionLevel">CompressionLevel</a>
      <a href="#man_005fssh_005fssh_005fconfig-ConnectionAttempts">ConnectionAttempts</a>
      <a href="#man_005fssh_005fssh_005fconfig-ConnectTimeout">ConnectTimeout</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlMaster">ControlMaster</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlPath">ControlPath</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlPersist">ControlPersist</a>
      <a href="#man_005fssh_005fssh_005fconfig-DynamicForward">DynamicForward</a>
      <a href="#man_005fssh_005fssh_005fconfig-EnableSSHKeysign">EnableSSHKeysign</a>
      <a href="#man_005fssh_005fssh_005fconfig-EscapeChar">EscapeChar</a>
      <a href="#man_005fssh_005fssh_005fconfig-ExitOnForwardFailure">ExitOnForwardFailure</a>
      <a href="#man_005fssh_005fssh_005fconfig-FingerprintHash">FingerprintHash</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardAgent">ForwardAgent</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardX11">ForwardX11</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardX11Timeout">ForwardX11Timeout</a>
      <a href="#man_005fssh_005fssh_005fconfig-ForwardX11Trusted">ForwardX11Trusted</a>
      <a href="#man_005fssh_005fssh_005fconfig-GatewayPorts">GatewayPorts</a>
      <a href="#man_005fssh_005fssh_005fconfig-GlobalKnownHostsFile">GlobalKnownHostsFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIAuthentication">GSSAPIAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIKeyExchange">GSSAPIKeyExchange</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIClientIdentity">GSSAPIClientIdentity</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIServerIdentity">GSSAPIServerIdentity</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIDelegateCredentials">GSSAPIDelegateCredentials</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIRenewalForcesRekey">GSSAPIRenewalForcesRekey</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPITrustDns">GSSAPITrustDns</a>
      <a href="#man_005fssh_005fssh_005fconfig-HashKnownHosts">HashKnownHosts</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostbasedAuthentication">HostbasedAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostbasedKeyTypes">HostbasedKeyTypes</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostKeyAlgorithms">HostKeyAlgorithms</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostKeyAlias">HostKeyAlias</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostName">HostName</a>
      <a href="#man_005fssh_005fssh_005fconfig-IdentitiesOnly">IdentitiesOnly</a>
      <a href="#man_005fssh_005fssh_005fconfig-IdentityFile">IdentityFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-IgnoreUnknown">IgnoreUnknown</a>
      <a href="#man_005fssh_005fssh_005fconfig-IPQoS">IPQoS</a>
      <a href="#man_005fssh_005fssh_005fconfig-KbdInteractiveAuthentication">KbdInteractiveAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-KbdInteractiveDevices">KbdInteractiveDevices</a>
      <a href="#man_005fssh_005fssh_005fconfig-KexAlgorithms">KexAlgorithms</a>
      <a href="#man_005fssh_005fssh_005fconfig-LocalCommand">LocalCommand</a>
      <a href="#man_005fssh_005fssh_005fconfig-LocalForward">LocalForward</a>
      <a href="#man_005fssh_005fssh_005fconfig-LogLevel">LogLevel</a>
      <a href="#man_005fssh_005fssh_005fconfig-MACs">MACs</a>
      <a href="#man_005fssh_005fssh_005fconfig-NoHostAuthenticationForLocalhost">NoHostAuthenticationForLocalhost</a>
      <a href="#man_005fssh_005fssh_005fconfig-NumberOfPasswordPrompts">NumberOfPasswordPrompts</a>
      <a href="#man_005fssh_005fssh_005fconfig-PasswordAuthentication">PasswordAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-PermitLocalCommand">PermitLocalCommand</a>
      <a href="#man_005fssh_005fssh_005fconfig-PKCS11Provider">PKCS11Provider</a>
      <a href="#man_005fssh_005fssh_005fconfig-Port">Port</a>
      <a href="#man_005fssh_005fssh_005fconfig-PreferredAuthentications">PreferredAuthentications</a>
      <a href="#man_005fssh_005fssh_005fconfig-Protocol">Protocol</a>
      <a href="#man_005fssh_005fssh_005fconfig-ProxyCommand">ProxyCommand</a>
      <a href="#man_005fssh_005fssh_005fconfig-ProxyUseFdpass">ProxyUseFdpass</a>
      <a href="#man_005fssh_005fssh_005fconfig-PubkeyAcceptedKeyTypes">PubkeyAcceptedKeyTypes</a>
      <a href="#man_005fssh_005fssh_005fconfig-PubkeyAuthentication">PubkeyAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-RekeyLimit">RekeyLimit</a>
      <a href="#man_005fssh_005fssh_005fconfig-RemoteForward">RemoteForward</a>
      <a href="#man_005fssh_005fssh_005fconfig-RequestTTY">RequestTTY</a>
      <a href="#man_005fssh_005fssh_005fconfig-RevokedHostKeys">RevokedHostKeys</a>
      <a href="#man_005fssh_005fssh_005fconfig-RhostsRSAAuthentication">RhostsRSAAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-RSAAuthentication">RSAAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-SendEnv">SendEnv</a>
      <a href="#man_005fssh_005fssh_005fconfig-ServerAliveCountMax">ServerAliveCountMax</a>
      <a href="#man_005fssh_005fssh_005fconfig-ServerAliveInterval">ServerAliveInterval</a>
      <a href="#man_005fssh_005fssh_005fconfig-StreamLocalBindMask">StreamLocalBindMask</a>
      <a href="#man_005fssh_005fssh_005fconfig-StreamLocalBindUnlink">StreamLocalBindUnlink</a>
      <a href="#man_005fssh_005fssh_005fconfig-StrictHostKeyChecking">StrictHostKeyChecking</a>
      <a href="#man_005fssh_005fssh_005fconfig-TCPKeepAlive">TCPKeepAlive</a>
      <a href="#man_005fssh_005fssh_005fconfig-Tunnel">Tunnel</a>
      <a href="#man_005fssh_005fssh_005fconfig-TunnelDevice">TunnelDevice</a>
      <a href="#man_005fssh_005fssh_005fconfig-UpdateHostKeys">UpdateHostKeys</a>
      <a href="#man_005fssh_005fssh_005fconfig-UsePrivilegedPort">UsePrivilegedPort</a>
      <a href="#man_005fssh_005fssh_005fconfig-User">User</a>
      <a href="#man_005fssh_005fssh_005fconfig-UserKnownHostsFile">UserKnownHostsFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-VerifyHostKeyDNS">VerifyHostKeyDNS</a>
      <a href="#man_005fssh_005fssh_005fconfig-VisualHostKey">VisualHostKey</a>
      <a href="#man_005fssh_005fssh_005fconfig-XAuthLocation">XAuthLocation</a>
</pre></div>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh(1) получает данные конфигурации из следующих источников в
     следующем порядке:
</p><div class="display">
<pre class="display">           1.   параметры командной строки
           2.   файл конфигурации пользователя (~/.ssh/config)
           3.   общесистемный файл конфигурации (/etc/ssh/ssh_config)
</pre></div>
<p>Для каждого параметра будет использоваться первое полученное значение. Файлы
     конфигурации содержат разделы, разделенные спецификациями “Host”, и этот раздел
     применяется только для хостов, которые соответствуют одному из шаблонов, приведенных
     в спецификации. Совпадающим именем хоста обычно является имя, указанное в командной
     строке (см. Опцию CanonicalizeHostname для исключений.)
</p>
<p>Поскольку для каждого параметра используется первое полученное значение, в начале
     файла должны быть приведены более специфичные для хоста объявления, а в конце -
     общие значения по умолчанию.
</p>
<p>Обратите внимание, что пакет openssh-client Debian устанавливает несколько опций
     в качестве стандартных в /etc/ssh/ssh_config, которые не являются параметрами по
     умолчанию в ssh(1):
</p><div class="display">
<pre class="display">           ·   SendEnv LANG LC_*
           ·   HashKnownHosts yes
           ·   GSSAPIAuthentication yes
</pre></div>
<p>Файл конфигурации имеет следующий формат:
</p>
<p>Пустые строки и строки, начинающиеся с ‘#’, являются комментариями. В противном
     случае строка имеет формат “keyword arguments”. Параметры конфигурации могут быть
     разделены пробелами или необязательными пробелами и ровно одним ‘=’; последний
     формат полезен, чтобы избежать необходимости заключать в кавычки пробел при указании
     параметров конфигурации с помощью ssh, scp, и sftp опция -o. Аргументы могут быть
     заключены в двойные кавычки (&quot;), чтобы представлять аргументы, содержащие пробелы.
</p>
<p>Возможные ключевые слова и их значения следующие (обратите внимание, что
     ключевые слова не чувствительны к регистру, а аргументы чувствительны к регистру):
</p><dl compact="compact">
<dt>Host <a name="man_005fssh_005fssh_005fconfig-Host"></a></dt>
<dd><p>Ограничивает следующие объявления (вплоть до следующего ключевого слова
             Host или Match) только для тех хостов, которые соответствуют одному из
             шаблонов, указанных после ключевого слова. Если предусмотрено более одного
             шаблона, они должны быть разделены пробелами. Один ‘*’ в качестве шаблона
             может использоваться для обеспечения глобальных значений по умолчанию для
             всех хостов. Хост обычно является аргументом имени хоста, указанным в
             командной строке (см. Опцию CanonicalizeHostname для исключений.)
</p>
<p>Запись шаблона может быть отменена путем добавления префикса
             восклицательного знака (‘!’). Если отрицаемая запись соответствует,
             то запись Host игнорируется, независимо от того, совпадают ли другие
             шаблоны в строке. Поэтому отрицательные совпадения полезны для
             предоставления исключений для подстановочных совпадений.
</p>
<p>Смотрите PATTERNS для получения дополнительной информации о шаблонах.
</p>
</dd>
<dt>Match <a name="man_005fssh_005fssh_005fconfig-Match"></a></dt>
<dd><p>Ограничивает использование следующих объявлений (вплоть до следующего
             ключевого слова Host или Match) только при соблюдении условий, следующих за
             ключевым словом Match. Условия совпадения указываются с использованием одного
             или нескольких критериев или одного токена, который всегда совпадает. Доступны
             следующие ключевые слова: canonical, exec, host, originalhost, user, и
             localuser. Все критерии должны быть указаны отдельно или сразу после
             канонического. Другие критерии могут комбинироваться произвольно. Все
             критерии, кроме всех и канонические, требуют аргументации. Критерии могут
             быть отменены путем добавления восклицательного знака (‘!’).
</p>
<p>Каноническое ключевое слово соответствует только тогда, когда файл
             конфигурации повторно анализируется после канонизации имени хоста
             (CanonicalizeHostname option.). Это может быть полезно для указания
             условий, которые работают только с каноническими именами хоста. Ключевое
             слово exec выполняет указанную команду под оболочкой пользователя. Если
             команда возвращает нулевой статус выхода, то условие считается истинным.
             Команды, содержащие пробельные символы, должны быть заключены в кавычки.
             Следующие последовательности символов в команде будут расширены до выполнения:
</p><div class="display">
<pre class="display">             ‘%L’ будет заменен первым компонентом локального имени хоста,
             ‘%l’ будет заменен локальным именем хоста (включая любое доменное имя),
             ‘%h’ будет заменен на имя целевого хоста,
             ‘%n’ будет заменено исходным именем целевого хоста, указанным в
             командной строке,
             ‘%p’ порт назначения,
             ‘%r’ - именем пользователя для удаленного входа, а
             ‘%u’ - именем пользователя, запустившего ssh(1).
</pre></div>
<p>Критерии других ключевых слов должны быть отдельными записями или
             разделенными запятыми списками и могут использовать подстановочные знаки и
             операторы отрицания, описанные в разделе PATTERNS. Критерии для ключевого
             слова host сравниваются с целевым именем хоста после любой замены опциями
             Hostname или CanonicalizeHostname. Ключевое слово originalhost совпадает
             с именем хоста, как было указано в командной строке. Ключевое слово user
             соответствует целевому имени пользователя на удаленном хосте. Ключевое
             слово localuser совпадает с именем локального пользователя,
             выполняющего ssh (1) (это ключевое слово может быть полезно в
             общесистемных файлах ssh_config).
</p>
</dd>
<dt>AddKeysToAgent <a name="man_005fssh_005fssh_005fconfig-AddKeysToAgent"></a></dt>
<dd><p>Указывает, следует ли автоматически добавлять ключи в работающий ssh-agent(1).
             Если для этой опции задано значение “yes” и ключ загружается из файла, ключ и
             его пароль добавляются в агент со временем жизни по умолчанию, как если бы это
             было сделано с помощью ssh-add(1). Если для этого параметра установлено
             значение “ask”, ssh потребует подтверждения с помощью программы SSH_ASKPASS
             перед добавлением ключа (см. Ssh-add(1) для получения подробной информации).
             Если для этой опции установлено значение “confirm”, каждое использование
             ключа должно быть подтверждено, как если бы для ssh-add(1) была указана
             опция -c. Если для этого параметра установлено значение “no”, ключи к агенту
             не добавляются. Аргумент должен быть “yes”, “confirm”, “ask”,и “no”.
             По умолчанию используется “no”.
</p>
</dd>
<dt>AddressFamily <a name="man_005fssh_005fssh_005fconfig-AddressFamily"></a></dt>
<dd><p>Указывает, какое семейство адресов использовать при подключении. Допустимые
             аргументы: “any”, “inet” (использовать только IPv4), или “inet6”
             (использовать только IPv6). По умолчанию используется “any”.
</p>
</dd>
<dt>BatchMode <a name="man_005fssh_005fssh_005fconfig-BatchMode"></a></dt>
<dd><p>Если установлено значение “yes”, запрос парольной фразы/пароля будет
             отключен. Кроме того, опция ServerAliveInterval будет установлена ​​на 300
             секунд по умолчанию. Эта опция полезна в сценариях и других пакетных заданиях,
             где нет ни одного пользователя, предоставляющего пароль, и где желательно
             быстро обнаруживать неисправную сеть. Аргумент должен быть “yes” или “no”.
             По умолчанию используется “no”.
</p>
</dd>
<dt>BindAddress <a name="man_005fssh_005fssh_005fconfig-BindAddress"></a></dt>
<dd><p>Используйте указанный адрес на локальном компьютере в качестве адреса
             источника соединения. Полезно только в системах с более чем одним адресом.
             Обратите внимание, что эта опция не работает, если для UsePrivilegedPort
             установлено значение “yes”.
</p>
</dd>
<dt>CanonicalDomains <a name="man_005fssh_005fssh_005fconfig-CanonicalDomains"></a></dt>
<dd><p>Когда CanonicalizeHostname включен, эта опция указывает список
             суффиксов домена, в котором следует искать указанный хост назначения.
</p>
</dd>
<dt>CanonicalizeFallbackLocal <a name="man_005fssh_005fssh_005fconfig-CanonicalizeFallbackLocal"></a></dt>
<dd><p>Указывает, следует ли выполнить сбой с ошибкой при сбое канонизации имени
             хоста. По умолчанию, “yes”, будет пытаться найти неполное имя хоста, используя
             правила поиска системного распознавателя. Значение “no” приведет к мгновенному
             сбою ssh (1), если включен CanonicalizeHostname и имя целевого хоста не может
             быть найдено ни в одном из доменов, указанных в CanonicalDomains.
</p>
</dd>
<dt>CanonicalizeHostname <a name="man_005fssh_005fssh_005fconfig-CanonicalizeHostname"></a></dt>
<dd><p>Управляет выполнением явной канонизации имени хоста. По умолчанию, “no”,
             не выполняется перезапись имен, и системный распознаватель обрабатывает все
             запросы на поиск имени хоста. Если установлено значение “yes”, то для
             соединений, которые не используют ProxyCommand, ssh (1) попытается
             канонизировать имя хоста, указанное в командной строке, используя суффиксы
             CanonicalDomains и правила CanonicalizePermittedCNAMEs. Если для
             CanonicalizeHostname установлено значение “always”, то канонизация
             применяется и к прокси-соединениям.
</p>
<p>Если эта опция включена, то файлы конфигурации снова обрабатываются с
             использованием нового целевого имени, чтобы выбрать любую новую конфигурацию
             в соответствующих строках Host и Match.
</p>
</dd>
<dt>CanonicalizeMaxDots <a name="man_005fssh_005fssh_005fconfig-CanonicalizeMaxDots"></a></dt>
<dd><p>Задает максимальное количество символов точки в имени хоста до отключения
             канонизации. Значение по умолчанию, “1”, допускает одну точку
             (как здесь hostname.subdomain).
</p>
</dd>
<dt>CanonicalizePermittedCNAMEs <a name="man_005fssh_005fssh_005fconfig-CanonicalizePermittedCNAMEs"></a></dt>
<dd><p>Указывает правила, определяющие, следует ли соблюдать CNAMEs при канонизации
             имен хостов. Правила состоят из одного или нескольких аргументов
             source_domain_list:target_domain_list, где source_domain_list является
             списком шаблонов доменов, которые могут следовать CNAMEs в канонизации, а
             target_domain_list является списком шаблонов доменов, к которым они могут
             обращаться.
</p>
<p>Например, “*.a.example.com:*.b.example.com,*.c.example.com” позволит
             канонически идентифицировать имена хостов, соответствующие “*.a.example.com”,
             именам в доменах “*.b.example.com” или “*.c.example.com”.
</p>
</dd>
<dt>CertificateFile <a name="man_005fssh_005fssh_005fconfig-CertificateFile"></a></dt>
<dd><p>Указывает файл, из которого читается сертификат пользователя. Соответствующий
             закрытый ключ должен быть предоставлен отдельно, чтобы использовать этот
             сертификат либо из директивы IdentityFile, либо из флага -i в ssh(1), через
             ssh-agent(1) или через PKCS11Provider.
</p>
<p>Имя файла может использовать синтаксис тильды для ссылки на домашний
             каталог пользователя или один из следующих escape-символов:
</p><div class="display">
<pre class="display">             ‘%d’ (домашний каталог локального пользователя),
             ‘%u’ (имя локального пользователя),
             ‘%l’ (имя локального хоста),
             ‘%h’ (имя удаленного хоста) ) или
             ‘%r’ (имя удаленного пользователя).
</pre></div>
<p>Можно указать несколько файлов сертификатов, указанных в файлах
             конфигурации; эти сертификаты будут опробованы последовательно. Несколько
             директив CertificateFile добавят в список сертификатов, используемых для
             аутентификации.
</p>
</dd>
<dt>ChallengeResponseAuthentication <a name="man_005fssh_005fssh_005fconfig-ChallengeResponseAuthentication"></a></dt>
<dd><p>Указывает, использовать ли проверку подлинности по запросу. Аргумент к
             этому ключевому слову должен быть “yes” или “no”. По умолчанию
             используется “yes”.
</p>
</dd>
<dt>CheckHostIP <a name="man_005fssh_005fssh_005fconfig-CheckHostIP"></a></dt>
<dd><p>Если этот флаг установлен в “yes”, ssh(1) дополнительно проверит адрес
             хоста IP в файле known_hosts. Это позволяет ssh определять, изменился ли
             ключ хоста из-за подмены DNS, и будет добавлять адреса хостов назначения в
             ~/.ssh/known_hosts в процессе, независимо от значения StrictHostKeyChecking.
             Если для параметра установлено значение “no”, проверка не будет выполнена.
             По умолчанию используется “yes”.
</p>
</dd>
<dt>Cipher <a name="man_005fssh_005fssh_005fconfig-Cipher"></a></dt>
<dd><p>Задает шифр, который будет использоваться для шифрования сеанса в протоколе
             версии 1. В настоящее время поддерживаются “blowfish”, “3des”, или “des”.
             des поддерживается только в клиенте ssh(1) для взаимодействия с устаревшими
             реализациями протокола 1, которые не поддерживают шифр 3des. Его использование
             настоятельно не рекомендуется из-за криптографических недостатков. По
             умолчанию используется “3des”.
</p>
</dd>
<dt>Ciphers <a name="man_005fssh_005fssh_005fconfig-Ciphers"></a></dt>
<dd><p>Задает разрешенные шифры для версии протокола 2 в порядке предпочтения.
             Несколько шифров должны быть разделены запятыми. Если указанное значение
             начинается с символа ‘+’, то указанные шифры будут добавлены в набор по
             умолчанию вместо их замены.
</p>
<p>Поддерживаемые шифры:
</p><div class="display">
<pre class="display">                   3des-cbc
                   aes128-cbc
                   aes192-cbc
                   aes256-cbc
                   aes128-ctr
                   aes192-ctr
                   aes256-ctr
                   aes128-gcm@openssh.com
                   aes256-gcm@openssh.com
                   arcfour
                   arcfour128
                   arcfour256
                   blowfish-cbc
                   cast128-cbc
                   chacha20-poly1305@openssh.com
</pre></div>
<p>По умолчанию:
</p><div class="display">
<pre class="display">                   chacha20-poly1305@openssh.com,
                   aes128-ctr,aes192-ctr,aes256-ctr,
                   aes128-gcm@openssh.com,aes256-gcm@openssh.com,
                   aes128-cbc,aes192-cbc,aes256-cbc,3des-cbc
</pre></div>
<p>Список доступных шифров также можно получить с помощью опции ssh(1) -Q с
             аргументом “cipher”.
</p>
</dd>
<dt>ClearAllForwardings <a name="man_005fssh_005fssh_005fconfig-ClearAllForwardings"></a></dt>
<dd><p>Указывает, что все локальные, удаленные и динамические переадресации портов,
             указанные в файлах конфигурации или в командной строке, будут очищены. Эта
             опция в первую очередь полезна, когда используется из командной строки ssh(1)
             для очистки переадресации портов, заданной в файлах конфигурации, и
             автоматически устанавливается scp(1) и sftp(1). Аргумент должен быть “yes”
             или “no”. По умолчанию используется “no”.
</p>
</dd>
<dt>Compression <a name="man_005fssh_005fssh_005fconfig-Compression"></a></dt>
<dd><p>Указывает, использовать ли сжатие. Аргумент должен быть “yes” или “no”.
             По умолчанию используется “no”.
</p>
</dd>
<dt>CompressionLevel <a name="man_005fssh_005fssh_005fconfig-CompressionLevel"></a></dt>
<dd><p>Задает уровень сжатия, который следует использовать, если сжатие включено.
             Аргумент должен быть целым числом от 1 (быстрый) до 9 (медленный, лучший).
             Уровень по умолчанию - 6, что хорошо для большинства приложений. Значение
             уровней такое же, как в gzip(1). Обратите внимание, что этот параметр
             применяется только к версии протокола 1.
</p>
</dd>
<dt>ConnectionAttempts <a name="man_005fssh_005fssh_005fconfig-ConnectionAttempts"></a></dt>
<dd><p>Определяет количество попыток (одна в секунду), чтобы сделать перед выходом.
             Аргумент должен быть целым числом. Это может быть полезно в сценариях, если
             иногда не удается установить соединение. По умолчанию это 1.
</p>
</dd>
<dt>ConnectTimeout <a name="man_005fssh_005fssh_005fconfig-ConnectTimeout"></a></dt>
<dd><p>Указывает время ожидания (в секундах), используемое при подключении к
             серверу SSH, вместо того, чтобы использовать системное время ожидания TCP
             по умолчанию. Это значение используется только тогда, когда цель недоступна
             или действительно недоступна, а не когда она отказывается от соединения.
</p>
</dd>
<dt>ControlMaster <a name="man_005fssh_005fssh_005fconfig-ControlMaster"></a></dt>
<dd><p>Разрешает совместное использование нескольких сеансов через одно сетевое
             соединение. Когда установлено значение “yes”, ssh(1) будет прослушивать
             соединения в контрольном сокете, указанном с помощью аргумента ControlPath.
             Дополнительные сеансы могут подключаться к этому сокету с использованием того
             же ControlPath с ControlMaster, установленным в “no” (по умолчанию). Эти
             сеансы будут пытаться повторно использовать сетевое соединение главного
             экземпляра, а не инициировать новые, но будут возвращаться к обычному
             соединению, если сокет управления не существует или не прослушивает.
</p>
<p>Установка этого значения в “ask” приведет к тому, что ssh будет прослушивать
             контрольные соединения, но потребует подтверждения с помощью ssh-askpass(1).
             Если ControlPath не может быть открыт, ssh продолжит работу без подключения
             к главному экземпляру.
</p>
<p>Переадресация X11 и ssh-agent(1) поддерживается через эти мультиплексные
             соединения, однако перенаправленный дисплей и агент будут принадлежать
             главному соединению, т.е. невозможно переадресовать несколько дисплеев
             или агентов.
</p>
<p>Два дополнительных параметра допускают оппортунистическое
             мультиплексирование: попробуйте использовать мастер-соединение, но отступите
             к созданию нового, если оно еще не существует. Эти параметры: “auto” и
             “autoask”. Последнее требует подтверждения как опция “ask”.
</p>
</dd>
<dt>ControlPath <a name="man_005fssh_005fssh_005fconfig-ControlPath"></a></dt>
<dd><p>Укажите путь к сокету управления, используемому для разделения соединений,
             как описано в разделе ControlMaster выше, или строку “none”, чтобы отключить
             совместное использование соединений. В пути ‘%L’ будет заменен первым
             компонентом локального имени хоста, ‘%l’ будет заменен локальным именем
             хоста (включая любое доменное имя), ‘%h’ будет заменен целевым именем
             хоста, ‘%n’ будет заменен исходным именем целевого хоста, указанное в
             командной строке, ‘%p’ порт назначения, ‘%r’ именем пользователя
             удаленного входа, ‘%u’ именем пользователя и ‘%i’ числовым пользовательским
             ID (uid) пользователя, выполняющего ssh(1), и ‘%C’ хешем объединения :
             %l%h%p%r. Рекомендуется, чтобы любой ControlPath, используемый для
             совместного использования соединений, включал как минимум %h, %p и %r
             (или, альтернативно, %C) и помещался в каталог, недоступный для записи другим
             пользователям. Это обеспечивает уникальную идентификацию общих подключений.
</p>
</dd>
<dt>ControlPersist <a name="man_005fssh_005fssh_005fconfig-ControlPersist"></a></dt>
<dd><p>При использовании вместе с ControlMaster указывает, что главное соединение
             должно оставаться открытым в фоновом режиме (в ожидании будущих клиентских
             соединений) после того, как первоначальное клиентское соединение было закрыто.
             Если установлено значение “no”, то основное соединение не будет помещено в
             фоновый режим и будет закрыто, как только будет закрыто исходное клиентское
             соединение. Если установлено значение “yes” или “0”, то мастер-соединение
             будет оставаться в фоновом режиме неопределенно (до тех пор, пока не будет
             разорвано или закрыто с помощью механизма, такого как опция ssh (1) “-O exit”).
             Если задано время в секундах или время в любом из форматов,
             задокументированных в sshd_config (5), то заземленное основное соединение
             автоматически завершится после того, как оно оставалось свободным (без
             клиентских подключений) в течение указанного времени.
</p>
</dd>
<dt>DynamicForward <a name="man_005fssh_005fssh_005fconfig-DynamicForward"></a></dt>
<dd><p>Указывает, что порт TCP на локальном компьютере будет переадресован по
             безопасному каналу, а затем протокол приложения будет использоваться для
             определения того, к чему подключаться с удаленного компьютера.
</p>
<p>Аргумент должен быть [bind_address:]port. Адреса IPv6 можно указать,
             заключив адреса в квадратные скобки. По умолчанию локальный порт связан
             в соответствии с настройкой GatewayPorts. Однако явный адрес bind_address
             может использоваться для привязки соединения к конкретному адресу.
             Bind_address “localhost” указывает, что прослушивающий порт связан только
             для локального использования, в то время как пустой адрес или ‘*’ указывает,
             что порт должен быть доступен со всех интерфейсов.
</p>
<p>В настоящее время поддерживаются протоколы SOCKS4 и SOCKS5, а ssh(1) будет
             действовать как сервер SOCKS. Можно указать несколько переадресаций, а
             дополнительные пересылки можно указать в командной строке. Только
             суперпользователь может пересылать привилегированные порты.
</p>
</dd>
<dt>EnableSSHKeysign <a name="man_005fssh_005fssh_005fconfig-EnableSSHKeysign"></a></dt>
<dd><p>Установка этой опции в “yes” в глобальном файле конфигурации клиента
             /etc/ssh/ssh_config позволяет использовать вспомогательную программу
             ssh-keysign(8) во время HostbasedAuthentication. Аргумент должен быть “yes”
             или “no”. По умолчанию используется “no”. Эта опция должна быть размещена
             в разделе, не относящемся к хосту. ssh-keysign(8) для получения
             дополнительной информации.
</p>
</dd>
<dt>EscapeChar <a name="man_005fssh_005fssh_005fconfig-EscapeChar"></a></dt>
<dd><p>Устанавливает escape-символ (по умолчанию: ‘~’). Экранирующий символ
             также может быть установлен в командной строке. Аргумент должен быть одним
             символом, ‘^’, за которым следует буква, или “none”, чтобы полностью
             отключить escape-символ (делая соединение прозрачным для двоичных данных).
</p>
</dd>
<dt>ExitOnForwardFailure <a name="man_005fssh_005fssh_005fconfig-ExitOnForwardFailure"></a></dt>
<dd><p>Указывает, должен ли ssh(1) завершать соединение, если он не может настроить
             все запрошенные динамические, туннельные, локальные и удаленные переадресации
             портов (например, если какой-либо конец не может связать и перечислить на
             указанном порту). Обратите внимание, что ExitOnForwardFailure не применяется
             к соединениям, выполненным через переадресацию портов, и, например, не
             приведет к выходу ssh(1) в случае сбоя соединений TCP с конечным пунктом
             назначения пересылки. Аргумент должен быть “yes” или “no”. По умолчанию
             используется “no”.
</p>
</dd>
<dt>FingerprintHash <a name="man_005fssh_005fssh_005fconfig-FingerprintHash"></a></dt>
<dd><p>Определяет алгоритм хеширования, используемый при отображении отпечатков
             клавиш. Допустимые параметры: “md5” и “sha256”. По умолчанию используется
             “sha256”.
</p>
</dd>
<dt>ForwardAgent <a name="man_005fssh_005fssh_005fconfig-ForwardAgent"></a></dt>
<dd><p>Указывает, будет ли соединение с агентом аутентификации (если есть)
             переадресовано на удаленный компьютер. Аргумент должен быть “yes” или “no”.
             По умолчанию используется “no”.
</p>
<p>Переадресация агента должна быть включена с осторожностью. Пользователи с
             возможностью обойти права доступа к файлам на удаленном хосте (для сокета
             Unix-домена агента) могут получить доступ к локальному агенту через
             переадресованное соединение. Злоумышленник не может получить материал ключа
             от агента, однако он может выполнять операции с ключами, которые позволяют
             им проходить проверку подлинности с использованием идентификаторов,
             загруженных в агент.
</p>
</dd>
<dt>ForwardX11 <a name="man_005fssh_005fssh_005fconfig-ForwardX11"></a></dt>
<dd><p>Указывает, будут ли соединения X11 автоматически переадресовываться по
             безопасному каналу и устанавливаться в DISPLAY. Аргумент должен быть “yes”
             или “no”. По умолчанию используется “no”.
</p>
<p>Пересылка X11 должна быть включена с осторожностью. Пользователи с
             возможностью обхода прав доступа к файлам на удаленном хосте (для базы
             данных авторизации X11 пользователя) могут получить доступ к локальному
             экрану X11 через переадресованное соединение. Затем злоумышленник сможет
             выполнять такие действия, как мониторинг нажатия клавиш, если также включена
             опция ForwardX11Trusted.
</p>
</dd>
<dt>ForwardX11Timeout <a name="man_005fssh_005fssh_005fconfig-ForwardX11Timeout"></a></dt>
<dd><p>Укажите время ожидания для ненадежной пересылки X11, используя формат,
             описанный в разделе TIME FORMATS sshd_config(5). Соединения X11, полученные
             ssh(1) по истечении этого времени, будут отклонены. По умолчанию отключается
             ненадежная пересылка X11 по истечении двадцати минут.
</p>
</dd>
<dt>ForwardX11Trusted <a name="man_005fssh_005fssh_005fconfig-ForwardX11Trusted"></a></dt>
<dd><p>Если для этого параметра установлено значение “yes”, удаленные клиенты
             X11 будут иметь полный доступ к исходному отображению X11.
</p>
<p>Если для этого параметра установлено значение “no”, удаленные клиенты X11
             будут считаться недоверенными и не смогут украсть или подделать данные,
             принадлежащие доверенным клиентам X11. Кроме того, токен xauth(1),
             используемый для сеанса, будет установлен как истекающий через 20 минут.
             Удаленным клиентам будет отказано в доступе после этого времени.
</p>
<p>По умолчанию используется “yes” (для Debian).
</p>
<p>См. Спецификацию расширения X11 SECURITY для полной информации об
             ограничениях, наложенных на ненадежных клиентов.
</p>
</dd>
<dt>GatewayPorts <a name="man_005fssh_005fssh_005fconfig-GatewayPorts"></a></dt>
<dd><p>Указывает, разрешено ли удаленным хостам подключаться к локальным
             перенаправленным портам. По умолчанию ssh(1) связывает перенаправления
             локальных портов с адресом обратной связи. Это предотвращает подключение
             других удаленных хостов к перенаправленным портам. С помощью GatewayPorts
             можно указать, что ssh должен связывать переадресацию локальных портов с
             подстановочным адресом, что позволяет удаленным хостам подключаться к
             перенаправленным портам. Аргумент должен быть “yes” или “no”. По
             умолчанию используется “no”.
</p>
</dd>
<dt>GlobalKnownHostsFile <a name="man_005fssh_005fssh_005fconfig-GlobalKnownHostsFile"></a></dt>
<dd><p>Задает один или несколько файлов для использования в базе данных глобального
             ключа хоста, разделенных пробелами. По умолчанию это
             /etc/ssh/ssh_known_hosts, /etc/ssh/ssh_known_hosts2.
</p>
</dd>
<dt>GSSAPIAuthentication <a name="man_005fssh_005fssh_005fconfig-GSSAPIAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли аутентификация пользователя на основе GSSAPI.
             По умолчанию используется “no”.
</p>
</dd>
<dt>GSSAPIKeyExchange <a name="man_005fssh_005fssh_005fconfig-GSSAPIKeyExchange"></a></dt>
<dd><p>Указывает, можно ли использовать обмен ключами на основе GSSAPI. При
             использовании обмена ключами GSSAPI серверу не нужно иметь ключ хоста. По
             умолчанию используется “no”.
</p>
</dd>
<dt>GSSAPIClientIdentity <a name="man_005fssh_005fssh_005fconfig-GSSAPIClientIdentity"></a></dt>
<dd><p>Если установлено, указывает идентификатор клиента GSSAPI, который ssh ​
             ​должен использовать при подключении к серверу. Значение по умолчанию не
             установлено, что означает, что будет использоваться идентификатор по
             умолчанию.
</p>
</dd>
<dt>GSSAPIServerIdentity <a name="man_005fssh_005fssh_005fconfig-GSSAPIServerIdentity"></a></dt>
<dd><p>Если установлено, указывает идентификатор сервера GSSAPI, который ssh ​​должен
             ожидать при подключении к серверу. По умолчанию установлено значение unset,
             что означает, что ожидаемая идентификация сервера GSSAPI будет определяться
             на основе целевого имени хоста.
</p>
</dd>
<dt>GSSAPIDelegateCredentials <a name="man_005fssh_005fssh_005fconfig-GSSAPIDelegateCredentials"></a></dt>
<dd><p>Переслать (делегировать) учетные данные на сервер. По умолчанию используется
             “no”.
</p>
</dd>
<dt>GSSAPIRenewalForcesRekey <a name="man_005fssh_005fssh_005fconfig-GSSAPIRenewalForcesRekey"></a></dt>
<dd><p>Если установлено значение “yes”, то обновление учетных данных клиента
             GSSAPI приведет к повторному вводу соединения ssh. На совместимом сервере
             это может делегировать обновленные учетные данные сеансу на сервере. По
             умолчанию используется “no”.
</p>
</dd>
<dt>GSSAPITrustDns <a name="man_005fssh_005fssh_005fconfig-GSSAPITrustDns"></a></dt>
<dd><p>Установите значение “yes”, чтобы указать, что DNS является доверенным для
             безопасной канонизации имени хоста, к которому подключен. Если “no”, имя
             хоста, введенное в командной строке, будет передано без изменений в
             библиотеку GSSAPI. По умолчанию используется “no”.
</p>
</dd>
<dt>HashKnownHosts <a name="man_005fssh_005fssh_005fconfig-HashKnownHosts"></a></dt>
<dd><p>Указывает, что ssh(1) должен хэшировать имена хостов и адреса, когда они
             добавляются в ~/.ssh/known_hosts. Эти хэшированные имена могут обычно
             использоваться ssh(1) и sshd(8), но они не раскрывают идентифицирующую
             информацию, если содержимое файла будет раскрыто. По умолчанию используется
             “no”. Обратите внимание, что существующие имена и адреса в известных файлах
             хоста не будут конвертироваться автоматически, но могут быть вручную
             хешированы с использованием ssh-keygen(1). Использование этой опции может
             нарушить такие возможности, как завершение табуляции, которые зависят от
             возможности чтения нехэшированных имен хостов из ~/.ssh/known_hosts.
</p>
</dd>
<dt>HostbasedAuthentication <a name="man_005fssh_005fssh_005fconfig-HostbasedAuthentication"></a></dt>
<dd><p>Указывает, следует ли использовать аутентификацию на основе rhosts с
             аутентификацией с открытым ключом. Аргумент должен быть “yes” или “no”. По
             умолчанию используется “no”.
</p>
</dd>
<dt>HostbasedKeyTypes <a name="man_005fssh_005fssh_005fconfig-HostbasedKeyTypes"></a></dt>
<dd><p>Задает типы ключей, которые будут использоваться для аутентификации на
             основе хоста в виде списка шаблонов, разделенных запятыми. С другой стороны,
             если указанное значение начинается с символа ‘+’, то указанные типы ключей
             будут добавлены к набору по умолчанию вместо их замены. По умолчанию для
             этой опции:
</p><div class="display">
<pre class="display">                ecdsa-sha2-nistp256-cert-v01@openssh.com,
                ecdsa-sha2-nistp384-cert-v01@openssh.com,
                ecdsa-sha2-nistp521-cert-v01@openssh.com,
                ssh-ed25519-cert-v01@openssh.com,
                ssh-rsa-cert-v01@openssh.com,
                ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,
                ssh-ed25519,ssh-rsa
</pre></div>
<p>Опция -Q в ssh(1) может использоваться для отображения поддерживаемых
             типов ключей.
</p>
</dd>
<dt>HostKeyAlgorithms <a name="man_005fssh_005fssh_005fconfig-HostKeyAlgorithms"></a></dt>
<dd><p>Определяет алгоритмы ключа хоста, которые клиент хочет использовать в
             порядке предпочтения. С другой стороны, если указанное значение начинается с
             символа ‘+’, то указанные типы ключей будут добавлены к набору по умолчанию
             вместо их замены. По умолчанию для этой опции:
</p><div class="display">
<pre class="display">                ecdsa-sha2-nistp256-cert-v01@openssh.com,
                ecdsa-sha2-nistp384-cert-v01@openssh.com,
                ecdsa-sha2-nistp521-cert-v01@openssh.com,
                ssh-ed25519-cert-v01@openssh.com,
                ssh-rsa-cert-v01@openssh.com,
                ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,
                ssh-ed25519,ssh-rsa
</pre></div>
<p>Если для хоста назначения известны хост-ключи, то это значение по
             умолчанию изменяется для предпочтения их алгоритмов.
</p>
<p>Список доступных типов ключей также можно получить с помощью опции -Q
             ssh(1) с аргументом “key”.
</p>
</dd>
<dt>HostKeyAlias <a name="man_005fssh_005fssh_005fconfig-HostKeyAlias"></a></dt>
<dd><p>Задает псевдоним, который следует использовать вместо реального имени хоста
             при поиске или сохранении ключа хоста в файлах базы данных ключей хоста. Эта
             опция полезна для туннелирования соединений SSH или для нескольких серверов,
             работающих на одном хосте.
</p>
</dd>
<dt>HostName <a name="man_005fssh_005fssh_005fconfig-HostName"></a></dt>
<dd><p>Указывает реальное имя хоста для входа. Это может быть использовано для
             указания псевдонимов или сокращений для хостов. Если имя хоста содержит
             последовательность символов ‘%h’, то оно будет заменено на имя хоста,
             указанное в командной строке (это полезно для манипулирования
             неквалифицированными именами). Последовательность символов ‘%%’ будет
             заменена одним символом ‘%’, который может использоваться при указании
             адресов локальной ссылки IPv6.
</p>
<p>По умолчанию используется имя, указанное в командной строке. Также допустимы
             числовые адреса IP (как в командной строке, так и в спецификациях HostName).
</p>
</dd>
<dt>IdentitiesOnly <a name="man_005fssh_005fssh_005fconfig-IdentitiesOnly"></a></dt>
<dd><p>Указывает, что ssh(1) должен использовать только файлы идентификации и
             сертификата, явно настроенные в файлах ssh_config или переданные в командной
             строке ssh(1), даже если поставщик ssh-agent(1) или PKCS11 предлагает больше
             идентификаторов. Аргумент к этому ключевому слову должен быть “yes” или “no”.
             Эта опция предназначена для ситуаций, когда ssh-agent предлагает много разных
             идентификаторов. По умолчанию используется “no”.
</p>
</dd>
<dt>IdentityFile <a name="man_005fssh_005fssh_005fconfig-IdentityFile"></a></dt>
<dd><p>Указывает файл, из которого читается идентификационная информация пользователя
             DSA, ECDSA, Ed25519 или RSA. По умолчанию используется ~/.ssh/identity для
             версии протокола 1 и ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 и
             ~/.ssh/id_rsa для версии протокола 2. Кроме того, любые идентификаторы,
             представленные агентом аутентификации, будут использоваться для аутентификации,
             если не установлен IdentitiesOnly. Если CertificateFile явно не указывает
             сертификаты, ssh(1) попытается загрузить информацию о сертификате из имени
             файла, полученного путем добавления -cert.pub к пути указанного
             IdentityFile.
</p>
<p>Имя файла может использовать синтаксис тильды для ссылки на домашний каталог
             пользователя или один из следующих escape-символов: ‘%d’ (домашний каталог
             локального пользователя), ‘%u’ (имя локального пользователя), ‘%l’ (имя
             локального хоста), ‘%h’ (имя удаленного хоста) ) или ‘%r’ (имя удаленного
             пользователя).
</p>
<p>Можно указать несколько файлов идентификации, указанных в файлах конфигурации;
             все эти идентичности будут опробованы последовательно. Несколько директив
             IdentityFile добавят к списку опробованных идентификаторов (это поведение
             отличается от поведения других директив конфигурации).
</p>
<p>IdentityFile может использоваться вместе с IdentitiesOnly, чтобы выбрать,
             какие идентификаторы в агенте предлагаются во время аутентификации.
             IdentityFile также может использоваться вместе с CertificateFile для
             предоставления любого сертификата, также необходимого для аутентификации с
             помощью идентификатора.
</p>
</dd>
<dt>IgnoreUnknown <a name="man_005fssh_005fssh_005fconfig-IgnoreUnknown"></a></dt>
<dd><p>Задает список шаблонов неизвестных параметров, которые следует игнорировать,
             если они встречаются при разборе конфигурации. Это может быть использовано
             для подавления ошибок, если ssh_config содержит параметры, которые не
             распознаются ssh(1). Рекомендуется, чтобы IgnoreUnknown был указан в начале
             файла конфигурации, так как он не будет применен к неизвестным параметрам,
             которые появляются перед ним.
</p>
</dd>
<dt>IPQoS <a name="man_005fssh_005fssh_005fconfig-IPQoS"></a></dt>
<dd><p>Определяет тип сервиса IPv4 или класс DSCP для соединений. Допустимые
             значения: “af11”, “af12”, “af13”, “af21”, “af22”, “af23”, “af31”, “af32”,
             “af33”, “af41”, “af42”, “af43”, “cs0”, “cs1”, “cs2”, “cs3”, “cs4”, “cs5”,
             “cs6”, “cs7”, “ef”, “lowdelay”, “throughput”, “reliability” или числовое
             значение. Эта опция может принимать один или два аргумента, разделенных
             пробелом. Если указан один аргумент, он безоговорочно используется в
             качестве класса пакета. Если указаны два значения, первое автоматически
             выбирается для интерактивных сеансов, а второе - для неинтерактивных сеансов.
             По умолчанию используется “lowdelay” для интерактивных сессий и “throughput”
             для неинтерактивных сессий.
</p>
</dd>
<dt>KbdInteractiveAuthentication <a name="man_005fssh_005fssh_005fconfig-KbdInteractiveAuthentication"></a></dt>
<dd><p>Указывает, использовать ли клавиатурно-интерактивную аутентификацию.
             Аргумент к этому ключевому слову должен быть “yes” или “no”. По умолчанию
             используется “yes”.
</p>
</dd>
<dt>KbdInteractiveDevices <a name="man_005fssh_005fssh_005fconfig-KbdInteractiveDevices"></a></dt>
<dd><p>Определяет список методов, используемых в клавиатурно-интерактивной
             аутентификации. Несколько имен методов должны быть разделены запятыми. По
             умолчанию используется указанный сервером список. Доступные методы различаются
             в зависимости от того, что поддерживает сервер. Для сервера OpenSSH это может
             быть ноль или более: “bsdauth”, “pam”, “skey”.
</p>
</dd>
<dt>KexAlgorithms <a name="man_005fssh_005fssh_005fconfig-KexAlgorithms"></a></dt>
<dd><p>Определяет доступные алгоритмы KEX (Обмен ключами). Несколько алгоритмов
             должны быть разделены запятыми. С другой стороны, если указанное значение
             начинается с символа ‘+’, то указанные методы будут добавлены к набору по
             умолчанию вместо их замены. По умолчанию это:
</p><div class="display">
<pre class="display">                   curve25519-sha256@libssh.org,
                   ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,
                   diffie-hellman-group-exchange-sha256,
                   diffie-hellman-group-exchange-sha1,
                   diffie-hellman-group14-sha1
</pre></div>
<p>Список доступных алгоритмов обмена ключами также можно получить, используя
             опцию -Q ssh(1) с аргументом “kex”.
</p>
</dd>
<dt>LocalCommand <a name="man_005fssh_005fssh_005fconfig-LocalCommand"></a></dt>
<dd><p>Указывает команду для выполнения на локальном компьютере после успешного
             подключения к серверу. Командная строка простирается до конца строки и
             выполняется с оболочкой пользователя. Будут выполнены следующие замены
             escape-символов:
</p><div class="display">
<pre class="display">             ‘%d’ (домашний каталог локального пользователя),
             &rsquo;%h&rsquo; (имя удаленного хоста),
             ‘%l’ (имя локального хоста),
             ‘%n’ (имя хоста, указанное в командной строке),
             ‘%p’ (удаленный порт) ),
             ‘%r’ (имя удаленного пользователя) или
             ‘%u’ (имя локального пользователя) или
             ‘%C’ с помощью хэша объединения: %l%h%p%r.
</pre></div>
<p>Команда выполняется синхронно и не имеет доступа к сеансу ssh(1), который
             ее породил. Он не должен использоваться для интерактивных команд.
</p>
<p>Эта директива игнорируется, если PermitLocalCommand не был включен.
</p>
</dd>
<dt>LocalForward <a name="man_005fssh_005fssh_005fconfig-LocalForward"></a></dt>
<dd><p>Указывает, что порт TCP на локальном компьютере будет перенаправлен по
             защищенному каналу на указанный хост и порт с удаленного компьютера. Первый
             аргумент должен быть [bind_address:]port, а второй аргумент должен быть
             host:hostport. Адреса IPv6 можно указать, заключив адреса в квадратные
             скобки. Можно указать несколько переадресаций, а дополнительные пересылки
             можно указать в командной строке. Только суперпользователь может пересылать
             приватные порты. По умолчанию локальный порт связан в соответствии с
             настройкой GatewayPorts. Однако явный bind_address может использоваться для
             привязки соединения к определенному адресу. bind_address из “localhost”
             указывает, что прослушивающий порт должен быть привязан только для локального
             использования, в то время как пустой адрес или ‘*’ указывает, что порт должен
             быть доступен со всех интерфейсов.
</p>
</dd>
<dt>LogLevel <a name="man_005fssh_005fssh_005fconfig-LogLevel"></a></dt>
<dd><p>Дает уровень многословия, который используется при регистрации сообщений
             от ssh(1). Возможные значения: QUIET, FATAL, ERROR, INFO, VER‐BOSE, DEBUG,
             DEBUG1, DEBUG2, и DEBUG3. По умолчанию используется INFO. DEBUG и DEBUG1
             эквивалентны. Каждый DEBUG2 и DEBUG3 определяет более высокий уровень
             подробного вывода.
</p>
</dd>
<dt>MACs <a name="man_005fssh_005fssh_005fconfig-MACs"></a></dt>
<dd><p>Определяет алгоритмы MAC (код аутентификации сообщения) в порядке
             предпочтения. Алгоритм MAC используется для защиты целостности данных.
             Несколько алгоритмов должны быть разделены запятыми. Если указанное значение
             начинается с символа ‘+’, то указанные алгоритмы будут добавлены в набор по
             умолчанию вместо их замены.
</p>
<p>Алгоритмы, содержащие “-etm”, вычисляют MAC после шифрования
             (encrypt-then-mac). Они считаются более безопасными, и их использование
             рекомендуется.
</p>
<p>По умолчанию:
</p><div class="display">
<pre class="display">                   umac-64-etm@openssh.com,umac-128-etm@openssh.com,
                   hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,
                   hmac-sha1-etm@openssh.com,
                   umac-64@openssh.com,umac-128@openssh.com,
                   hmac-sha2-256,hmac-sha2-512,hmac-sha1
</pre></div>
<p>Список доступных алгоритмов MAC также можно получить с помощью опции
             -Q ssh(1) с аргументом “mac”.
</p>
</dd>
<dt>NoHostAuthenticationForLocalhost <a name="man_005fssh_005fssh_005fconfig-NoHostAuthenticationForLocalhost"></a></dt>
<dd><p>Эта опция может использоваться, если домашний каталог является общим для
             всех компьютеров. В этом случае localhost будет ссылаться на разные машины
             на каждой машине, и пользователь получит много предупреждений об изменении
             ключей хоста. Однако этот параметр отключает аутентификацию хоста для
             localhost. Аргумент к этому ключевому слову должен быть “yes” или “no”. По
             умолчанию проверяется ключ хоста для localhost.
</p>
</dd>
<dt>NumberOfPasswordPrompts <a name="man_005fssh_005fssh_005fconfig-NumberOfPasswordPrompts"></a></dt>
<dd><p>Определяет количество запросов пароля, прежде чем отказаться. Аргумент
             к этому ключевому слову должен быть целым числом. По умолчанию 3.
</p>
</dd>
<dt>PasswordAuthentication <a name="man_005fssh_005fssh_005fconfig-PasswordAuthentication"></a></dt>
<dd><p>Указывает, использовать ли аутентификацию по паролю. Аргумент к этому
             ключевому слову должен быть “yes” или “no”. По умолчанию используется
             “yes”.
</p>
</dd>
<dt>PermitLocalCommand <a name="man_005fssh_005fssh_005fconfig-PermitLocalCommand"></a></dt>
<dd><p>Разрешить локальное выполнение команды с помощью опции LocalCommand или
             с помощью escape-последовательности команды! В ssh(1). Аргумент должен
             быть “yes” или “no”. По умолчанию используется “no”.
</p>
</dd>
<dt>PKCS11Provider <a name="man_005fssh_005fssh_005fconfig-PKCS11Provider"></a></dt>
<dd><p>Определяет, какого поставщика PKCS#11 использовать. Аргументом к этому
             ключевому слову является разделяемая библиотека PKCS#11, которую ssh(1)
             следует использовать для связи с токеном PKCS#11, предоставляющим личный ключ
             пользователя RSA.
</p>
</dd>
<dt>Port <a name="man_005fssh_005fssh_005fconfig-Port"></a></dt>
<dd><p>Указывает номер порта для подключения на удаленном хосте. По умолчанию
             это 22.
</p>
</dd>
<dt>PreferredAuthentications <a name="man_005fssh_005fssh_005fconfig-PreferredAuthentications"></a></dt>
<dd><p>Указывает порядок, в котором клиент должен попробовать методы аутентификации.
             Это позволяет клиенту предпочесть один метод (например, интерактивный с
             клавиатуры) другому методу (например, пароль). По умолчанию это:
</p><div class="display">
<pre class="display">                   gssapi-with-mic,hostbased,publickey,
                   keyboard-interactive,password
</pre></div>
</dd>
<dt>Protocol <a name="man_005fssh_005fssh_005fconfig-Protocol"></a></dt>
<dd><p>Указывает версии протокола, которые должен поддерживать ssh(1) в порядке
             предпочтения. Возможные значения: ‘1’ и ‘2’. Несколько версий должны быть
             разделены запятыми. Если для этого параметра установлено значение “2,1”, ssh
             будет пытаться использовать версию 2 и переходить к версии 1, если версия 2
             недоступна. По умолчанию используется ‘2’. Протокол 1 страдает от ряда
             криптографических недостатков и не должен использоваться. Предлагается только
             для поддержки устаревших устройств.
</p>
</dd>
<dt>ProxyCommand <a name="man_005fssh_005fssh_005fconfig-ProxyCommand"></a></dt>
<dd><p>Указывает команду, используемую для подключения к серверу. Строка команды
             простирается до конца строки и выполняется с использованием директивы
             оболочки ‘exec’ пользователя, чтобы избежать длительного процесса оболочки.
</p>
<p>В командной строке любое вхождение ‘%h’ будет заменено именем хоста для
             подключения, ‘%p’ - портом, а ‘%r’ - именем удаленного пользователя. Команда
             может быть в основном чем угодно, и должна читать из стандартного ввода и
             записывать в стандартный вывод. В конечном итоге он должен подключиться к
             серверу sshd(8), работающему на какой-либо машине, или выполнить sshd -i
             где-нибудь. Управление ключами хоста будет осуществляться с использованием
             HostName подключаемого хоста (по умолчанию используется имя, введенное
             пользователем). Установка команды в “none” полностью отключает эту опцию.
             Обратите внимание, что CheckHostIP недоступен для соединений с
             прокси-командой.
</p>
<p>Эта директива полезна в сочетании с nc(1) и его поддержкой прокси. Например,
             следующая директива будет подключаться через прокси HTTP в 192.0.2.0:
</p>
<p>ProxyCommand /usr/bin/nc -X connect -x 192.0.2.0:8080 %h %p
</p>
</dd>
<dt>ProxyUseFdpass <a name="man_005fssh_005fssh_005fconfig-ProxyUseFdpass"></a></dt>
<dd><p>Указывает, что ProxyCommand будет передавать дескриптор подключенного файла
             обратно в ssh(1) вместо продолжения выполнения и передачи данных. По
             умолчанию используется “no”.
</p>
</dd>
<dt>PubkeyAcceptedKeyTypes <a name="man_005fssh_005fssh_005fconfig-PubkeyAcceptedKeyTypes"></a></dt>
<dd><p>Задает типы ключей, которые будут использоваться для аутентификации с
             открытым ключом в виде списка шаблонов, разделенных запятыми. С другой
             стороны, если указанное значение начинается с символа ‘+’, то ключи типа
             после него будут добавлены к значению по умолчанию вместо его замены. По
             умолчанию для этой опции:
</p><div class="display">
<pre class="display">                ecdsa-sha2-nistp256-cert-v01@openssh.com,
                ecdsa-sha2-nistp384-cert-v01@openssh.com,
                ecdsa-sha2-nistp521-cert-v01@openssh.com,
                ssh-ed25519-cert-v01@openssh.com,
                ssh-rsa-cert-v01@openssh.com,
                ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,
                ssh-ed25519,ssh-rsa
</pre></div>
<p>Опция -Q в ssh(1) может использоваться для отображения поддерживаемых
             типов ключей.
</p>
</dd>
<dt>PubkeyAuthentication <a name="man_005fssh_005fssh_005fconfig-PubkeyAuthentication"></a></dt>
<dd><p>Указывает, следует ли использовать аутентификацию с открытым ключом.
             Аргумент к этому ключевому слову должен быть “yes” или “no”. По умолчанию
             используется “yes”.
</p>
</dd>
<dt>RekeyLimit <a name="man_005fssh_005fssh_005fconfig-RekeyLimit"></a></dt>
<dd><p>Задает максимальный объем данных, которые могут быть переданы до повторного
             согласования ключа сеанса, при желании может следовать максимальное количество
             времени, которое может пройти до повторного согласования ключа сеанса. Первый
             аргумент указывается в байтах и ​​может иметь суффикс ‘K’, ‘M’, и ‘G’ для
             обозначения килобайт, Megabytes или Gigabytes соответственно. Значение по
             умолчанию находится между ‘1G’ и ‘4G’, в зависимости от шифра. Необязательное
             второе значение указывается в секундах и может использовать любые единицы
             измерения, указанные в разделе TIME FORMATS раздела sshd_config(5). Значением
             по умолчанию для RekeyLimit является “default none”, что означает, что
             повторный ввод выполняется после того, как объем данных шифра был отправлен
             или получен, а повторный ввод по времени не выполняется.
</p>
</dd>
<dt>RemoteForward <a name="man_005fssh_005fssh_005fconfig-RemoteForward"></a></dt>
<dd><p>Указывает, что порт TCP на удаленной машине будет перенаправлен по защищенному
             каналу на указанный хост и порт с локальной машины. Первый аргумент должен
             быть [bind_address:]port, а второй аргумент должен быть host:hostport. Адреса
             IPv6 можно указать, заключив адреса в квадратные скобки. Можно указать
             несколько переадресаций, а дополнительные пересылки можно указать в командной
             строке. Привилегированные порты могут быть перенаправлены только при входе в
             систему как root на удаленной машине.
</p>
<p>Если аргумент порта - ‘0’, порт прослушивания будет динамически выделяться
             на сервере и сообщаться клиенту во время выполнения.
</p>
<p>Если bind_address не указан, по умолчанию выполняется привязка только к
             адресам обратной связи. Если bind_address является ‘*’ или пустой строкой, то
             переадресация запрашивается для прослушивания на всех интерфейсах. Задание
             удаленного bind_address будет успешным, только если включена опция сервера
             GatewayPorts (смотри sshd_config(5)).
</p>
</dd>
<dt>RequestTTY <a name="man_005fssh_005fssh_005fconfig-RequestTTY"></a></dt>
<dd><p>Указывает, следует ли запрашивать псевдотерминал для сеанса. Аргумент может
             быть одним из: “no” (никогда не запрашивать TTY), “yes” (всегда запрашивать
             TTY, когда стандартным вводом является TTY), “force” (всегда запрашивать TTY)
             или “auto” (запрашивать TTY при открытии сеанса входа в систему) , Эта опция
             отражает флаги -t и -T для ssh(1).
</p>
</dd>
<dt>RevokedHostKeys <a name="man_005fssh_005fssh_005fconfig-RevokedHostKeys"></a></dt>
<dd><p>Указывает отозванные открытые ключи хоста. Ключи, перечисленные в этом файле,
             будут отклонены для аутентификации хоста. Обратите внимание, что если этот
             файл не существует или недоступен для чтения, то аутентификация хоста будет
             отклонена для всех хостов. Ключи могут быть указаны в виде текстового файла с
             указанием одного открытого ключа в строке или в виде OpenSSH Key Revocation
             List (KRL), сгенерированного ssh-keygen(1). Для получения дополнительной
             информации об KRLs см. Раздел KEY REVOCATION LISTS в ssh-keygen(1).
</p>
</dd>
<dt>RhostsRSAAuthentication <a name="man_005fssh_005fssh_005fconfig-RhostsRSAAuthentication"></a></dt>
<dd><p>Указывает, следует ли использовать аутентификацию на основе rhosts с
             аутентификацией хоста RSA. Аргумент должен быть “yes” или “no”. По
             умолчанию используется “no”. Эта опция применима только к протоколу версии 1
             и требует, чтобы для ssh(1) было установлено значение root.
</p>
</dd>
<dt>RSAAuthentication <a name="man_005fssh_005fssh_005fconfig-RSAAuthentication"></a></dt>
<dd><p>Указывает, следует ли попробовать аутентификацию RSA. Аргумент к этому
             ключевому слову должен быть “yes” или “no”. Проверка подлинности RSA будет
             выполняться только в том случае, если существует файл идентификации или
             работает агент проверки подлинности. По умолчанию используется “yes”.
             Обратите внимание, что этот параметр применяется только к версии
             протокола 1.
</p>
</dd>
<dt>SendEnv <a name="man_005fssh_005fssh_005fconfig-SendEnv"></a></dt>
<dd><p>Указывает, какие переменные из локального environ(7) следует отправлять на
             сервер. Сервер также должен поддерживать его, и сервер должен быть настроен
             на прием этих переменных среды. Обратите внимание, что переменная окружения
             TERM всегда отправляется всякий раз, когда запрашивается псевдо-терминал, как
             того требует протокол. Обратитесь к AcceptEnv в sshd_config(5) для того, чтобы
             настроить сервер. Переменные указываются по имени, которое может содержать
             символы подстановки. Несколько переменных среды могут быть разделены пробелами
             или распределены по нескольким директивам SendEnv. По умолчанию не
             отправляются никакие переменные среды.
</p>
<p>Смотрите PATTERNS для получения дополнительной информации о шаблонах.
</p>
</dd>
<dt>ServerAliveCountMax <a name="man_005fssh_005fssh_005fconfig-ServerAliveCountMax"></a></dt>
<dd><p>Устанавливает количество живых сообщений сервера (см. Ниже), которые могут
             быть отправлены без ssh(1) получения каких-либо сообщений от сервера. Если
             этот порог достигнут, когда отправляются живые сообщения сервера, ssh
             отключится от сервера, завершив сеанс. Важно отметить, что использование
             живых сообщений на сервере сильно отличается от TCPKeepAlive (ниже). Живые
             сообщения сервера отправляются по зашифрованному каналу и поэтому не могут
             быть подделаны. Опция keepalive TCP, включенная TCPKeepAlive, подделана.
             Механизм работы сервера полезен, когда клиент или сервер зависят от того,
             когда соединение стало неактивным.
</p>
<p>Значение по умолчанию - 3. Если, например, для ServerAliveInterval (см. Ниже)
           установлено значение 15, а для ServerAliveCountMax оставлено значение по
           умолчанию, если сервер перестает отвечать на запросы, ssh отключится
           примерно через 45 секунд.
</p>
</dd>
<dt>ServerAliveInterval <a name="man_005fssh_005fssh_005fconfig-ServerAliveInterval"></a></dt>
<dd><p>Устанавливает интервал ожидания в секундах, после которого, если от
             сервера не было получено никаких данных, ssh(1) отправит сообщение через
             зашифрованный канал для запроса ответа от сервера. По умолчанию 0, что
             означает, что эти сообщения не будут отправлены на сервер, или 300, если
             установлена ​​опция BatchMode. ProtocolKeepAlives и SetupTimeOut - псевдонимы
             совместимости для Debian для этой опции.
</p>
</dd>
<dt>StreamLocalBindMask <a name="man_005fssh_005fssh_005fconfig-StreamLocalBindMask"></a></dt>
<dd><p>Устанавливает восьмеричную маску режима создания файла (umask), используемую
             при создании файла сокета Unix-домена для локальной или удаленной
             переадресации портов. Эта опция используется только для переадресации портов
             в файл сокета Unix-домена.
</p>
<p>Значением по умолчанию является 0177, которое создает файл сокета Unix-домена,
             который доступен для чтения и записи только владельцу. Обратите внимание, что
             не все операционные системы поддерживают режим файлов в файлах сокетов
             Unix-домена.
</p>
</dd>
<dt>StreamLocalBindUnlink <a name="man_005fssh_005fssh_005fconfig-StreamLocalBindUnlink"></a></dt>
<dd><p>Указывает, следует ли удалить существующий файл сокета Unix-domain для
             локальной или удаленной переадресации портов перед созданием нового. Если
             файл сокета уже существует и StreamLocalBindUnlink не включен, ssh не сможет
             перенаправить порт в файл сокета Unix-домена. Эта опция используется только
             для переадресации портов в файл сокета Unix-домена.
</p>
<p>Аргумент должен быть “yes” или “no”. По умолчанию используется “no”.
</p>
</dd>
<dt>StrictHostKeyChecking <a name="man_005fssh_005fssh_005fconfig-StrictHostKeyChecking"></a></dt>
<dd><p>Если этот флаг установлен на “yes”, ssh(1) никогда не будет автоматически
             добавлять ключи хоста в файл ~/.ssh/known_hosts и отказывается подключаться
             к хостам, чей ключ хоста был изменен. Это обеспечивает максимальную защиту от
             атак троянских коней, хотя это может раздражать, если файл
             /etc/ssh/ssh_known_hosts плохо поддерживается или когда часто устанавливаются
             соединения с новыми хостами. Эта опция заставляет пользователя вручную
             добавлять все новые хосты. Если этот флаг установлен в “no”, ssh автоматически
             добавит новые ключи хоста в файлы известных хостов пользователя. Если для
             этого флага установлено значение “ask”, новые ключи хоста будут добавлены в
             известные хост-файлы пользователя только после того, как пользователь
             подтвердит, что это именно то, что он действительно хочет сделать, и ssh
             откажется подключаться к хостам, чей ключ хоста был изменен. Ключи известных
             хостов будут автоматически проверяться во всех случаях. Аргумент должен быть
             “yes”, “no”, или “ask”. По умолчанию используется “ask”.
</p>
</dd>
<dt>TCPKeepAlive <a name="man_005fssh_005fssh_005fconfig-TCPKeepAlive"></a></dt>
<dd><p>Указывает, должна ли система отправлять сообщения поддержки активности TCP
             другой стороне. Если они отправлены, смерть соединения или сбой одной из машин
             будут правильно замечены. Эта опция использует только keepalive TCP (в отличие
             от использования keepalive уровня ssh), поэтому требуется много времени, чтобы
             заметить, когда соединение разрывается. Таким образом, вы, вероятно, также
             захотите использовать опцию ServerAliveInterval. Однако это означает, что
             соединения прекратят свое существование, если маршрут временно не работает, и
             некоторые люди считают это раздражающим.
</p>
<p>По умолчанию используется “yes” (для отправки сообщений keepalive TCP), и
             клиент заметит, если сеть выйдет из строя или удаленный хост умрет. Это важно
             в сценариях, и многие пользователи тоже этого хотят.
</p>
<p>Чтобы отключить сообщения поддержки активности TCP, необходимо установить
             значение “no”.
</p>
</dd>
<dt>Tunnel <a name="man_005fssh_005fssh_005fconfig-Tunnel"></a></dt>
<dd><p>Запросите переадресацию устройства tun(4) между клиентом и сервером. Аргумент
             должен быть “yes”, “point-to-point” (layer 3), “ethernet” (layer 2), или “no”.
             Указание “yes” запрашивает режим туннелирования по умолчанию, то есть
             “point-to-point”. По умолчанию используется “no”.
</p>
</dd>
<dt>TunnelDevice <a name="man_005fssh_005fssh_005fconfig-TunnelDevice"></a></dt>
<dd><p>Задает устройства tun(4), которые нужно открыть на клиенте (local_tun) и на
             сервере (remote_tun).
</p>
<p>Аргумент должен быть local_tun[:remote_tun]. Устройства могут быть указаны
             числовым ID или ключевым словом “any”, которое использует следующее доступное
             туннельное устройство. Если remote_tun не указан, по умолчанию используется
             “any”. По умолчанию используется “any:any”.
</p>
</dd>
<dt>UpdateHostKeys <a name="man_005fssh_005fssh_005fconfig-UpdateHostKeys"></a></dt>
<dd><p>Определяет, должен ли ssh(1) принимать уведомления о дополнительных ключах
             хоста от сервера, отправленные после завершения аутентификации, и добавлять
             их в UserKnownHostsFile. Аргумент должен быть “yes”, “no” (по умолчанию) или
             “ask”. Включение этой опции позволяет изучать альтернативные ключи хоста для
             сервера и поддерживает плавное чередование ключей, позволяя серверу отправлять
             замененные открытые ключи до того, как старые будут удалены. Дополнительные
             ключи хоста принимаются только в том случае, если ключ, используемый для
             аутентификации хоста, уже был доверенным или явно принят пользователем. Если
             для UpdateHostKeys установлено значение “ask”, пользователю предлагается
             подтвердить изменения в файле known_hosts. Подтверждение в настоящее время
             несовместимо с ControlPersist и будет отключено, если оно включено.
</p>
<p>В настоящее время только sshd(8) из OpenSSH 6.8 и выше поддерживает расширение
             протокола “hostkeys@openssh.com”, используемое для информирования клиента
             обо всех ключах хоста сервера.
</p>
</dd>
<dt>UsePrivilegedPort <a name="man_005fssh_005fssh_005fconfig-UsePrivilegedPort"></a></dt>
<dd><p>Указывает, использовать ли привилегированный порт для исходящих соединений.
             Аргумент должен быть “yes” или “no”. По умолчанию используется “no”. Если
             установлено значение “yes”, для ssh(1) должен быть установлен root. Обратите
             внимание, что этот параметр должен быть установлен в “yes” для
             RhostsRSAAuthentication со старыми серверами.
</p>
</dd>
<dt>User <a name="man_005fssh_005fssh_005fconfig-User"></a></dt>
<dd><p>Определяет пользователя для входа в систему. Это может быть полезно, когда
             на разных машинах используется другое имя пользователя. Это избавляет от
             необходимости помнить, имя пользователя для указания его в командной строке.
</p>
</dd>
<dt>UserKnownHostsFile <a name="man_005fssh_005fssh_005fconfig-UserKnownHostsFile"></a></dt>
<dd><p>Задает один или несколько файлов для использования в базе данных ключей
             хоста пользователя, разделенных пробелами. По умолчанию используется
             ~/.ssh/known_hosts, ~/.ssh/known_hosts2.
</p>
</dd>
<dt>VerifyHostKeyDNS <a name="man_005fssh_005fssh_005fconfig-VerifyHostKeyDNS"></a></dt>
<dd><p>Указывает, проверять ли удаленный ключ с помощью записей ресурсов DNS и SSHFP.
             Если для этого параметра установлено значение “yes”, клиент будет неявно
             доверять ключам, которые соответствуют защищенному отпечатку от DNS.
             Небезопасные отпечатки пальцев будут обрабатываться так, как если бы этот
             параметр был установлен в “ask”. Если для этого параметра установлено значение
             “ask”, будет отображаться информация о совпадении отпечатков пальцев, но
             пользователю все равно потребуется подтвердить новые ключи хоста в
             соответствии с параметром StrictHostKeyChecking. Аргумент должен быть “yes”,
             “no”, или “ask”. По умолчанию используется “no”.
</p>
<p>Смотрите также VERIFYING HOST KEYS в ssh(1).
</p>
</dd>
<dt>VisualHostKey <a name="man_005fssh_005fssh_005fconfig-VisualHostKey"></a></dt>
<dd><p>Если для этого флага установлено значение “yes”, в дополнение к строке
             отпечатка пальца при входе в систему и для неизвестных ключей хоста печатается
             художественное представление ASCII отпечатка пальца ключа удаленного хоста.
             Если для этого флага установлено значение “no”, при входе в систему не
             выводятся строки отпечатков пальцев, а для неизвестных ключей хоста будет
             печататься только строка отпечатков пальцев. По умолчанию используется “no”.
</p>
</dd>
<dt>XAuthLocation <a name="man_005fssh_005fssh_005fconfig-XAuthLocation"></a></dt>
<dd><p>Задает полный путь к программе xauth(1). По умолчанию используется
             /usr/bin/xauth.
</p></dd>
</dl>
</dd>
<dt>PATTERNS</dt>
<dd><p>Шаблон состоит из нуля или более непробельных символов, ‘*’ (подстановочный знак,
     который соответствует нулю или более символов) или ‘?’ (подстановочный знак,
     который соответствует ровно одному символу). Например, чтобы указать набор объявлений
     для любого хоста в наборе доменов “.co.uk”, можно использовать следующий шаблон:
</p><div class="display">
<pre class="display">           Host *.co.uk
</pre></div>
<p>Следующий шаблон будет соответствовать любому хосту в диапазоне сети 192.168.0.[0-9]:
</p><div class="display">
<pre class="display">           Host 192.168.0.?
</pre></div>
<p>Список шаблонов - это список шаблонов, разделенных запятыми. Шаблоны в списках
     шаблонов можно отменить, поставив перед ними восклицательный знак (‘!’). Например,
     чтобы разрешить использование ключа из любой точки организации, кроме пула “dialup”,
     можно использовать следующую запись (в authorized_keys):
</p><div class="display">
<pre class="display">           from=&quot;!*.dialup.example.com,*.example.com&quot;
</pre></div>
</dd>
<dt>FILES</dt>
<dd><dl compact="compact">
<dt>~/.ssh/config</dt>
<dd><p>Это файл конфигурации для каждого пользователя. Формат этого файла описан
             выше. Этот файл используется клиентом SSH. Из-за возможного злоупотребления
             этот файл должен иметь строгие разрешения: чтение/запись для пользователя и
             недоступность для других. Это может быть доступно для записи в группе при
             условии, что рассматриваемая группа содержит только пользователя.
</p>
</dd>
<dt>/etc/ssh/ssh_config</dt>
<dd><p>Общесистемный файл конфигурации. Этот файл предоставляет значения по
             умолчанию для тех значений, которые не указаны в файле конфигурации
             пользователя, и для тех пользователей, у которых нет файла конфигурации.
             Этот файл должен быть доступен для чтения всем.
</p></dd>
</dl>
</dd>
<dt>SEE ALSO</dt>
<dd><p>ssh(1)
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.
</p>
<p>BSD                            February 20, 2016                           BSD
</p></dd>
</dl>
<hr>
<a name="SSHD_005fCONFIG"></a>
<div class="header">
<p>
Next: <a href="#SCP_00281_0029" accesskey="n" rel="next">SCP(1)</a>, Previous: <a href="#SSH_005fCONFIG" accesskey="p" rel="prev">SSH_CONFIG</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSHD_005fCONFIG-1"></a>
<h2 class="chapter">4 SSHD_CONFIG</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>sshd_config — Файл конфигурации демона OpenSSH SSH
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>/etc/ssh/sshd_config
</p></dd>
<dt>DESCRIPTION</dt>
<dd><p>sshd (8) считывает данные конфигурации из /etc/ssh/sshd_config (или файла,
     указанного в командной строке -f). Файл содержит пары ключевое слово-аргумент,
     по одной на строку. Строки, начинающиеся с ‘#’ и пустые строки, интерпретируются
     как комментарии. Аргументы могут быть необязательно заключены в двойные кавычки
     (&quot;) для представления аргументов, содержащих пробелы.
</p>
<p>Обратите внимание, что пакет openssh-сервера Debian устанавливает несколько
     опций в качестве стандартного в /etc/ssh/sshd_config, которые не являются
     параметрами по умолчанию в sshd(8). Точный список зависит от того, был ли
     пакет установлен свежим или обновлен с различных возможных предыдущих версий,
     но включает по крайней мере следующее:
</p><div class="display">
<pre class="display">           ·   ChallengeResponseAuthentication no
           ·   X11Forwarding yes
           ·   PrintMotd no
           ·   AcceptEnv LANG LC_*
           ·   Subsystem sftp /usr/lib/openssh/sftp-server
           ·   UsePAM yes
</pre></div>
<p>Возможные ключевые слова и их значения следующие (обратите внимание, что
     ключевые слова не чувствительны к регистру, а аргументы чувствительны к регистру):
</p></dd>
<dt>Список Ключевых слов</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fsshd_005fconfig-AcceptEnv">AcceptEnv</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AddressFamily">AddressFamily</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AllowAgentForwarding">AllowAgentForwarding</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AllowGroups">AllowGroups</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AllowTcpForwarding">AllowTcpForwarding</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AllowStreamLocalForwarding">AllowStreamLocalForwarding</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AllowUsers">AllowUsers</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AuthenticationMethods">AuthenticationMethods</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AuthorizedKeysCommand">AuthorizedKeysCommand</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AuthorizedKeysCommandUser">AuthorizedKeysCommandUser</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AuthorizedKeysFile">AuthorizedKeysFile</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AuthorizedPrincipalsCommand">AuthorizedPrincipalsCommand</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AuthorizedPrincipalsCommandUser">AuthorizedPrincipalsCommandUser</a>
     <a href="#man_005fssh_005fsshd_005fconfig-AuthorizedPrincipalsFile">AuthorizedPrincipalsFile</a>
     <a href="#man_005fssh_005fsshd_005fconfig-Banner">Banner</a>
     <a href="#man_005fssh_005fsshd_005fconfig-ChallengeResponseAuthentication">ChallengeResponseAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-ChrootDirectory">ChrootDirectory</a>
     <a href="#man_005fssh_005fsshd_005fconfig-Ciphers">Ciphers</a>
     <a href="#man_005fssh_005fsshd_005fconfig-ClientAliveCountMax">ClientAliveCountMax</a>
     <a href="#man_005fssh_005fsshd_005fconfig-ClientAliveInterval">ClientAliveInterval</a>
     <a href="#man_005fssh_005fsshd_005fconfig-Compression">Compression</a>
     <a href="#man_005fssh_005fsshd_005fconfig-DebianBanner">DebianBanner</a>
     <a href="#man_005fssh_005fsshd_005fconfig-DenyGroups">DenyGroups</a>
     <a href="#man_005fssh_005fsshd_005fconfig-DenyUsers">DenyUsers</a>
     <a href="#man_005fssh_005fsshd_005fconfig-FingerprintHash">FingerprintHash</a>
     <a href="#man_005fssh_005fsshd_005fconfig-ForceCommand">ForceCommand</a>
     <a href="#man_005fssh_005fsshd_005fconfig-GatewayPorts">GatewayPorts</a>
     <a href="#man_005fssh_005fsshd_005fconfig-GSSAPIAuthentication">GSSAPIAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-GSSAPIKeyExchange">GSSAPIKeyExchange</a>
     <a href="#man_005fssh_005fsshd_005fconfig-GSSAPICleanupCredentials">GSSAPICleanupCredentials</a>
     <a href="#man_005fssh_005fsshd_005fconfig-GSSAPIStrictAcceptorCheck">GSSAPIStrictAcceptorCheck</a>
     <a href="#man_005fssh_005fsshd_005fconfig-GSSAPIStoreCredentialsOnRekey">GSSAPIStoreCredentialsOnRekey</a>
     <a href="#man_005fssh_005fsshd_005fconfig-HostbasedAcceptedKeyTypes">HostbasedAcceptedKeyTypes</a>
     <a href="#man_005fssh_005fsshd_005fconfig-HostbasedAuthentication">HostbasedAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-HostbasedUsesNameFromPacketOnly">HostbasedUsesNameFromPacketOnly</a>
     <a href="#man_005fssh_005fsshd_005fconfig-HostCertificate">HostCertificate</a>
     <a href="#man_005fssh_005fsshd_005fconfig-HostKey">HostKey</a>
     <a href="#man_005fssh_005fsshd_005fconfig-HostKeyAgent">HostKeyAgent</a>
     <a href="#man_005fssh_005fsshd_005fconfig-HostKeyAlgorithms">HostKeyAlgorithms</a>
     <a href="#man_005fssh_005fsshd_005fconfig-IgnoreRhosts">IgnoreRhosts</a>
     <a href="#man_005fssh_005fsshd_005fconfig-IgnoreUserKnownHosts">IgnoreUserKnownHosts</a>
     <a href="#man_005fssh_005fsshd_005fconfig-IPQoS">IPQoS</a>
     <a href="#man_005fssh_005fsshd_005fconfig-KbdInteractiveAuthentication">KbdInteractiveAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-KerberosAuthentication">KerberosAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-KerberosGetAFSToken">KerberosGetAFSToken</a>
     <a href="#man_005fssh_005fsshd_005fconfig-KerberosOrLocalPasswd">KerberosOrLocalPasswd</a>
     <a href="#man_005fssh_005fsshd_005fconfig-KerberosTicketCleanup">KerberosTicketCleanup</a>
     <a href="#man_005fssh_005fsshd_005fconfig-KexAlgorithms">KexAlgorithms</a>
     <a href="#man_005fssh_005fsshd_005fconfig-KeyRegenerationInterval">KeyRegenerationInterval</a>
     <a href="#man_005fssh_005fsshd_005fconfig-ListenAddress">ListenAddress</a>
     <a href="#man_005fssh_005fsshd_005fconfig-LoginGraceTime">LoginGraceTime</a>
     <a href="#man_005fssh_005fsshd_005fconfig-LogLevel">LogLevel</a>
     <a href="#man_005fssh_005fsshd_005fconfig-MACs">MACs</a>
     <a href="#man_005fssh_005fsshd_005fconfig-Match">Match</a>
     <a href="#man_005fssh_005fsshd_005fconfig-MaxAuthTries">MaxAuthTries</a>
     <a href="#man_005fssh_005fsshd_005fconfig-MaxSessions">MaxSessions</a>
     <a href="#man_005fssh_005fsshd_005fconfig-MaxStartups">MaxStartups</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PasswordAuthentication">PasswordAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PermitEmptyPasswords">PermitEmptyPasswords</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PermitOpen">PermitOpen</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PermitRootLogin">PermitRootLogin</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PermitTunnel">PermitTunnel</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PermitTTY">PermitTTY</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PermitUserEnvironment">PermitUserEnvironment</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PermitUserRC">PermitUserRC</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PidFile">PidFile</a>
     <a href="#man_005fssh_005fsshd_005fconfig-Port">Port</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PrintLastLog">PrintLastLog</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PrintMotd">PrintMotd</a>
     <a href="#man_005fssh_005fsshd_005fconfig-Protocol">Protocol</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PubkeyAcceptedKeyTypes">PubkeyAcceptedKeyTypes</a>
     <a href="#man_005fssh_005fsshd_005fconfig-PubkeyAuthentication">PubkeyAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-RekeyLimit">RekeyLimit</a>
     <a href="#man_005fssh_005fsshd_005fconfig-RevokedKeys">RevokedKeys</a>
     <a href="#man_005fssh_005fsshd_005fconfig-RhostsRSAAuthentication">RhostsRSAAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-RSAAuthentication">RSAAuthentication</a>
     <a href="#man_005fssh_005fsshd_005fconfig-ServerKeyBits">ServerKeyBits</a>
     <a href="#man_005fssh_005fsshd_005fconfig-StreamLocalBindMask">StreamLocalBindMask</a>
     <a href="#man_005fssh_005fsshd_005fconfig-StreamLocalBindUnlink">StreamLocalBindUnlink</a>
     <a href="#man_005fssh_005fsshd_005fconfig-StrictModes">StrictModes</a>
     <a href="#man_005fssh_005fsshd_005fconfig-Subsystem">Subsystem</a>
     <a href="#man_005fssh_005fsshd_005fconfig-SyslogFacility">SyslogFacility</a>
     <a href="#man_005fssh_005fsshd_005fconfig-TCPKeepAlive">TCPKeepAlive</a>
     <a href="#man_005fssh_005fsshd_005fconfig-TrustedUserCAKeys">TrustedUserCAKeys</a>
     <a href="#man_005fssh_005fsshd_005fconfig-UseDNS">UseDNS</a>
     <a href="#man_005fssh_005fsshd_005fconfig-UseLogin">UseLogin</a>
     <a href="#man_005fssh_005fsshd_005fconfig-UsePAM">UsePAM</a>
     <a href="#man_005fssh_005fsshd_005fconfig-UsePrivilegeSeparation">UsePrivilegeSeparation</a>
     <a href="#man_005fssh_005fsshd_005fconfig-VersionAddendum">VersionAddendum</a>
     <a href="#man_005fssh_005fsshd_005fconfig-X11DisplayOffset">X11DisplayOffset</a>
     <a href="#man_005fssh_005fsshd_005fconfig-X11Forwarding">X11Forwarding</a>
     <a href="#man_005fssh_005fsshd_005fconfig-X11UseLocalhost">X11UseLocalhost</a>
     <a href="#man_005fssh_005fsshd_005fconfig-XAuthLocation">XAuthLocation</a>
     
</pre></div>
<dl compact="compact">
<dt>AcceptEnv <a name="man_005fssh_005fsshd_005fconfig-AcceptEnv"></a></dt>
<dd><p>Указывает, какие переменные среды, отправленные клиентом, будут скопированы
             в environ(7) сеанса. Смотри SendEnv в ssh_config(5) для того, как настроить
             клиент. Переменная окружения TERM всегда отправляется всякий раз, когда
             клиент запрашивает псевдо-терминал, как того требует протокол. Переменные
             указываются по имени, которое может содержать символы подстановки ‘*’ и ‘?’.
             Несколько переменных среды могут быть разделены пробелами или распределены по
             нескольким директивам AcceptEnv. Имейте в виду, что некоторые переменные
             среды могут использоваться для обхода ограниченных пользовательских сред. По
             этой причине следует соблюдать осторожность при использовании этой директивы.
             По умолчанию не принимается никаких переменных среды.
</p>
</dd>
<dt>AddressFamily <a name="man_005fssh_005fsshd_005fconfig-AddressFamily"></a></dt>
<dd><p>Указывает, какое семейство адресов должно использоваться sshd(8). Допустимые
             аргументы: “any”, “inet” (использовать только IPv4) или “inet6” (использовать
             только IPv6). По умолчанию используется “any”.
</p>
</dd>
<dt>AllowAgentForwarding <a name="man_005fssh_005fsshd_005fconfig-AllowAgentForwarding"></a></dt>
<dd><p>Указывает, разрешена ли пересылка ssh-agent(1). По умолчанию используется
             “yes”. Обратите внимание, что отключение переадресации агентов не повышает
             безопасность, если пользователям также не запрещен доступ к оболочке,
             поскольку они всегда могут установить свои собственные серверы пересылки.
</p>
</dd>
<dt>AllowGroups <a name="man_005fssh_005fsshd_005fconfig-AllowGroups"></a></dt>
<dd><p>За этим ключевым словом может следовать список шаблонов имен групп,
             разделенных пробелами. Если указано, вход в систему разрешен только для
             пользователей, чья основная группа или список дополнительных групп
             соответствует одному из шаблонов. Допустимы только имена групп; числовой
             идентификатор группы не распознается. По умолчанию вход разрешен для всех
             групп. Директивы allow/deny обрабатываются в следующем порядке: DenyUsers,
             AllowUsers, DenyGroups и, наконец, AllowGroups.
</p>
<p>Смотрите PATTERNS в ssh_config(5) для получения дополнительной информации
             о шаблонах.
</p>
</dd>
<dt>AllowTcpForwarding <a name="man_005fssh_005fsshd_005fconfig-AllowTcpForwarding"></a></dt>
<dd><p>Указывает, разрешена ли пересылка TCP. Доступные опции: “yes” или “all”,
             чтобы разрешить пересылку TCP, “no”, чтобы предотвратить все пересылки TCP,
             “local”, чтобы разрешить только локальную (с точки зрения ssh(1)) пересылку,
             или “remote”, чтобы разрешить только удаленную пересылку. По умолчанию
             используется “yes”. Обратите внимание, что отключение пересылки TCP не
             повышает безопасность, если пользователям также не запрещен доступ к
             оболочке, поскольку они всегда могут установить свои собственные серверы
             пересылки.
</p>
</dd>
<dt>AllowStreamLocalForwarding <a name="man_005fssh_005fsshd_005fconfig-AllowStreamLocalForwarding"></a></dt>
<dd><p>Указывает, разрешена ли пересылка StreamLocal (сокет Unix-домена). Доступные
             опции: “yes” или “all”, чтобы разрешить пересылку StreamLocal, “no”, чтобы
             запретить всю пересылку StreamLocal, “local”, чтобы разрешить только
             локальную (с точки зрения ssh(1)) пересылку, или “remote”, чтобы разрешить
             только удаленную пересылку. По умолчанию используется “yes”. Обратите
             внимание, что отключение пересылки StreamLocal не повышает безопасность, если
             пользователям также не запрещен доступ к оболочке, поскольку они всегда могут
             установить свои собственные серверы пересылки.
</p>
</dd>
<dt>AllowUsers <a name="man_005fssh_005fsshd_005fconfig-AllowUsers"></a></dt>
<dd><p>За этим ключевым словом может следовать список шаблонов имен пользователей,
             разделенных пробелами. Если указано, вход в систему разрешен только для имен
             пользователей, которые соответствуют одному из шаблонов. Допустимы только
             имена пользователей; числовой пользователь ID не распознается. По умолчанию
             вход разрешен для всех пользователей. Если шаблон принимает форму USER@HOST,
             то USER и HOST проверяются отдельно, ограничивая вход в систему определенным
             пользователям с определенных хостов. Директивы allow / deny обрабатываются в
             следующем порядке: DenyUsers, AllowUsers, DenyGroups и, наконец, AllowGroups.
</p>
<p>Смотрите PATTERNS в ssh_config (5) для получения дополнительной информации
             о шаблонах.
</p>
</dd>
<dt>AuthenticationMethods <a name="man_005fssh_005fsshd_005fconfig-AuthenticationMethods"></a></dt>
<dd><p>Определяет методы аутентификации, которые должны быть успешно завершены,
             чтобы пользователю был предоставлен доступ. За этой опцией должен следовать
             один или несколько разделенных запятыми списков имен методов аутентификации.
             Успешная аутентификация требует завершения каждого метода хотя бы в одном из
             этих списков.
</p>
<p>Например, аргумент “publickey,password publickey,keyboard-interactive”
             потребует от пользователя завершить аутентификацию с открытым ключом, а
             затем интерактивную аутентификацию с помощью пароля или клавиатуры. На
             каждом этапе предлагаются только методы, которые являются следующими в одном
             или нескольких списках, поэтому для этого примера было бы невозможно
             попытаться выполнить аутентификацию с помощью пароля или интерактивной
             клавиатуры перед открытым ключом.
</p>
<p>Для интерактивной аутентификации с помощью клавиатуры также можно ограничить
             аутентификацию для конкретного устройства, добавив двоеточие, за которым
             следует идентификатор устройства “bsdauth”, “pam”, или “skey”, в зависимости
             от конфигурации сервера. Например, “keyboard-interactive:bsdauth” ограничивает
             интерактивную аутентификацию клавиатуры устройством “bsdauth”.
</p>
<p>Если метод “publickey” указан в списке более одного раза, sshd(8) проверяет,
             что ключи, которые были успешно использованы, не используются повторно для
             последующей аутентификации. Например, для AuthenticationMethods из
             “publickey,publickey” потребуется успешная аутентификация с использованием
             двух разных открытых ключей.
</p>
<p>Эта опция приведет к фатальной ошибке, если она включена, если протокол 1
             также включен. Обратите внимание, что каждый из перечисленных методов
             аутентификации должен быть явно включен в конфигурации. По умолчанию не
             требуется множественная аутентификация; успешного завершения одного метода
             аутентификации достаточно.
</p>
</dd>
<dt>AuthorizedKeysCommand <a name="man_005fssh_005fsshd_005fconfig-AuthorizedKeysCommand"></a></dt>
<dd><p>Определяет программу, которая будет использоваться для поиска открытых
             ключей пользователя. Программа должна принадлежать пользователю root, не
             записываться группой или другими пользователями и указываться
             абсолютным путем.
</p>
<p>Аргументы AuthorizedKeysCommand могут быть предоставлены с использованием
             следующих токенов, которые будут развернуты во время выполнения:
</p><div class="display">
<pre class="display">             %% заменяется литералом &rsquo;%&rsquo;,
             %u, заменяется аутентифицируемым именем пользователя,
             %h заменяется домашним каталогом аутентифицируемого пользователя. ,
             %t заменяется типом ключа, предлагаемым для аутентификации,
             %f заменяется отпечатком ключа, а
             %k заменяется ключом, предлагаемым для аутентификации.
</pre></div>
<p>Если аргументы не указаны, то будет указано имя пользователя целевого
             пользователя.
</p>
<p>Программа должна выдавать на стандартном выходе ноль или более строк
             авторизованного вывода (AUTHORIZED_KEYS в sshd (8)). Если ключ,
             предоставленный AuthorizedKeysCommand, не проходит аутентификацию и
             авторизацию пользователя, аутентификация открытого ключа продолжается с
             использованием обычных файлов AuthorizedKeysFile. По умолчанию
             AuthorizedKeysCommand не запускается.
</p>
</dd>
<dt>AuthorizedKeysCommandUser <a name="man_005fssh_005fsshd_005fconfig-AuthorizedKeysCommandUser"></a></dt>
<dd><p>Указывает пользователя, под учетной записью которого запускается
             AuthorizedKeysCommand. Рекомендуется использовать выделенного пользователя,
             который не имеет никакой другой роли на хосте, кроме запуска команд
             авторизованных ключей. Если указан AuthorizedKeysCommand, а
             AuthorizedKeysCommandUser нет, то sshd(8) откажется запускаться.
</p>
</dd>
<dt>AuthorizedKeysFile <a name="man_005fssh_005fsshd_005fconfig-AuthorizedKeysFile"></a></dt>
<dd><p>Указывает файл, который содержит открытые ключи, которые можно использовать
             для аутентификации пользователя. Формат описан в разделе
             AUTHORIZED_KEYS FILE FORMAT в sshd (8). AuthorizedKeysFile может содержать
             токены вида %T, которые подставляются во время установки соединения.
             Определены следующие токены:
</p><div class="display">
<pre class="display">             %% заменяется литералом &rsquo;%&rsquo;,
             %h заменяется домашним каталогом аутентифицируемого пользователя, а
             %u заменяется именем пользователя этого пользователя.
</pre></div>
<p>После расширения AuthorizedKeysFile считается абсолютным или относительным
             путем к домашнему каталогу пользователя. Несколько файлов могут быть
             перечислены, разделенные пробелом. В качестве альтернативы этот параметр
             может быть установлен в “none”, чтобы пропустить проверку пользовательских
             ключей в файлах. По умолчанию используется
             “.ssh/authorized_keys .ssh/authorized_keys2”.
</p>
</dd>
<dt>AuthorizedPrincipalsCommand <a name="man_005fssh_005fsshd_005fconfig-AuthorizedPrincipalsCommand"></a></dt>
<dd><p>Определяет программу, которая будет использоваться для генерации списка
             разрешенных участников сертификата согласно AuthorizedPrincipalsFile.
             Программа должна принадлежать пользователю root, недоступна для записи
             группе или другим пользователям и указываться абсолютным путем.
</p>
<p>Аргументы AuthorizedPrincipalsCommand могут быть предоставлены с
             использованием следующих токенов, которые будут раскрыты во время
             выполнения:
</p><div class="display">
<pre class="display">             %% заменяется литералом &rsquo;%&rsquo;,
             %u заменяется аутентифицируемым именем пользователя, а
             %h заменяется домашним каталогом аутентифицируемого пользователя.
</pre></div>
<p>Программа должна выдавать на стандартном выходе ноль или более строк вывода
             AuthorizedPrincipalsFile. Если указан либо AuthorizedPrincipalsCommand или
             AuthorizedPrincipalsFile, то сертификаты, предлагаемые клиентом для
             аутентификации, должны содержать принципала, который указан в списке. По
             умолчанию AuthorizedPrincipalsCommand не запускается.
</p>
</dd>
<dt>AuthorizedPrincipalsCommandUser <a name="man_005fssh_005fsshd_005fconfig-AuthorizedPrincipalsCommandUser"></a></dt>
<dd><p>Указывает пользователя, под учетной записью которого запускается
             AuthorizedPrincipalsCommand. Рекомендуется использовать выделенного
             пользователя, который не имеет никакой другой роли на хосте, кроме запуска
             авторизованных команд принцесс. Если указан AuthorizedPrincipalsCommand,
             а AuthorizedPrincipalsCommandUser нет, то sshd(8) откажется запускаться.
</p>
</dd>
<dt>AuthorizedPrincipalsFile <a name="man_005fssh_005fsshd_005fconfig-AuthorizedPrincipalsFile"></a></dt>
<dd><p>Указывает файл, в котором перечислены имена участников, которые принимаются
             для проверки подлинности сертификата. При использовании сертификатов,
             подписанных ключом, указанным в TrustedUserCAKeys, в этом файле перечислены
             имена, одно из которых должно присутствовать в сертификате, чтобы его можно
             было принять для аутентификации. Имена перечислены по одному в строке, перед
             которыми стоят ключевые параметры (как описано в AUTHORIZED_KEYS FILE FORMAT
             в sshd (8)). Пустые строки и комментарии, начинающиеся с ‘#’, игнорируются.
</p>
<p>AuthorizedPrincipalsFile может содержать токены вида %T, которые
             подставляются во время установки соединения. Определены следующие токены:
</p><div class="display">
<pre class="display">             %% заменяется литералом &rsquo;%&rsquo;,
             %h заменяется домашним каталогом аутентифицируемого пользователя, а
             %u заменяется именем пользователя этого пользователя.
</pre></div>
<p>После расширения AuthorizedPrincipalsFile считается абсолютным или
             относительным путем к домашнему каталогу пользователя.
</p>
<p>По умолчанию используется “none”, то есть не использовать файл принципалов -
             в этом случае имя пользователя должно появиться в списке принципалов
             сертификата, чтобы его можно было принять. Обратите внимание, что
             AuthorizedPrincipalsFile используется только в том случае, если
             аутентификация выполняется с использованием CA, указанного в
             TrustedUserCAKeys, и не используется для сертификационных центров,
             которым доверяют через ~/.ssh/authorized_keys, хотя опция principals= key
             предлагает аналогичное средство (подробнее см. Sshd(8)).
</p>
</dd>
<dt>Banner <a name="man_005fssh_005fsshd_005fconfig-Banner"></a></dt>
<dd><p>Содержимое указанного файла отправляется удаленному пользователю до разрешения
             аутентификации. Если аргумент - “none”, тогда баннер не отображается. По
             умолчанию баннер не отображается.
</p>
</dd>
<dt>ChallengeResponseAuthentication <a name="man_005fssh_005fsshd_005fconfig-ChallengeResponseAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли аутентификация по запросу-ответу (например,
             через PAM). По умолчанию используется “yes”.
</p>
</dd>
<dt>ChrootDirectory <a name="man_005fssh_005fsshd_005fconfig-ChrootDirectory"></a></dt>
<dd><p>Указывает путь к каталогу, к которому chroot(2) следует после аутентификации.
             При запуске сеанса sshd(8) проверяет, что все компоненты пути являются
             корневыми каталогами, которые не доступны для записи любому другому
             пользователю или группе. После chroot, sshd(8) меняет рабочий каталог
             на домашний каталог пользователя.
</p>
<p>Путь может содержать следующие токены, которые раскрываются во время
             выполнения после аутентификации подключающегося пользователя:
</p><div class="display">
<pre class="display">             %% заменяется литералом &rsquo;%&rsquo;,
             %h заменяется домашним каталогом аутентифицируемого пользователя, а
             %u заменяется именем пользователя этого пользователя.
</pre></div>
<p>ChrootDirectory должен содержать необходимые файлы и директории для
             поддержки сеанса пользователя. Для интерактивного сеанса это требует,
             по крайней мере, оболочки, обычно sh(1), и базовых узлов /dev, таких
             как null(4), zero(4), stdin(4), stdout(4), stderr(4) и устройства
             tty(4). Для сеансов передачи файлов с использованием “sftp” дополнительная
             настройка среды не требуется, если используется внутрипроцессный сервер
             sftp, хотя для сеансов, которые используют ведение журнала, может
             потребоваться /dev/log внутри каталога chroot в некоторых операционных
             системах (подробности см. В sftp-server(8)).
</p>
<p>В целях безопасности очень важно предотвратить изменение иерархии каталогов
             другими процессами в системе (особенно теми, которые находятся за пределами
             тюрьмы). Неверная конфигурация может привести к небезопасной среде, которую
             sshd(8) не может обнаружить.
</p>
<p>По умолчанию установлено значение “none”, что указывает на отсутствие
             chroot(2).
</p>
</dd>
<dt>Ciphers <a name="man_005fssh_005fsshd_005fconfig-Ciphers"></a></dt>
<dd><p>Определяет разрешенные шифры. Несколько шифров должны быть разделены запятыми.
             Если указанное значение начинается с символа ‘+’, то указанные шифры будут
             добавлены в набор по умолчанию вместо их замены.
</p>
<p>Поддерживаемые шифры:
</p><div class="display">
<pre class="display">                   3des-cbc
                   aes128-cbc
                   aes192-cbc
                   aes256-cbc
                   aes128-ctr
                   aes192-ctr
                   aes256-ctr
                   aes128-gcm@openssh.com
                   aes256-gcm@openssh.com
                   arcfour
                   arcfour128
                   arcfour256
                   blowfish-cbc
                   cast128-cbc
                   chacha20-poly1305@openssh.com
</pre></div>
<p>The default is:
</p><div class="display">
<pre class="display">                   chacha20-poly1305@openssh.com,
                   aes128-ctr,aes192-ctr,aes256-ctr,
                   aes128-gcm@openssh.com,aes256-gcm@openssh.com
</pre></div>
<p>Список доступных шифров также можно получить с помощью опции -Q ssh(1)
             с аргументом “cipher”.
</p>
</dd>
<dt>ClientAliveCountMax <a name="man_005fssh_005fsshd_005fconfig-ClientAliveCountMax"></a></dt>
<dd><p>Устанавливает количество живых сообщений клиента (см. Ниже), которые могут
             быть отправлены без sshd(8) получения каких-либо сообщений от клиента. Если
             этот порог достигнут, пока клиент отправляет живые сообщения, sshd отключит
             клиента, завершив сеанс. Важно отметить, что использование клиентских живых
             сообщений очень отличается от TCPKeepAlive (ниже). Живые сообщения клиента
             отправляются через зашифрованный канал, и поэтому они не будут подделаны.
             Опция keepalive TCP, включенная TCPKeepAlive, подделана. Механизм «живой»
             клиент ценится, когда клиент или сервер зависят от того, когда соединение
             стало неактивным.
</p>
<p>Значение по умолчанию - 3. Если для ClientAliveInterval (см. Ниже)
             установлено значение 15, а для ClientAliveCountMax оставлено значение
             по умолчанию, не отвечающие требованиям клиенты SSH будут отключены примерно
             через 45 секунд.
</p>
</dd>
<dt>ClientAliveInterval <a name="man_005fssh_005fsshd_005fconfig-ClientAliveInterval"></a></dt>
<dd><p>Устанавливает интервал ожидания в секундах, после чего, если от клиента не
             было получено никаких данных, sshd(8) отправляет сообщение через зашифрованный
             канал для запроса ответа от клиента. По умолчанию используется 0, что 
             означает, что эти сообщения не будут отправлены клиенту.
</p>
</dd>
<dt>Compression <a name="man_005fssh_005fsshd_005fconfig-Compression"></a></dt>
<dd><p>Указывает, включено ли сжатие после успешной аутентификации пользователя.
             Аргумент должен быть “yes”, “delayed” (устаревший синоним “yes”) или “no”.
             По умолчанию используется “yes”.
</p>
</dd>
<dt>DebianBanner <a name="man_005fssh_005fsshd_005fconfig-DebianBanner"></a></dt>
<dd><p>Указывает, включен ли дополнительный суффикс указанной версии при
             первоначальном согласовании протокола. По умолчанию используется “yes”.
</p>
</dd>
<dt>DenyGroups <a name="man_005fssh_005fsshd_005fconfig-DenyGroups"></a></dt>
<dd><p>За этим ключевым словом может следовать список шаблонов имен групп,
             разделенных пробелами. Вход запрещен для пользователей, чья основная группа
             или список дополнительных групп соответствует одному из шаблонов. Допустимы
             только имена групп; числовой идентификатор группы не распознается. По
             умолчанию вход разрешен для всех групп. Директивы
             allow/deny (разрешать/запрещать) обрабатываются в следующем порядке:
             DenyUsers, AllowUsers, DenyGroups, и в итоге AllowGroups.
</p>
<p>Смотрите PATTERNS в ssh_config(5) для получения дополнительной
             информации о шаблонах.
</p>
</dd>
<dt>DenyUsers <a name="man_005fssh_005fsshd_005fconfig-DenyUsers"></a></dt>
<dd><p>За этим ключевым словом может следовать список шаблонов имен пользователей,
             разделенных пробелами. Вход запрещен для имен пользователей, которые
             соответствуют одному из шаблонов. Допустимы только имена пользователей;
             числовой пользователь ID не распознается. По умолчанию вход разрешен для
             всех пользователей. Если шаблон принимает форму USER @ HOST, то USER и
             HOST проверяются отдельно, ограничивая вход в систему определенным
             пользователям с определенных хостов. Директивы allow/deny
             (разрешать/запрещать) обрабатываются в следующем порядке:
             DenyUsers, AllowUsers, DenyGroups, и в итоге AllowGroups.
</p>
<p>Смотрите PATTERNS в ssh_config(5) для получения дополнительной
             информации о шаблонах.
</p>
</dd>
<dt>FingerprintHash <a name="man_005fssh_005fsshd_005fconfig-FingerprintHash"></a></dt>
<dd><p>Определяет алгоритм хеширования, используемый при регистрации отпечатков
             кллючей. Допустимые параметры: “md5” и “sha256”. По умолчанию
             используется “sha256”.
</p>
</dd>
<dt>ForceCommand <a name="man_005fssh_005fsshd_005fconfig-ForceCommand"></a></dt>
<dd><p>Принудительно выполняет команду, указанную ForceCommand, игнорируя
             любую команду, предоставленную клиентом, и ~/.ssh/rc, если присутствует.
             Команда вызывается с использованием оболочки входа пользователя с
             опцией -c. Это относится к выполнению оболочки, команды или подсистемы.
             Это наиболее полезно внутри блока Match. Команда, изначально
             предоставленная клиентом, доступна в переменной окружения
             SSH_ORIGINAL_COMMAND. Указание команды “internal-sftp” приведет к
             использованию внутрипроцессного сервера sftp, который не требует
             файлов поддержки при использовании с ChrootDirectory. По умолчанию
             используется “none”.
</p>
</dd>
<dt>GatewayPorts <a name="man_005fssh_005fsshd_005fconfig-GatewayPorts"></a></dt>
<dd><p>Указывает, разрешено ли удаленным узлам подключаться к портам,
             перенаправленным для клиента. По умолчанию sshd(8) связывает переадресацию
             удаленных портов с адресом обратной связи. Это предотвращает подключение
             других удаленных хостов к перенаправленным портам. GatewayPorts может
             использоваться для указания того, что sshd должен позволять перенаправлениям
             удаленных портов связываться с адресами без обратной связи, что позволяет
             другим хостам соединяться. Аргументом может быть “no”, чтобы принудительно
             сделать переадресацию удаленных портов доступным только для локального хоста,
             “yes” для принудительной переадресации удаленных портов для привязки к
             подстановочному адресу или “clientspecified”, чтобы позволить клиенту
             выбрать адрес, с которым связана переадресация. По умолчанию
             используется “no”.
</p>
</dd>
<dt>GSSAPIAuthentication <a name="man_005fssh_005fsshd_005fconfig-GSSAPIAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли аутентификация пользователя на основе GSSAPI.
             По умолчанию используется “no”.
</p>
</dd>
<dt>GSSAPIKeyExchange <a name="man_005fssh_005fsshd_005fconfig-GSSAPIKeyExchange"></a></dt>
<dd><p>Указывает, разрешен ли обмен ключами на основе GSSAPI. Обмен ключами
             GSSAPI не использует ключи ssh для проверки личности хоста. По умолчанию
             используется “no”.
</p>
</dd>
<dt>GSSAPICleanupCredentials <a name="man_005fssh_005fsshd_005fconfig-GSSAPICleanupCredentials"></a></dt>
<dd><p>Указывает, следует ли автоматически уничтожать кэш учетных данных
             пользователя при выходе из системы. По умолчанию используется “yes”.
</p>
</dd>
<dt>GSSAPIStrictAcceptorCheck <a name="man_005fssh_005fsshd_005fconfig-GSSAPIStrictAcceptorCheck"></a></dt>
<dd><p>Определяет, строго ли относиться к идентификатору акцептора GSSAPI, с
             которым аутентифицируется клиент. Если установлено значение “yes”, то
             клиент должен аутентифицироваться на службе хоста на текущем имени хоста.
             Если установлено значение “no”, тогда клиент может аутентифицироваться по
             любому служебному ключу, хранящемуся в хранилище по умолчанию на машине.
             Это средство предназначено для помощи в работе на многодомных машинах. По
             умолчанию используется “yes”.
</p>
</dd>
<dt>GSSAPIStoreCredentialsOnRekey <a name="man_005fssh_005fsshd_005fconfig-GSSAPIStoreCredentialsOnRekey"></a></dt>
<dd><p>Управляет обновлением учетных данных пользователя GSSAPI после успешного
             повторного подключения. Этот параметр можно использовать для принятия
             обновленных или обновленных учетных данных от совместимого клиента. По
             умолчанию используется “no”.
</p>
</dd>
<dt>HostbasedAcceptedKeyTypes <a name="man_005fssh_005fsshd_005fconfig-HostbasedAcceptedKeyTypes"></a></dt>
<dd><p>Задает типы ключей, которые будут приниматься для аутентификации на
             основе хоста в виде списка шаблонов, разделенных запятыми. С другой стороны,
             если указанное значение начинается с символа ‘+’, то указанные типы ключей
             будут добавляться к набору по умолчанию вместо их замены. По умолчанию для
             этой опции:
</p><div class="display">
<pre class="display">                ecdsa-sha2-nistp256-cert-v01@openssh.com,
                ecdsa-sha2-nistp384-cert-v01@openssh.com,
                ecdsa-sha2-nistp521-cert-v01@openssh.com,
                ssh-ed25519-cert-v01@openssh.com,
                ssh-rsa-cert-v01@openssh.com,
                ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,
                ssh-ed25519,ssh-rsa
</pre></div>
<p>Опция -Q в ssh(1) может использоваться для отображения поддерживаемых
             типов ключей.
</p>
</dd>
<dt>HostbasedAuthentication <a name="man_005fssh_005fsshd_005fconfig-HostbasedAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли аутентификация rhosts или /etc/hosts.equiv вместе
             с успешной аутентификацией хоста клиента с открытым ключом (аутентификация
             на основе хоста). По умолчанию используется “no”.
</p>
</dd>
<dt>HostbasedUsesNameFromPacketOnly <a name="man_005fssh_005fsshd_005fconfig-HostbasedUsesNameFromPacketOnly"></a></dt>
<dd><p>Указывает, будет ли сервер пытаться выполнить обратный поиск имени при
             сопоставлении имени в файлах ~/.shosts, ~/.rhosts, и /etc/hosts.equiv во
             время HostbasedAuthentication. Параметр “yes” означает, что sshd(8) использует
             имя, предоставленное клиентом, а не пытается разрешить имя из самого
             соединения TCP. По умолчанию используется “no”.
</p>
</dd>
<dt>HostCertificate <a name="man_005fssh_005fsshd_005fconfig-HostCertificate"></a></dt>
<dd><p>Указывает файл, содержащий сертификат общедоступного хоста. Открытый ключ
             сертификата должен соответствовать закрытому ключу хоста, уже указанному в
             HostKey. Поведение sshd(8) по умолчанию - не загружать сертификаты.
</p>
</dd>
<dt>HostKey <a name="man_005fssh_005fsshd_005fconfig-HostKey"></a></dt>
<dd><p>Указывает файл, содержащий закрытый ключ хоста, используемый SSH. По
             умолчанию используется /etc/ssh/ssh_host_key для версии протокола 1 и
             /etc/ssh/ssh_host_dsa_key, /etc/ssh/ssh_host_ecdsa_key,
             /etc/ssh/ssh_host_ed25519_key и /etc/ssh/ssh_host_rsa_key для
             версии протокола 2.
</p>
<p>Обратите внимание, что sshd(8) откажется использовать файл, если он
             является group/world-accessible (группа / всем доступным), и что опция
             HostKeyAlgorithms ограничивает, какой из ключей фактически
             используется sshd(8).
</p>
<p>Можно иметь несколько файлов ключей хоста. Ключи “rsa1” используются для
             версии 1, а “dsa”, “ecdsa”, “ed25519” или “rsa” - для версии 2
             протокола SSH. Вместо этого также можно указать файлы открытых ключей
             хоста. В этом случае операции с закрытым ключом будут
             делегированы ssh-agent(1).
</p>
</dd>
<dt>HostKeyAgent <a name="man_005fssh_005fsshd_005fconfig-HostKeyAgent"></a></dt>
<dd><p>Определяет сокет домена UNIX, используемый для связи с агентом, который
             имеет доступ к закрытым ключам хоста. Если указан “SSH_AUTH_SOCK”,
             местоположение сокета будет считываться из переменной среды SSH_AUTH_SOCK.
</p>
</dd>
<dt>HostKeyAlgorithms <a name="man_005fssh_005fsshd_005fconfig-HostKeyAlgorithms"></a></dt>
<dd><p>Определяет алгоритмы ключей хоста, которые предлагает сервер. По
             умолчанию для этой опции:
</p><div class="display">
<pre class="display">                ecdsa-sha2-nistp256-cert-v01@openssh.com,
                ecdsa-sha2-nistp384-cert-v01@openssh.com,
                ecdsa-sha2-nistp521-cert-v01@openssh.com,
                ssh-ed25519-cert-v01@openssh.com,
                ssh-rsa-cert-v01@openssh.com,
                ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,
                ssh-ed25519,ssh-rsa
</pre></div>
<p>Список доступных типов ключей также можно получить с помощью опции
             ssh(1) -Q с аргументом “key”.
</p>
</dd>
<dt>IgnoreRhosts <a name="man_005fssh_005fsshd_005fconfig-IgnoreRhosts"></a></dt>
<dd><p>Указывает, что файлы .rhosts и .shosts не будут использоваться в
             RhostsRSAAuthentication или HostbasedAuthentication.
</p>
<p>/etc/hosts.equiv и /etc/ssh/shosts.equiv все еще используются.
             По умолчанию “yes”.
</p>
</dd>
<dt>IgnoreUserKnownHosts <a name="man_005fssh_005fsshd_005fconfig-IgnoreUserKnownHosts"></a></dt>
<dd><p>Указывает, должен ли sshd(8) игнорировать пользовательский
             ~/.ssh/known_hosts во время RhostsRSAAuthentication или
             HostbasedAuthentication. По умолчанию используется “no”.
</p>
</dd>
<dt>IPQoS <a name="man_005fssh_005fsshd_005fconfig-IPQoS"></a></dt>
<dd><p>Определяет тип сервиса IPv4 или класс DSCP для соединения. Допустимые
             значения: “af11”, “af12”, “af13”, “af21”, “af22”, “af23”, “af31”,
             “af32”, “af33”, “af41”, “af42”, “af43”, “cs0”, “cs1”, “cs2”, “cs3”,
             “cs4”, “cs5”, “cs6”, “cs7”, “ef”, “lowdelay”, “throughput”,
             “reliability” или числовое значение. Эта опция может принимать один
             или два аргумента, разделенных пробелом. Если указан один аргумент,
             он безоговорочно используется в качестве класса пакета. Если указаны
             два значения, первое автоматически выбирается для интерактивных сеансов,
             а второе - для неинтерактивных сеансов. По умолчанию “lowdelay” для
             интерактивных сессий и “throughput” для неинтерактивных сессий.
</p>
</dd>
<dt>KbdInteractiveAuthentication <a name="man_005fssh_005fsshd_005fconfig-KbdInteractiveAuthentication"></a></dt>
<dd><p>Указывает, разрешить ли интерактивную аутентификацию с клавиатуры. Аргумент
             к этому ключевому слову должен быть “yes” или “no”. По умолчанию используется
             любое значение, установленное для ChallengeResponseAuthentication (по
             умолчанию “yes”)..
</p>
</dd>
<dt>KerberosAuthentication <a name="man_005fssh_005fsshd_005fconfig-KerberosAuthentication"></a></dt>
<dd><p>Указывает, будет ли пароль, предоставленный пользователем для
             PasswordAuthentication, проверяться через Kerberos KDC. Чтобы
             использовать эту опцию, серверу нужен сервабер Kerberos, который
             позволяет проверять идентичность KDC&rsquo;s. По умолчанию используется “no”.
</p>
</dd>
<dt>KerberosGetAFSToken <a name="man_005fssh_005fsshd_005fconfig-KerberosGetAFSToken"></a></dt>
<dd><p>Если AFS активен и у пользователя Kerberos 5 TGT, попытайтесь получить
             токен AFS перед доступом к домашнему каталогу пользователя. По умолчанию
             используется “no”.
</p>
</dd>
<dt>KerberosOrLocalPasswd <a name="man_005fssh_005fsshd_005fconfig-KerberosOrLocalPasswd"></a></dt>
<dd><p>Если аутентификация по паролю через Kerberos не удалась, пароль будет
             проверен с помощью любого дополнительного локального механизма, такого
             как /etc/passwd. По умолчанию используется “yes”.
</p>
</dd>
<dt>KerberosTicketCleanup <a name="man_005fssh_005fsshd_005fconfig-KerberosTicketCleanup"></a></dt>
<dd><p>Указывает, нужно ли автоматически уничтожать файл кэша билетов
             пользователя при выходе из системы. По умолчанию используется “yes”.
</p>
</dd>
<dt>KexAlgorithms <a name="man_005fssh_005fsshd_005fconfig-KexAlgorithms"></a></dt>
<dd><p>Определяет доступные алгоритмы KEX (Key Exchange(Обмен ключами)). Несколько
             алгоритмов должны быть разделены запятыми. С другой стороны, если
             указанное значение начинается с символа ‘+’, то указанные методы будут
             добавлены к набору по умолчанию вместо их замены. Поддерживаемые алгоритмы:
</p><div class="display">
<pre class="display">                   curve25519-sha256@libssh.org
                   diffie-hellman-group1-sha1
                   diffie-hellman-group14-sha1
                   diffie-hellman-group-exchange-sha1
                   diffie-hellman-group-exchange-sha256
                   ecdh-sha2-nistp256
                   ecdh-sha2-nistp384
                   ecdh-sha2-nistp521
</pre></div>
<p>По умолчанию:
</p><div class="display">
<pre class="display">                   curve25519-sha256@libssh.org,
                   ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,
                   diffie-hellman-group-exchange-sha256,
                   diffie-hellman-group14-sha1
</pre></div>
<p>Список доступных алгоритмов обмена ключами также можно получить, используя
             опцию -Q ssh(1) с аргументом “kex”.
</p>
</dd>
<dt>KeyRegenerationInterval <a name="man_005fssh_005fsshd_005fconfig-KeyRegenerationInterval"></a></dt>
<dd><p>В протоколе версии 1 эфемерный серверный ключ автоматически восстанавливается
             через столько секунд (если он использовался). Целью регенерации является
             предотвращение дешифрования захваченных сессий путем последующего взлома
             машины и кражи ключей. Ключ никогда нигде не хранится. Если значение
             равно 0, ключ никогда не восстанавливается. По умолчанию 3600 (секунд).
</p>
</dd>
<dt>ListenAddress <a name="man_005fssh_005fsshd_005fconfig-ListenAddress"></a></dt>
<dd><p>Определяет локальные адреса, которые должен прослушивать sshd(8). Можно
             использовать следующие формы:
</p><div class="display">
<pre class="display">                   ListenAddress host|IPv4_addr|IPv6_addr
                   ListenAddress host|IPv4_addr:port
                   ListenAddress [host|IPv6_addr]:port
</pre></div>
<p>Если порт не указан, sshd будет прослушивать адрес и все указанные
             параметры порта. По умолчанию прослушиваются все локальные адреса.
             Допускается несколько опций ListenAddress.
</p>
</dd>
<dt>LoginGraceTime <a name="man_005fssh_005fsshd_005fconfig-LoginGraceTime"></a></dt>
<dd><p>Сервер отключается после этого времени, если пользователь не вошел в
             систему. Если значение равно 0, ограничения по времени нет. Значение по
             умолчанию составляет 120 секунд.
</p>
</dd>
<dt>LogLevel <a name="man_005fssh_005fsshd_005fconfig-LogLevel"></a></dt>
<dd><p>Дает уровень многословия, который используется при регистрации сообщений
             от sshd(8). Возможные значения: QUIET, FATAL, ERROR, INFO, VERBOSE,
             DEBUG, DEBUG1, DEBUG2, и DEBUG3. По умолчанию используется INFO. DEBUG
             и DEBUG1 эквивалентны. Последующие DEBUG2 и DEBUG3 указывает более высокий
             уровень вывода отладочной информации. Регистрация с уровнем DEBUG нарушает
             конфиденциальность пользователей и не рекомендуется.
</p>
</dd>
<dt>MACs <a name="man_005fssh_005fsshd_005fconfig-MACs"></a></dt>
<dd><p>Определяет доступные алгоритмы MAC (код аутентификации сообщения). Алгоритм
             MAC используется для защиты целостности данных. Несколько алгоритмов должны
             быть разделены запятыми. Если указанное значение начинается с символа ‘+’,
             то указанные алгоритмы будут добавлены в набор по умолчанию вместо их замены.
</p>
<p>Алгоритмы, содержащие “-etm”, вычисляют MAC после шифрования
             (encrypt-then-mac). Они считаются более безопасными, и их использование
             рекомендуется. Поддерживаемые MACs:
</p><div class="display">
<pre class="display">                   hmac-md5
                   hmac-md5-96
                   hmac-ripemd160
                   hmac-sha1
                   hmac-sha1-96
                   hmac-sha2-256
                   hmac-sha2-512
                   umac-64@openssh.com
                   umac-128@openssh.com
                   hmac-md5-etm@openssh.com
                   hmac-md5-96-etm@openssh.com
                   hmac-ripemd160-etm@openssh.com
                   hmac-sha1-etm@openssh.com
                   hmac-sha1-96-etm@openssh.com
                   hmac-sha2-256-etm@openssh.com
                   hmac-sha2-512-etm@openssh.com
                   umac-64-etm@openssh.com
                   umac-128-etm@openssh.com
</pre></div>
<p>По умолчанию:
</p><div class="display">
<pre class="display">                   umac-64-etm@openssh.com,umac-128-etm@openssh.com,
                   hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,
                   hmac-sha1-etm@openssh.com,
                   umac-64@openssh.com,umac-128@openssh.com,
                   hmac-sha2-256,hmac-sha2-512,hmac-sha1
</pre></div>
<p>Список доступных алгоритмов MAC можно также получить с помощью
             опции -Q ssh(1) с аргументом “mac”.
</p>
</dd>
<dt>Match <a name="man_005fssh_005fsshd_005fconfig-Match"></a></dt>
<dd><p>Вводит условный блок. Если все критерии в строке Match удовлетворены,
             ключевые слова в следующих строках переопределяют те, которые установлены
             в глобальном разделе файла конфигурации, до следующей строки Match или
             конца файла. Если ключевое слово появляется в нескольких удовлетворенных
             блоках соответствия, применяется только первый экземпляр ключевого слова.
</p>
<p>Аргументами Match являются одна или несколько пар критериев-шаблонов
             или один токен All, который соответствует всем критериям. Доступные
             критерии: User, Group, Host, LocalAddress, LocalPort, и Address.
             Шаблоны соответствия могут состоять из отдельных записей или
             разделенных запятыми списков и могут использовать подстановочные
             знаки и операторы отрицания, описанные в разделе
             PATTERNS ssh_config(5).
</p>
<p>Шаблоны в критериях Address могут дополнительно содержать адреса для
             сопоставления в формате CIDR address/masklen (адрес/маска подсети),
             например, “192.0.2.0/24” или “3ffe:ffff::/32”. Обратите внимание,
             что предоставленная длина маски должна соответствовать адресу -
             ошибочно указывать длину маски, которая слишком велика для адреса или
             с битами, установленными в этой части хоста адреса. Например,
             “192.0.2.0/33” и “192.0.2.0/8” соответственно.
</p>
<p>В строках, следующих за ключевым словом Match, можно использовать
             только подмножество ключевых слов.  Доступные ключевые слова AcceptEnv,
             AllowAgentForwarding, AllowGroups, AllowStreamLocalForwarding,
             AllowTcpForwarding, AllowUsers, AuthenticationMethods,
             AuthorizedKeysCommand, AuthorizedKeysCommandUser,
             AuthorizedKeysFile, AuthorizedPrincipalsCommand,
             AuthorizedPrincipalsCommandUser, AuthorizedPrincipalsFile,
             Banner, ChrootDirectory, DenyGroups, DenyUsers, ForceCommand,
             GatewayPorts, GSSAPIAuthentication, HostbasedAcceptedKeyTypes,
             HostbasedAuthentication, HostbasedUsesNameFromPacketOnly, IPQoS,
             KbdInteractiveAuthentication, KerberosAuthentication,
             MaxAuthTries, MaxSessions, PasswordAuthentication,
             PermitEmptyPasswords, PermitOpen, PermitRootLogin, PermitTTY,
             PermitTunnel, PermitUserRC, PubkeyAcceptedKeyTypes,
             PubkeyAuthentication, RekeyLimit, RevokedKeys,
             RhostsRSAAuthentication, RSAAuthentication, StreamLocalBindMask,
             StreamLocalBindUnlink, TrustedUserCAKeys, X11DisplayOffset,
             X11Forwarding и X11UseLocalHost.
</p>
</dd>
<dt>MaxAuthTries <a name="man_005fssh_005fsshd_005fconfig-MaxAuthTries"></a></dt>
<dd><p>Задает максимальное количество попыток аутентификации, разрешенных для
             одного соединения. Когда число отказов достигает половины этого значения,
             регистрируются дополнительные сбои. По умолчанию 6.
</p>
</dd>
<dt>MaxSessions <a name="man_005fssh_005fsshd_005fconfig-MaxSessions"></a></dt>
<dd><p>Задает максимальное количество сеансов открытой оболочки, входа в систему
             или подсистемы (например, sftp), разрешенных для одного сетевого
             подключения. Несколько сеансов могут быть установлены клиентами, которые
             поддерживают мультиплексирование соединений. Установка MaxSessions в 1
             эффективно отключит мультиплексирование сеансов, в то время как установка
             в 0 предотвратит все сеансы оболочки, входа в систему и подсистемы, в то
             же время разрешая пересылку. По умолчанию 10.
</p>
</dd>
<dt>MaxStartups <a name="man_005fssh_005fsshd_005fconfig-MaxStartups"></a></dt>
<dd><p>Задает максимальное количество одновременных неаутентифицированных
             подключений к демону SSH. Дополнительные соединения будут сброшены до
             тех пор, пока аутентификация не пройдет успешно или не истечет срок
             действия LoginGraceTime для соединения. По умолчанию
             используется 10:30:100.
</p>
<p>Альтернативно, случайное раннее отбрасывание может быть включено путем
             указания трех разделенных двоеточиями значений “start:rate:full”
             (например, &quot;10:30:60&quot;). sshd(8) будет отказывать в попытках
             подключения с вероятностью “rate/100” (30%), если в настоящее время
             существуют “start” (10) неавторизованные подключения. Вероятность
             возрастает линейно, и все попытки подключения отклоняются, если число
             подключений без проверки подлинности достигает значения “full” (60).
</p>
</dd>
<dt>PasswordAuthentication <a name="man_005fssh_005fsshd_005fconfig-PasswordAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли аутентификация по паролю. По умолчанию
             используется “yes”.
</p>
</dd>
<dt>PermitEmptyPasswords <a name="man_005fssh_005fsshd_005fconfig-PermitEmptyPasswords"></a></dt>
<dd><p>Когда аутентификация по паролю разрешена, она указывает, разрешает ли
             сервер входить в учетные записи с пустыми строками пароля. По умолчанию
             используется “no”.
</p>
</dd>
<dt>PermitOpen <a name="man_005fssh_005fsshd_005fconfig-PermitOpen"></a></dt>
<dd><p>Определяет пункты назначения, для которых разрешена переадресация
             порта TCP. Спецификация пересылки должна быть одной из следующих форм:
</p><div class="display">
<pre class="display">                   PermitOpen host:port
                   PermitOpen IPv4_addr:port
                   PermitOpen [IPv6_addr]:port
</pre></div>
<p>Можно указать несколько форвардов, разделив их пробелами. Аргумент “any”
             может использоваться для снятия всех ограничений и разрешения любых запросов
             на пересылку. Аргумент “none” может использоваться для запрета всех запросов
             на пересылку. По умолчанию все запросы на переадресацию портов разрешены.
</p>
</dd>
<dt>PermitRootLogin <a name="man_005fssh_005fsshd_005fconfig-PermitRootLogin"></a></dt>
<dd><p>Указывает, может ли root войти в систему с помощью ssh(1). Аргумент должен
             быть “yes”, “prohibit-password”, “without-password”, “forced-commands-only”,
             или “no”. По умолчанию используется “prohibit-password”.
</p>
<p>Если для этого параметра установлено значение “prohibit-password” или
             “without-password”, пароль и клавиатурно-интерактивная аутентификация
             отключены для пользователя root.
</p>
<p>Если для этого параметра установлено значение “forced-commands-only”, будет
             разрешен вход в систему root с аутентификацией с открытым ключом, но только
             если была указана опция команды (что может быть полезно для создания
             удаленных резервных копий, даже если вход в систему root обычно не разрешен).
             Все остальные методы аутентификации отключены для root.
</p>
<p>Если для этого параметра установлено значение “no”, root не
             может войти в систему.
</p>
</dd>
<dt>PermitTunnel <a name="man_005fssh_005fsshd_005fconfig-PermitTunnel"></a></dt>
<dd><p>Указывает, разрешена ли пересылка устройства tun(4). Аргумент должен быть
             “yes”, “point-to-point” (layer 3), “ethernet” (уровень 2), или “no”.
             Указание “yes” разрешает оба “point-to-point” и “ethernet”. По умолчанию
             используется “no”.
</p>
<p>Независимо от этого параметра разрешения выбранного устройства tun(4)
             должны разрешать доступ пользователю.
</p>
</dd>
<dt>PermitTTY <a name="man_005fssh_005fsshd_005fconfig-PermitTTY"></a></dt>
<dd><p>Указывает, разрешено ли выделение pty(4). По умолчанию
             используется “yes”.
</p>
</dd>
<dt>PermitUserEnvironment <a name="man_005fssh_005fsshd_005fconfig-PermitUserEnvironment"></a></dt>
<dd><p>Определяет, обрабатываются ли опции ~/.ssh/environment и environment= в
             ~/.ssh/authorized_keys с помощью sshd(8). По умолчанию используется “no”.
             Включение обработки среды может позволить пользователям обойти ограничения
             доступа в некоторых конфигурациях, используя такие механизмы,
             как LD_PRELOAD.
</p>
</dd>
<dt>PermitUserRC <a name="man_005fssh_005fsshd_005fconfig-PermitUserRC"></a></dt>
<dd><p>Указывает, выполняется ли какой-либо файл ~/.ssh/rc. По умолчанию
             используется “yes”.
</p>
</dd>
<dt>PidFile <a name="man_005fssh_005fsshd_005fconfig-PidFile"></a></dt>
<dd><p>Указывает файл, содержащий процесс ID демона SSH, или “none”, чтобы
             не записывать его. По умолчанию используется /var/run/sshd.pid.
</p>
</dd>
<dt>Port <a name="man_005fssh_005fsshd_005fconfig-Port"></a></dt>
<dd><p>Specifies the port number that sshd(8) listens on.  The default
             is 22.  Multiple options of this type are permitted.  See also
             ListenAddress.
</p>
</dd>
<dt>PrintLastLog <a name="man_005fssh_005fsshd_005fconfig-PrintLastLog"></a></dt>
<dd><p>Указывает, должен ли sshd(8) печатать дату и время последнего входа
             пользователя, когда пользователь входит в систему в интерактивном режиме.
             По умолчанию используется “yes”.
</p>
</dd>
<dt>PrintMotd <a name="man_005fssh_005fsshd_005fconfig-PrintMotd"></a></dt>
<dd><p>Указывает, должен ли sshd(8) печатать /etc/motd, когда пользователь входит
             в систему в интерактивном режиме. (В некоторых системах он также печатается
             с помощью оболочки, /etc/profile или эквивалентной.) По умолчанию
             используется “yes”.
</p>
</dd>
<dt>Protocol <a name="man_005fssh_005fsshd_005fconfig-Protocol"></a></dt>
<dd><p>Определяет версии протокола, поддерживаемые sshd(8). Возможные
             значения: ‘1’ и ‘2’. Несколько версий должны быть разделены запятыми.
             По умолчанию используется ‘2’. Протокол 1 страдает от ряда
             криптографических недостатков и не должен использоваться. Предлагается
             только для поддержки устаревших устройств.
</p>
<p>Обратите внимание, что порядок списка протоколов не указывает на
             предпочтение, потому что клиент выбирает из нескольких вариантов
             протоколов, предлагаемых сервером. Указание “2,1” идентично “1,2”.
</p>
</dd>
<dt>PubkeyAcceptedKeyTypes <a name="man_005fssh_005fsshd_005fconfig-PubkeyAcceptedKeyTypes"></a></dt>
<dd><p>Задает типы ключей, которые будут приняты для аутентификации с открытым
             ключом в виде списка шаблонов, разделенных запятыми. С другой стороны,
             если указанное значение начинается с символа ‘+’, то указанные типы
             ключей будут добавляться к набору по умолчанию вместо их замены. По
             умолчанию для этой опции:
</p><div class="display">
<pre class="display">                ecdsa-sha2-nistp256-cert-v01@openssh.com,
                ecdsa-sha2-nistp384-cert-v01@openssh.com,
                ecdsa-sha2-nistp521-cert-v01@openssh.com,
                ssh-ed25519-cert-v01@openssh.com,
                ssh-rsa-cert-v01@openssh.com,
                ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,
                ssh-ed25519,ssh-rsa
</pre></div>
<p>Опция -Q в ssh(1) может использоваться для отображения
             поддерживаемых типов ключей.
</p>
</dd>
<dt>PubkeyAuthentication <a name="man_005fssh_005fsshd_005fconfig-PubkeyAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли аутентификация с открытым ключом. По умолчанию
             используется “yes”.
</p>
</dd>
<dt>RekeyLimit <a name="man_005fssh_005fsshd_005fconfig-RekeyLimit"></a></dt>
<dd><p>Задает максимальный объем данных, которые могут быть переданы до
             повторного согласования ключа сеанса, при желании может следовать
             максимальное количество времени, которое может пройти до повторного
             согласования ключа сеанса. Первый аргумент указывается в байтах и ​​может
             иметь суффикс ‘K’, ‘M’, или ‘G’ для обозначения Kilobytes, Megabytes,
             или Gigabytes соответственно. Значение по умолчанию находится между
             ‘1G’ и ‘4G’, в зависимости от шифра. Необязательное второе значение
             указывается в секундах и может использовать любые единицы измерения,
             описанные в разделе TIME FORMATS. Значением по умолчанию для RekeyLimit
             является “default none”, что означает, что повторный ввод выполняется
             после того, как объем данных шифра был отправлен или получен, и
             повторный ввод по времени не выполняется.
</p>
</dd>
<dt>RevokedKeys <a name="man_005fssh_005fsshd_005fconfig-RevokedKeys"></a></dt>
<dd><p>Указывает отозванный файл открытых ключей или “none”, чтобы не
             использовать его. Ключи, перечисленные в этом файле, будут отклонены
             для аутентификации с открытым ключом. Обратите внимание, что если этот
             файл недоступен для чтения, аутентификация с открытым ключом будет
             отклонена для всех пользователей. Ключи могут быть указаны в виде
             текстового файла с указанием одного открытого ключа в строке или в
             виде OpenSSH Key Revocation List(KRL), сгенерированного ssh-keygen(1).
             Для получения дополнительной информации об KRLs см. Раздел
             KEY REVOCATION LISTS в ssh-keygen(1).
</p>
</dd>
<dt>RhostsRSAAuthentication <a name="man_005fssh_005fsshd_005fconfig-RhostsRSAAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли аутентификация rhosts или /etc/hosts.equiv
             вместе с успешной аутентификацией хоста RSA. По умолчанию используется
             “no”. Эта опция применяется только к версии протокола 1.
</p>
</dd>
<dt>RSAAuthentication <a name="man_005fssh_005fsshd_005fconfig-RSAAuthentication"></a></dt>
<dd><p>Указывает, разрешена ли чистая аутентификация RSA. По умолчанию
             используется “yes”. Эта опция применяется только к версии протокола 1.
</p>
</dd>
<dt>ServerKeyBits <a name="man_005fssh_005fsshd_005fconfig-ServerKeyBits"></a></dt>
<dd><p>Определяет количество бит в ключе сервера эфемерного протокола версии 1.
             Минимальное значение по умолчанию - 1024.
</p>
</dd>
<dt>StreamLocalBindMask <a name="man_005fssh_005fsshd_005fconfig-StreamLocalBindMask"></a></dt>
<dd><p>Устанавливает восьмеричную маску режима создания файла (umask),
             используемую при создании файла сокета Unix-домена для локальной или
             удаленной переадресации портов. Эта опция используется только для
             переадресации портов в файл сокета Unix-домена.
</p>
<p>Значением по умолчанию является 0177, которое создает файл сокета
             Unix-домена, который доступен для чтения и записи только владельцу.
             Обратите внимание, что не все операционные системы поддерживают режим
             файлов в файлах сокетов Unix-домена.
</p>
</dd>
<dt>StreamLocalBindUnlink <a name="man_005fssh_005fsshd_005fconfig-StreamLocalBindUnlink"></a></dt>
<dd><p>Указывает, следует ли удалить существующий файл сокета Unix-домена для
             локальной или удаленной переадресации портов перед созданием нового. Если
             файл сокета уже существует и StreamLocalBindUnlink не включен, sshd не
             сможет перенаправить порт в файл сокета Unix-домена. Эта опция используется
             только для переадресации портов в файл сокета Unix-домена.
</p>
<p>Аргумент должен быть “yes” или “no”. По умолчанию используется “no”.
</p>
</dd>
<dt>StrictModes <a name="man_005fssh_005fsshd_005fconfig-StrictModes"></a></dt>
<dd><p>Определяет, должен ли sshd(8) проверять режимы файлов и владение файлами
             пользователя и домашним каталогом, прежде чем принимать вход в систему.
             Обычно это желательно, потому что новички иногда случайно покидают свои
             каталоги или файлы, доступные для записи. По умолчанию используется “yes”.
             Обратите внимание, что это не относится к ChrootDirectory, права и владение
             которого проверяются безоговорочно.
</p>
</dd>
<dt>Subsystem <a name="man_005fssh_005fsshd_005fconfig-Subsystem"></a></dt>
<dd><p>Настраивает внешнюю подсистему (например, демон передачи файлов). Аргументы
             должны быть именем подсистемы и командой (с необязательными аргументами)
             для выполнения по запросу подсистемы.
</p>
<p>Команда sftp-server(8) реализует подсистему передачи файлов “sftp”.
</p>
<p>Альтернативно имя “internal-sftp” реализует внутрипроцессный сервер
             “sftp”. Это может упростить конфигурации, использующие ChrootDirectory
             для принудительного создания корня другой файловой системы на клиентах.
</p>
<p>По умолчанию подсистемы не определены.
</p>
</dd>
<dt>SyslogFacility <a name="man_005fssh_005fsshd_005fconfig-SyslogFacility"></a></dt>
<dd><p>Предоставляет код объекта, который используется при регистрации сообщений
             от sshd(8). Возможные значения: DAEMON, USER, AUTH, LOCAL0, LOCAL1, LOCAL2,
             LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7. По умолчанию используется AUTH.
</p>
</dd>
<dt>TCPKeepAlive <a name="man_005fssh_005fsshd_005fconfig-TCPKeepAlive"></a></dt>
<dd><p>Указывает, должна ли система отправлять сообщения поддержки активности
             TCP другой стороне. Если они отправлены, смерть соединения или сбой
             одной из машин будут замечены должным образом. Однако это означает, что
             соединения прекратят свое существование, если маршрут временно не работает,
             и некоторые люди считают это раздражающим. С другой стороны, если сообщения
             поддержки активности TCP не отправляются, сеансы могут зависать на сервере
             неограниченное время, оставляя пользователей “ghost” и потребляя ресурсы
             сервера.
</p>
<p>По умолчанию используется “yes” (для отправки сообщений keepalive TCP), и
             сервер заметит, если сеть выйдет из строя или произойдет сбой хоста клиента.
             Это позволяет избежать бесконечно зависающих сессий.
</p>
<p>Чтобы отключить сообщения поддержки активности TCP, необходимо
             установить значение “no”.
</p>
<p>Этот вариант ранее назывался KeepAlive.
</p>
</dd>
<dt>TrustedUserCAKeys <a name="man_005fssh_005fsshd_005fconfig-TrustedUserCAKeys"></a></dt>
<dd><p>Определяет файл, содержащий открытые ключи полномочий сертификатов, которым
             доверяют подписывать пользовательские сертификаты для аутентификации, или
             “none”, чтобы не использовать их. Ключи указаны по одному в строке;
             допускаются пустые строки и комментарии, начинающиеся с ‘#’. Если сертификат
             представлен для аутентификации и его подписывающий ключ CA указан в этом
             файле, его можно использовать для аутентификации любого пользователя,
             указанного в списке участников сертификата. Обратите внимание, что
             сертификаты, в которых отсутствует список участников, не будут разрешены
             для аутентификации с использованием TrustedUserCAKeys. Для получения
             дополнительной информации о сертификатах см. Раздел CERTIFICATES в
             ssh-keygen(1).
</p>
</dd>
<dt>UseDNS <a name="man_005fssh_005fsshd_005fconfig-UseDNS"></a></dt>
<dd><p>Указывает, должен ли sshd(8) искать имя удаленного хоста и проверять,
             соответствует ли разрешенное имя хоста для адреса удаленного IP тому
             же адресу IP.
</p>
<p>Если для этого параметра установлено значение “no” (по умолчанию),
             то в директивах ~/.ssh/known_hosts from и sshd_config Match Host могут
             использоваться только адреса, а не имена хостов.
</p>
</dd>
<dt>UseLogin <a name="man_005fssh_005fsshd_005fconfig-UseLogin"></a></dt>
<dd><p>Указывает, используется ли login(1) для интерактивных сеансов входа
             в систему. По умолчанию используется “no”. Обратите внимание, что
             login(1) никогда не используется для удаленного выполнения команд.
             Также обратите внимание, что если это включено, X11Forwarding будет
             отключен, потому что login(1) не знает, как обращаться с файлами
             cookie xauth(1). Если указан UsePrivilegeSeparation, он будет
             отключен после аутентификации.
</p>
</dd>
<dt>UsePAM <a name="man_005fssh_005fsshd_005fconfig-UsePAM"></a></dt>
<dd><p>Включает интерфейс Pluggable Authentication Module
             (Сменный модуль аутентификации). Если установлено значение “yes”,
             это включит аутентификацию PAM с использованием
             ChallengeResponseAuthentication и PasswordAuthentication в
             дополнение к обработке учетной записи PAM и модуля сеанса для
             всех типов аутентификации.
</p>
<p>Поскольку проверка подлинности «запрос-ответ» PAM обычно играет роль,
             эквивалентную проверке подлинности по паролю, следует отключить
             PasswordAuthentication или ChallengeResponseAuthentication.
</p>
<p>Если UsePAM включен, вы не сможете запускать sshd(8) от имени
             пользователя без полномочий root. По умолчанию используется “no”.
</p>
</dd>
<dt>UsePrivilegeSeparation <a name="man_005fssh_005fsshd_005fconfig-UsePrivilegeSeparation"></a></dt>
<dd><p>Указывает, разделяет ли sshd(8) привилегии, создавая непривилегированный
             дочерний процесс для обработки входящего сетевого трафика. После успешной
             аутентификации будет создан другой процесс, имеющий привилегию
             аутентифицированного пользователя. Цель разделения привилегий состоит в
             том, чтобы предотвратить повышение привилегий путем сдерживания любого
             повреждения в непривилегированных процессах. Аргумент должен быть “yes”,
             “no”, или “sandbox”. Если для UsePrivilegeSeparation установлено значение
             “sandbox”, то непривилегированный процесс предварительной аутентификации
             будет подвергаться дополнительным ограничениям. По умолчанию используется
             “sandbox”.
</p>
</dd>
<dt>VersionAddendum <a name="man_005fssh_005fsshd_005fconfig-VersionAddendum"></a></dt>
<dd><p>Опционально указывает дополнительный текст для добавления к баннеру
             протокола SSH, отправляемому сервером при подключении. По умолчанию
             используется “none”.
</p>
</dd>
<dt>X11DisplayOffset <a name="man_005fssh_005fsshd_005fconfig-X11DisplayOffset"></a></dt>
<dd><p>Задает первый номер дисплея, доступный для пересылки X11 в sshd(8). Это
             предотвращает взаимодействие sshd с реальными серверами X11.
             По умолчанию 10.
</p>
</dd>
<dt>X11Forwarding <a name="man_005fssh_005fsshd_005fconfig-X11Forwarding"></a></dt>
<dd><p>Указывает, разрешена ли пересылка X11. Аргумент должен быть “yes” или
             “no”. По умолчанию используется “no”.
</p>
<p>Когда включена переадресация X11, сервер и клиентские дисплеи могут
             получить дополнительную информацию, если прокси-сервер sshd(8) настроен
             на прослушивание по шаблону (см. Ниже X11UseLocalhost), хотя это не
             значение по умолчанию. Кроме того, проверка подлинности подделка и
             проверка и замена данных аутентификации происходят на стороне клиента.
             Риск безопасности при использовании пересылки X11 состоит в том, что
             сервер дисплея X11 клиента может подвергаться атаке, когда клиент SSH
             запрашивает переадресацию (см. Предупреждения для ForwardX11 в
             ssh_config(5)). Системный администратор может иметь позицию, в которой
             он хочет защитить клиентов, которые могут подвергнуть себя атаке, невольно
             запросив переадресацию X11, что может гарантировать настройку “no”.
</p>
<p>Обратите внимание, что отключение пересылки X11 не мешает пользователям
             пересылать трафик X11, поскольку пользователи всегда могут установить свои
             собственные серверы пересылки. Пересылка X11 автоматически отключается,
             если включен UseLogin.
</p>
</dd>
<dt>X11UseLocalhost <a name="man_005fssh_005fsshd_005fconfig-X11UseLocalhost"></a></dt>
<dd><p>Указывает, должен ли sshd(8) связывать сервер пересылки X11 с адресом
             обратной связи или с подстановочным адресом. По умолчанию sshd связывает
             сервер пересылки с адресом обратной связи и устанавливает для части имени
             хоста переменной среды DISPLAY значение “localhost”. Это предотвращает
             подключение удаленных хостов к прокси-дисплею. Однако некоторые старые
             клиенты X11 могут не работать с этой конфигурацией. X11UseLocalhost может
             быть установлен в “no”, чтобы указать, что сервер пересылки должен быть
             связан с адресом подстановочного знака. Аргумент должен быть “yes” или
             “no”. По умолчанию используется “yes”.
</p>
</dd>
<dt>XAuthLocation <a name="man_005fssh_005fsshd_005fconfig-XAuthLocation"></a></dt>
<dd><p>Задает полный путь к программе xauth(1) или “none”, чтобы не использовать
             ее. По умолчанию используется /usr/bin/xauth.
</p></dd>
</dl>
</dd>
<dt>TIME FORMATS</dt>
<dd><p>sshd(8) аргументы командной строки и параметры файла конфигурации, которые
     задают время, могут быть выражены с помощью последовательности вида:
     time[qualifier] (время[спецификатор]), где time - положительное целочисленное
     значение, а квалификатор - один из следующих:
</p><div class="display">
<pre class="display">           ⟨none⟩  seconds
           s | S   seconds
           m | M   minutes
           h | H   hours
           d | D   days
           w | W   weeks
</pre></div>
<p>Каждый член последовательности складывается вместе для вычисления общего
     значения времени.
</p>
<p>Примеры формата времени:
</p><div class="display">
<pre class="display">           600     600 seconds (10 minutes)
           10m     10 minutes
           1h30m   1 hour 30 minutes (90 minutes)
</pre></div>
</dd>
<dt>FILES</dt>
<dd><p>/etc/ssh/sshd_config
             Содержит данные конфигурации для sshd(8). Этот файл должен быть доступен
             для записи только пользователю root, но рекомендуется
             (хотя и не обязательно), чтобы он был доступен для чтения всем.
</p>
</dd>
<dt>SEE ALSO</dt>
<dd><p>sshd(8)
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.  Niels Provos and Markus Friedl contributed support
     for privilege separation.
</p>
<p>BSD                            February 17, 2016                           BSD
</p></dd>
</dl>
<hr>
<a name="SCP_00281_0029"></a>
<div class="header">
<p>
Next: <a href="#SFTP_00281_0029" accesskey="n" rel="next">SFTP(1)</a>, Previous: <a href="#SSHD_005fCONFIG" accesskey="p" rel="prev">SSHD_CONFIG</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SCP"></a>
<h2 class="chapter">5 SCP</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>scp — безопасное копирование (программа удаленного копирования файлов)
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>scp [-<a href="#man_005fssh_005fscp-_002d1">1</a><a href="#man_005fssh_005fscp-_002d2">2</a><a href="#man_005fssh_005fscp-3">3</a><a href="#man_005fssh_005fscp-4">4</a><a href="#man_005fssh_005fscp-6">6</a><a href="#man_005fssh_005fscp-B">B</a><a href="#man_005fssh_005fscp-C">C</a><a href="#man_005fssh_005fscp-_002dp">p</a><a href="#man_005fssh_005fscp-_002dq">q</a><a href="#man_005fssh_005fscp-r">r</a><a href="#man_005fssh_005fscp-T">T</a><a href="#man_005fssh_005fscp-v">v</a>] [<a href="#man_005fssh_005fscp-c-cipher">c cipher</a>] [<a href="#man_005fssh_005fscp-_002dF-ssh_005fconfig">-F ssh_config</a>] [<a href="#man_005fssh_005fscp-_002di-identity_005ffile">-i identity_file</a>]
         [<a href="#man_005fssh_005fscp-_002dl-limit">-l limit</a>] [<a href="#man_005fssh_005fscp-_002do-ssh_005foption">-o ssh_option</a>] [<a href="#man_005fssh_005fscp-_002dP-port">-P port</a>] [<a href="#man_005fssh_005fscp-_002dS-program">-S program</a>]
         [[user@]host1:]file1 ... [[user@]host2:]file2
</p>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>scp копирует файлы между хостами в сети. Она использует ssh(1) для передачи данных, использует ту
     же аутентификацию и обеспечивает ту же безопасность, что и ssh(1). scp запросит пароли или парольные
     фразы, если они необходимы для аутентификации.
</p>
<p>Имена файлов могут содержать спецификацию пользователя и хоста, чтобы указать, что файл должен быть
     скопирован на/с этого хоста. Локальные имена файлов можно сделать явными, используя абсолютные или
     относительные имена путей, чтобы избежать scp-обработки имен файлов, содержащих ‘:’ в качестве
     спецификаторов хоста. Копии между двумя удаленными хостами также разрешены.
</p>
<p>Варианты следующие:
</p><dl compact="compact">
<dt>-1 <a name="man_005fssh_005fscp-_002d1"></a></dt>
<dd><p>Заставляет scp использовать протокол 1.
</p>
</dd>
<dt>-2 <a name="man_005fssh_005fscp-_002d2"></a></dt>
<dd><p>Заставляет scp использовать протокол 2.
</p>
</dd>
<dt>-3 <a name="man_005fssh_005fscp-3"></a></dt>
<dd><p>Копии между двумя удаленными хостами передаются через локальный хост. Без этой опции данные
             копируются непосредственно между двумя удаленными хостами. Обратите внимание, что эта опция
             отключает индикатор прогресса.
</p>
</dd>
<dt>-4 <a name="man_005fssh_005fscp-4"></a></dt>
<dd><p>Заставляет scp использовать только адреса IPv4.
</p>
</dd>
<dt>-6 <a name="man_005fssh_005fscp-6"></a></dt>
<dd><p>Заставляет scp использовать только адреса IPv6.
</p>
</dd>
<dt>-B <a name="man_005fssh_005fscp-B"></a></dt>
<dd><p>Выбирает пакетный режим (запрещает запрашивать пароли или парольные фразы).
</p>
</dd>
<dt>-C <a name="man_005fssh_005fscp-C"></a></dt>
<dd><p>Включение сжатия. Передает флаг -C в ssh (1), чтобы включить сжатие.
</p>
</dd>
<dt>-c cipher <a name="man_005fssh_005fscp-c-cipher"></a></dt>
<dd><p>Выбирает шифр, который будет использоваться для шифрования передачи данных. Эта опция
             напрямую передается в ssh(1).
</p>
</dd>
<dt>-F ssh_config <a name="man_005fssh_005fscp-_002dF-ssh_005fconfig"></a></dt>
<dd><p>Определяет альтернативный файл конфигурации для пользователя для ssh. Эта опция напрямую
             передается в ssh (1).
</p>
</dd>
<dt>-i identity_file <a name="man_005fssh_005fscp-_002di-identity_005ffile"></a></dt>
<dd><p>Выбирает файл, из которого читается идентификатор (закрытый ключ) для аутентификации с
             открытым ключом. Эта опция напрямую передается в ssh(1).
</p>
</dd>
<dt>-l limit <a name="man_005fssh_005fscp-_002dl-limit"></a></dt>
<dd><p>Ограничивает используемую пропускную способность, указанную в Кбит/с.
</p>
</dd>
<dt>-o ssh_option <a name="man_005fssh_005fscp-_002do-ssh_005foption"></a></dt>
<dd><p>Может использоваться для передачи параметров в ssh в формате, используемом в
             ssh_config(5). Это полезно для указания параметров, для которых нет отдельного
             флага командной строки scp.  Для получения полной информации о параметрах, перечисленных
             ниже, и их возможных значений, смотри ssh_config(5).
</p><div class="display">
<pre class="display">      <a href="#man_005fssh_005fssh_005fconfig-AddressFamily">AddressFamily</a>
      <a href="#man_005fssh_005fssh_005fconfig-BatchMode">BatchMode</a>
      <a href="#man_005fssh_005fssh_005fconfig-BindAddress">BindAddress</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalDomains">CanonicalDomains</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeFallbackLocal">CanonicalizeFallbackLocal</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeHostname">CanonicalizeHostname</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizeMaxDots">CanonicalizeMaxDots</a>
      <a href="#man_005fssh_005fssh_005fconfig-CanonicalizePermittedCNAMEs">CanonicalizePermittedCNAMEs</a>
      <a href="#man_005fssh_005fssh_005fconfig-CertificateFile">CertificateFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-ChallengeResponseAuthentication">ChallengeResponseAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-CheckHostIP">CheckHostIP</a>
      <a href="#man_005fssh_005fssh_005fconfig-Cipher">Cipher</a>
      <a href="#man_005fssh_005fssh_005fconfig-Ciphers">Ciphers</a>
      <a href="#man_005fssh_005fssh_005fconfig-Compression">Compression</a>
      <a href="#man_005fssh_005fssh_005fconfig-CompressionLevel">CompressionLevel</a>
      <a href="#man_005fssh_005fssh_005fconfig-ConnectionAttempts">ConnectionAttempts</a>
      <a href="#man_005fssh_005fssh_005fconfig-ConnectTimeout">ConnectTimeout</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlMaster">ControlMaster</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlPath">ControlPath</a>
      <a href="#man_005fssh_005fssh_005fconfig-ControlPersist">ControlPersist</a>
      <a href="#man_005fssh_005fssh_005fconfig-GlobalKnownHostsFile">GlobalKnownHostsFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIAuthentication">GSSAPIAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-GSSAPIDelegateCredentials">GSSAPIDelegateCredentials</a>
      <a href="#man_005fssh_005fssh_005fconfig-HashKnownHosts">HashKnownHosts</a>
      <a href="#man_005fssh_005fssh_005fconfig-Host">Host</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostbasedAuthentication">HostbasedAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostbasedKeyTypes">HostbasedKeyTypes</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostKeyAlgorithms">HostKeyAlgorithms</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostKeyAlias">HostKeyAlias</a>
      <a href="#man_005fssh_005fssh_005fconfig-HostName">HostName</a>
      <a href="#man_005fssh_005fssh_005fconfig-IdentityFile">IdentityFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-IdentitiesOnly">IdentitiesOnly</a>
      <a href="#man_005fssh_005fssh_005fconfig-IPQoS">IPQoS</a>
      <a href="#man_005fssh_005fssh_005fconfig-KbdInteractiveAuthentication">KbdInteractiveAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-KbdInteractiveDevices">KbdInteractiveDevices</a>
      <a href="#man_005fssh_005fssh_005fconfig-KexAlgorithms">KexAlgorithms</a>
      <a href="#man_005fssh_005fssh_005fconfig-LogLevel">LogLevel</a>
      <a href="#man_005fssh_005fssh_005fconfig-MACs">MACs</a>
      <a href="#man_005fssh_005fssh_005fconfig-NoHostAuthenticationForLocalhost">NoHostAuthenticationForLocalhost</a>
      <a href="#man_005fssh_005fssh_005fconfig-NumberOfPasswordPrompts">NumberOfPasswordPrompts</a>
      <a href="#man_005fssh_005fssh_005fconfig-PasswordAuthentication">PasswordAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-PKCS11Provider">PKCS11Provider</a>
      <a href="#man_005fssh_005fssh_005fconfig-Port">Port</a>
      <a href="#man_005fssh_005fssh_005fconfig-PreferredAuthentications">PreferredAuthentications</a>
      <a href="#man_005fssh_005fssh_005fconfig-Protocol">Protocol</a>
      <a href="#man_005fssh_005fssh_005fconfig-ProxyCommand">ProxyCommand</a>
      <a href="#man_005fssh_005fssh_005fconfig-PubkeyAcceptedKeyTypes">PubkeyAcceptedKeyTypes</a>
      <a href="#man_005fssh_005fssh_005fconfig-PubkeyAuthentication">PubkeyAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-RekeyLimit">RekeyLimit</a>
      <a href="#man_005fssh_005fssh_005fconfig-RhostsRSAAuthentication">RhostsRSAAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-RSAAuthentication">RSAAuthentication</a>
      <a href="#man_005fssh_005fssh_005fconfig-SendEnv">SendEnv</a>
      <a href="#man_005fssh_005fssh_005fconfig-ServerAliveInterval">ServerAliveInterval</a>
      <a href="#man_005fssh_005fssh_005fconfig-ServerAliveCountMax">ServerAliveCountMax</a>
      <a href="#man_005fssh_005fssh_005fconfig-StrictHostKeyChecking">StrictHostKeyChecking</a>
      <a href="#man_005fssh_005fssh_005fconfig-TCPKeepAlive">TCPKeepAlive</a>
      <a href="#man_005fssh_005fssh_005fconfig-UpdateHostKeys">UpdateHostKeys</a>
      <a href="#man_005fssh_005fssh_005fconfig-UsePrivilegedPort">UsePrivilegedPort</a>
      <a href="#man_005fssh_005fssh_005fconfig-User">User</a>
      <a href="#man_005fssh_005fssh_005fconfig-UserKnownHostsFile">UserKnownHostsFile</a>
      <a href="#man_005fssh_005fssh_005fconfig-VerifyHostKeyDNS">VerifyHostKeyDNS</a>

</pre></div>
</dd>
<dt>-P port <a name="man_005fssh_005fscp-_002dP-port"></a></dt>
<dd><p>Указывает порт для подключения на удаленном хосте. Обратите внимание, что этот параметр
             записывается с заглавной буквы ‘P’, поскольку -p уже зарезервирован для сохранения времени
             и режимов файла.
</p>
</dd>
<dt>-p <a name="man_005fssh_005fscp-_002dp"></a></dt>
<dd><p>Сохраняет время модификации, время доступа и режимы из исходного файла.
</p>
</dd>
<dt>-q <a name="man_005fssh_005fscp-_002dq"></a></dt>
<dd><p>Тихий режим: отключает индикатор хода выполнения, а также предупреждающие и диагностические
             сообщения от ssh(1).
</p>
</dd>
<dt>-r <a name="man_005fssh_005fscp-r"></a></dt>
<dd><p>Рекурсивно копировать целые каталоги. Обратите внимание, что scp следует символическим ссылкам,
             встречающимся в обходе дерева.
</p>
</dd>
<dt>-S program <a name="man_005fssh_005fscp-_002dS-program"></a></dt>
<dd><p>Имя программы, используемой для зашифрованного соединения. Программа должна понимать опции ssh(1).
</p>
</dd>
<dt>-T <a name="man_005fssh_005fscp-T"></a></dt>
<dd><p>Отключить строгую проверку имени файла. По умолчанию при копировании файлов с удаленного хоста
             в локальный каталог scp проверяет, совпадают ли полученные имена файлов с запрошенными в командной
             строке, чтобы предотвратить отправку удаленным концом неожиданных или нежелательных файлов. Из-за
             различий в том, как различные операционные системы и оболочки интерпретируют подстановочные знаки
             имени файла, эти проверки могут привести к отклонению нужных файлов. Эта опция отключает эти
             проверки за счет полного доверия, что сервер не будет отправлять неожиданные имена файлов.
</p>
</dd>
<dt>-v <a name="man_005fssh_005fscp-v"></a></dt>
<dd><p>Детальный режим. Заставляет scp и ssh(1) печатать отладочные сообщения об их прогрессе. Это
             полезно при отладке проблем с подключением, аутентификацией и настройкой.
</p></dd>
</dl>
</dd>
<dt>EXIT STATUS</dt>
<dd><p>Утилита scp завершает работу с 0 в случае успеха и &gt;0 в случае возникновения ошибки.
</p>
</dd>
<dt>SEE ALSO</dt>
<dd><p>sftp(1), ssh(1), ssh-add(1), ssh-agent(1), ssh-keygen(1), ssh_config(5),
     sshd(8)
</p>
</dd>
<dt>HISTORY</dt>
<dd><p>scp is based on the rcp program in BSD source code from the Regents of
     the University of California.
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>Timo Rinne &lt;tri@iki.fi&gt;
     Tatu Ylonen &lt;ylo@cs.hut.fi&gt;
</p></dd>
</dl>
<p>BSD                           September 25, 2015                           BSD
</p><hr>
<a name="SFTP_00281_0029"></a>
<div class="header">
<p>
Next: <a href="#SSH_002dADD_00281_0029" accesskey="n" rel="next">SSH-ADD(1)</a>, Previous: <a href="#SCP_00281_0029" accesskey="p" rel="prev">SCP(1)</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SFTP_00281_0029-1"></a>
<h2 class="chapter">6 SFTP(1)</h2>

<dl compact="compact">
<dt>NAME</dt>
<dd><p>sftp — программа безопасной передачи файлов
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>sftp [-<a href="#man_005fssh_005fsftp-1">1</a><a href="#man_005fssh_005fsftp-2">2</a><a href="#man_005fssh_005fsftp-4">4</a><a href="#man_005fssh_005fsftp-6">6</a><a href="#man_005fssh_005fsftp-a">a</a><a href="#man_005fssh_005fsftp-C">C</a><a href="#man_005fssh_005fsftp-f">f</a><a href="#man_005fssh_005fsftp-p">p</a><a href="#man_005fssh_005fsftp-q">q</a><a href="#man_005fssh_005fsftp-r">r</a><a href="#man_005fssh_005fsftp-v">v</a>] [<a href="#man_005fssh_005fsftp-_002dB-buffer_005fsize">-B buffer_size</a>] [<a href="#man_005fssh_005fsftp-_002db-batchfile">-b batchfile</a>] [<a href="#man_005fssh_005fsftp-_002dc-cipher">-c cipher</a>]
          [<a href="#man_005fssh_005fsftp-_002dD-sftp_005fserver_005fpath">-D sftp_server_path</a>] [<a href="#man_005fssh_005fsftp-_002dF-ssh_005fconfig">-F ssh_config</a>] [<a href="#man_005fssh_005fsftp-_002di-identity_005ffile">-i identity_file</a>] [<a href="#man_005fssh_005fsftp-_002dl-limit">-l limit</a>]
          [<a href="#man_005fssh_005fsftp-_002do-ssh_005foption">-o ssh_option</a>] [<a href="#man_005fssh_005fsftp-_002dP-port">-P port</a>] [<a href="#man_005fssh_005fsftp-_002dR-num_005frequests">-R num_requests</a>] [<a href="#man_005fssh_005fsftp-_002dS-program">-S program</a>]
          [<a href="#man_005fssh_005fsftp-_002ds-subsystem-_007c-sftp_005fserver">-s subsystem | sftp_server</a>] host
     sftp [user@]host[:file ...]
     sftp [user@]host[:dir[/]]
     sftp -b batchfile [user@]host
</p></dd>
<dt>Интерактивные команды</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fsftp-bye">bye</a>
     <a href="#man_005fssh_005fsftp-cd-path">cd path</a>
     <a href="#man_005fssh_005fsftp-chgrp-grp-path">chgrp grp path</a>
     <a href="#man_005fssh_005fsftp-chmod-mode-path">chmod mode path</a>
     <a href="#man_005fssh_005fsftp-chown-own-path">chown own path</a>
     <a href="#man_005fssh_005fsftp-df-_005b_002dhi_005d-_005bpath_005d">df [-hi] [path]</a>
     <a href="#man_005fssh_005fsftp-exit">exit</a>
     <a href="#man_005fssh_005fsftp-get-_005b_002dafPpr_005d-remote_002dpath-_005blocal_002dpath_005d">get [-afPpr] remote-path [local-path]</a>
     <a href="#man_005fssh_005fsftp-help">help</a>
     <a href="#man_005fssh_005fsftp-lcd-path">lcd path</a>
     <a href="#man_005fssh_005fsftp-lls-_005bls_002doptions-_005bpath_005d_005d">lls [ls-options [path]]</a>
     <a href="#man_005fssh_005fsftp-lmkdir-path">lmkdir path</a>
     <a href="#man_005fssh_005fsftp-ln-_005b_002ds_005d-oldpath-newpath">ln [-s] oldpath newpath</a>
     <a href="#man_005fssh_005fsftp-lpwd">lpwd</a>
     <a href="#man_005fssh_005fsftp-ls-_005b_002d1afhlnrSt_005d-_005bpath_005d">ls [-1afhlnrSt] [path]</a>
     <a href="#man_005fssh_005fsftp-lumask-umask">lumask umask</a>
     <a href="#man_005fssh_005fsftp-mkdir-path">mkdir path</a>
     <a href="#man_005fssh_005fsftp-progress">progress</a>
     <a href="#man_005fssh_005fsftp-put-_005b_002dafPpr_005d-local_002dpath-_005bremote_002dpath_005d">put [-afPpr] local-path [remote-path]</a>
     <a href="#man_005fssh_005fsftp-pwd">pwd</a>
     <a href="#man_005fssh_005fsftp-quit">quit</a>
     <a href="#man_005fssh_005fsftp-reget-_005b_002dPpr_005d-remote_002dpath-_005blocal_002dpath_005d">reget [-Ppr] remote-path [local-path]</a>
     <a href="#man_005fssh_005fsftp-reput-_005b_002dPpr_005d-_005blocal_002dpath_005d-remote_002dpath">reput [-Ppr] [local-path] remote-path</a>
     <a href="#man_005fssh_005fsftp-rename-oldpath-newpath">rename oldpath newpath</a>
     <a href="#man_005fssh_005fsftp-rm-path">rm path</a>
     <a href="#man_005fssh_005fsftp-rmdir-path">rmdir path</a>
     <a href="#man_005fssh_005fsftp-symlink-oldpath-newpath">symlink oldpath newpath</a>
     <a href="#man_005fssh_005fsftp-version">version</a>
     <a href="#man_005fssh_005fsftp-_0021command">!command</a>
     <a href="#man_005fssh_005fsftp-_0021">!</a>
     <a href="#man_005fssh_005fsftp-_003f">?</a>
</pre></div>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>sftp - это интерактивная программа для передачи файлов, похожая на ftp(1),
     которая выполняет все операции с использованием зашифрованного транспорта ssh(1). Она
     также может использовать многие функции ssh, такие как аутентификация и сжатие с
     открытым ключом. sftp подключается и входит на указанный хост, затем переходит в
     интерактивный командный режим.
</p>
<p>Второй формат использования будет извлекать файлы автоматически, если используется
     неинтерактивный метод аутентификации; в противном случае это будет сделано после
     успешной интерактивной аутентификации.
</p>
<p>Третий формат использования позволяет запускать sftp в удаленном каталоге.
</p>
<p>Окончательный формат использования позволяет автоматизировать сеансы с использованием
     опции -b. В таких случаях необходимо настроить неинтерактивную аутентификацию, чтобы
     устранить необходимость ввода пароля во время подключения (см. Sshd(8) и ssh-keygen(1)
     для получения подробной информации).
</p>
<p>Поскольку некоторые форматы использования используют символы двоеточия для отделения
     имен хостов от путей, адреса IPv6 должны быть заключены в квадратные скобки во
     избежание двусмысленности.
</p>
<p>Возможны следующие варианты:
</p><dl compact="compact">
<dt>-1 <a name="man_005fssh_005fsftp-1"></a></dt>
<dd><p>Указывает использование протокола версии 1.
</p>
</dd>
<dt>-2 <a name="man_005fssh_005fsftp-2"></a></dt>
<dd><p>Указывает использование протокола версии 2.
</p>
</dd>
<dt>-4 <a name="man_005fssh_005fsftp-4"></a></dt>
<dd><p>Заставляет sftp использовать только адреса IPv4.
</p>
</dd>
<dt>-6 <a name="man_005fssh_005fsftp-6"></a></dt>
<dd><p>Заставляет sftp использовать только адреса IPv6.
</p>
</dd>
<dt>-a <a name="man_005fssh_005fsftp-a"></a></dt>
<dd><p>Попытка продолжить прерванную передачу, а не перезаписывать
             существующие частичные или полные копии файлов. Если частичное
             содержимое отличается от передаваемого, то результирующий файл может
             быть поврежден.
</p>
</dd>
<dt>-B buffer_size <a name="man_005fssh_005fsftp-_002dB-buffer_005fsize"></a></dt>
<dd><p>Укажите размер буфера, который использует sftp при передаче файлов. Большие
             буферы требуют меньше циклов обработки за счет более высокого потребления
             памяти. По умолчанию это байты 32768.
</p>
</dd>
<dt>-b batchfile <a name="man_005fssh_005fsftp-_002db-batchfile"></a></dt>
<dd><p>Пакетный режим читает серию команд из входного пакетного файла вместо
             стандартного ввода. Поскольку в нем отсутствует взаимодействие с
             пользователем, его следует использовать в сочетании с неинтерактивной
             аутентификацией. Пакетный файл может использовать ‘-’ для указания
             стандартного ввода. sftp прервет работу, если любая из следующих команд
             завершится неудачно: get, put, reget, reput, rename, ln, rm, mkdir, chdir,
             ls, lchdir, chmod, chown, chgrp, lpwd, df, symlink, и lmkdir. Завершение в
             случае ошибки может быть подавлено для каждой команды в отдельности путем
             добавления к команде префикса с символом ‘-’ (например, -rm /tmp/blah*).
</p>
</dd>
<dt>-C <a name="man_005fssh_005fsftp-C"></a></dt>
<dd><p>Включает сжатие (через флаг ssh -C).
</p>
</dd>
<dt>-c cipher <a name="man_005fssh_005fsftp-_002dc-cipher"></a></dt>
<dd><p>Выбирает шифр, который будет использоваться для шифрования передачи данных.
             Эта опция напрямую передается в ssh(1).
</p>
</dd>
<dt>-D sftp_server_path <a name="man_005fssh_005fsftp-_002dD-sftp_005fserver_005fpath"></a></dt>
<dd><p>Подключайтесь напрямую к локальному серверу sftp (а не через ssh(1)). Эта
             опция может быть полезна при отладке клиента и сервера.
</p>
</dd>
<dt>-F ssh_config <a name="man_005fssh_005fsftp-_002dF-ssh_005fconfig"></a></dt>
<dd><p>Определяет альтернативный файл конфигурации для пользователя ssh(1). Эта
             опция напрямую передается в ssh(1).
</p>
</dd>
<dt>-f <a name="man_005fssh_005fsftp-f"></a></dt>
<dd><p>Требует, чтобы файлы были записаны на диск сразу после передачи. При загрузке
             файлов эта функция включается только в том случае, если на сервере
             реализовано расширение &quot;fsync@openssh.com&quot;.
</p>
</dd>
<dt>-i identity_file <a name="man_005fssh_005fsftp-_002di-identity_005ffile"></a></dt>
<dd><p>Выбирает файл, из которого читается идентификатор (закрытый ключ) для
             аутентификации с открытым ключом. Эта опция напрямую передается в ssh(1).
</p>
</dd>
<dt>-l limit <a name="man_005fssh_005fsftp-_002dl-limit"></a></dt>
<dd><p>Ограничивает используемую пропускную способность, указанную в Кбит/с.
</p>
</dd>
<dt>-o ssh_option <a name="man_005fssh_005fsftp-_002do-ssh_005foption"></a></dt>
<dd><p>Может использоваться для передачи параметров в ssh в формате, используемом в
             ssh_config(5). Это полезно для указания параметров, для которых нет
             отдельного флага командной строки sftp. Например, чтобы указать альтернативный
             порт, используйте: sftp -oPort=24. Для получения полной информации о
             параметрах, перечисленных ниже, и их возможных значений, смотри ssh_config(5).
</p><div class="display">
<pre class="display">                   AddressFamily
                   BatchMode
                   BindAddress
                   CanonicalDomains
                   CanonicalizeFallbackLocal
                   CanonicalizeHostname
                   CanonicalizeMaxDots
                   CanonicalizePermittedCNAMEs
                   CertificateFile
                   ChallengeResponseAuthentication
                   CheckHostIP
                   Cipher
                   Ciphers
                   Compression
                   CompressionLevel
                   ConnectionAttempts
                   ConnectTimeout
                   ControlMaster
                   ControlPath
                   ControlPersist
                   GlobalKnownHostsFile
                   GSSAPIAuthentication
                   GSSAPIDelegateCredentials
                   HashKnownHosts
                   Host
                   HostbasedAuthentication
                   HostbasedKeyTypes
                   HostKeyAlgorithms
                   HostKeyAlias
                   HostName
                   IdentityFile
                   IdentitiesOnly
                   IPQoS
                   KbdInteractiveAuthentication
                   KbdInteractiveDevices
                   KexAlgorithms
                   LogLevel
                   MACs
                   NoHostAuthenticationForLocalhost
                   NumberOfPasswordPrompts
                   PasswordAuthentication
                   PKCS11Provider
                   Port
                   PreferredAuthentications
                   Protocol
                   ProxyCommand
                   PubkeyAuthentication
                   RekeyLimit
                   RhostsRSAAuthentication
                   RSAAuthentication
                   SendEnv
                   ServerAliveInterval
                   ServerAliveCountMax
                   StrictHostKeyChecking
                   TCPKeepAlive
                   UpdateHostKeys
                   UsePrivilegedPort
                   User
                   UserKnownHostsFile
                   VerifyHostKeyDNS
</pre></div>
</dd>
<dt>-P port <a name="man_005fssh_005fsftp-_002dP-port"></a></dt>
<dd><p>Указывает порт для подключения на удаленном хосте.
</p>
</dd>
<dt>-p <a name="man_005fssh_005fsftp-p"></a></dt>
<dd><p>Сохраняет время модификации, время доступа и режимы из исходных файлов,
             переданных.
</p>
</dd>
<dt>-q <a name="man_005fssh_005fsftp-q"></a></dt>
<dd><p>Тихий режим: отключает индикатор хода выполнения, а также предупреждающие
             и диагностические сообщения от ssh(1).
</p>
</dd>
<dt>-R num_requests <a name="man_005fssh_005fsftp-_002dR-num_005frequests"></a></dt>
<dd><p>Укажите, сколько запросов может быть ожидающим одновременно. Увеличение
             этого значения может немного улучшить скорость передачи файлов, но увеличит
             использование памяти. По умолчанию 64 невыполненных запроса.
</p>
</dd>
<dt>-r <a name="man_005fssh_005fsftp-r"></a></dt>
<dd><p>При загрузке и выгрузке рекурсивно копируйте целые каталоги. Обратите
             внимание, что sftp не следует символическим ссылкам, встречающимся в
             обходе дерева.
</p>
</dd>
<dt>-S program <a name="man_005fssh_005fsftp-_002dS-program"></a></dt>
<dd><p>Название программы, используемой для зашифрованного соединения. Программа
             должна понимать опции ssh(1).
</p>
</dd>
<dt>-s subsystem | sftp_server <a name="man_005fssh_005fsftp-_002ds-subsystem-_007c-sftp_005fserver"></a></dt>
<dd><p>Задает подсистему SSH2 или путь к серверу sftp на удаленном хосте. Путь
             полезен для использования sftp поверх протокола версии 1 или когда на
             удаленном sshd(8) не настроена подсистема sftp.
</p>
</dd>
<dt>-v <a name="man_005fssh_005fsftp-v"></a></dt>
<dd><p>Поднимите уровень регистрации. Эта опция также передается в ssh.
</p></dd>
</dl>
</dd>
<dt>INTERACTIVE COMMANDS</dt>
<dd><p>Находясь в интерактивном режиме, sftp понимает набор команд, аналогичных командам
     ftp(1). Команды не чувствительны к регистру. Пути, содержащие пробелы, должны быть
     заключены в кавычки. Любые специальные символы, содержащиеся в путевых именах,
     которые распознаются glob(3), должны быть экранированы с помощью обратной косой
     черты (‘\’).
</p><dl compact="compact">
<dt>bye <a name="man_005fssh_005fsftp-bye"></a></dt>
<dd><p>Выйти из sftp.
</p>
</dd>
<dt>cd path <a name="man_005fssh_005fsftp-cd-path"></a></dt>
<dd><p>Измените удаленный каталог на путь.
</p>
</dd>
<dt>chgrp grp path <a name="man_005fssh_005fsftp-chgrp-grp-path"></a></dt>
<dd><p>Измените группу файла path на grp. path может содержать символы glob(3) и
             может соответствовать нескольким файлам. grp должен быть числовым GID.
</p>
</dd>
<dt>chmod mode path <a name="man_005fssh_005fsftp-chmod-mode-path"></a></dt>
<dd><p>Измените права доступа к файлу path на mode. path может содержать
             символы glob(3) и может соответствовать нескольким файлам.
</p>
</dd>
<dt>chown own path <a name="man_005fssh_005fsftp-chown-own-path"></a></dt>
<dd><p>Измените владельца файла path на own. path может содержать символы
             glob(3) и может соответствовать нескольким файлам. own должен быть
             числовым UID.
</p>
</dd>
<dt>df [-hi] [path] <a name="man_005fssh_005fsftp-df-_005b_002dhi_005d-_005bpath_005d"></a></dt>
<dd><p>Вывести информацию об использовании для файловой системы, содержащей
             текущий каталог (или path, если указан). Если указан флаг -h, информация
             о емкости будет отображаться с использованием суффиксов &quot;human-readable&quot;
             (удобочитаемых). Флаг -i запрашивает отображение информации об узле в
             дополнение к информации о емкости. Эта команда поддерживается только на
             серверах, которые реализуют расширение “statvfs@openssh.com”.
</p>
</dd>
<dt>exit <a name="man_005fssh_005fsftp-exit"></a></dt>
<dd><p>Завершить sftp.
</p>
</dd>
<dt>get [-<a href="#man_005fssh_005fsftp_005fget-a">a</a><a href="#man_005fssh_005fsftp_005fget-f">f</a><a href="#man_005fssh_005fsftp_005fget-P_007cp">Pp</a><a href="#man_005fssh_005fsftp_005fget-r">r</a>] remote-path [local-path] <a name="man_005fssh_005fsftp-get-_005b_002dafPpr_005d-remote_002dpath-_005blocal_002dpath_005d"></a></dt>
<dd><p>Получите удаленный путь и сохраните его на локальном компьютере. Если
             локальный путь не указан, ему присваивается то же имя, что и на удаленном
             компьютере. Удаленный путь может содержать символы glob(3) и может
             соответствовать нескольким файлам. Если это так и указан local-path,
             то local-path должен указывать директорию.
</p><dl compact="compact">
<dt>-a <a name="man_005fssh_005fsftp_005fget-a"></a></dt>
<dd><p>Если указан флаг -a, попытайтесь возобновить частичную передачу существующих
             файлов. Обратите внимание, что возобновление предполагает, что любая
             частичная копия локального файла соответствует удаленной копии. Если
             содержимое удаленного файла отличается от частичной локальной копии, то
             результирующий файл может быть поврежден.
</p></dd>
<dt>-f <a name="man_005fssh_005fsftp_005fget-f"></a></dt>
<dd><p>Если указан флаг -f, то после завершения передачи файла будет вызван
             fsync(2) для сброса файла на диск.
</p></dd>
<dt>P|p <a name="man_005fssh_005fsftp_005fget-P_007cp"></a></dt>
<dd><p>Если указан флаг -P или -p, то также копируются полные разрешения и
             время доступа к файлу.
</p></dd>
<dt>-r <a name="man_005fssh_005fsftp_005fget-r"></a></dt>
<dd><p>Если указан флаг -r, то каталоги будут копироваться рекурсивно. Обратите
             внимание, что sftp не следует по символическим ссылкам при выполнении
             рекурсивных передач.
</p></dd>
</dl>
</dd>
<dt>help <a name="man_005fssh_005fsftp-help"></a></dt>
<dd><p>Показать текст справки.
</p>
</dd>
<dt>lcd path <a name="man_005fssh_005fsftp-lcd-path"></a></dt>
<dd><p>Изменить локальный каталог на path.
</p>
</dd>
<dt>lls [ls-options [path]] <a name="man_005fssh_005fsftp-lls-_005bls_002doptions-_005bpath_005d_005d"></a></dt>
<dd><p>Показать список локальных каталогов либо path, либо текущего каталога, если
             путь не указан. ls-options может содержать любые флаги, поддерживаемые
             командой ls(1) локальной системы. path может содержать символы glob(3) и
             может соответствовать нескольким файлам.
</p>
</dd>
<dt>lmkdir path <a name="man_005fssh_005fsftp-lmkdir-path"></a></dt>
<dd><p>Создать локальный каталог, указанный в path.
</p>
</dd>
<dt>ln [-s] oldpath newpath <a name="man_005fssh_005fsftp-ln-_005b_002ds_005d-oldpath-newpath"></a></dt>
<dd><p>Создайте ссылку от oldpath до newpath. Если указан флаг -s, созданная
             ссылка является символической ссылкой, в противном случае это жесткая
             ссылка.
</p>
</dd>
<dt>lpwd <a name="man_005fssh_005fsftp-lpwd"></a></dt>
<dd><p>Распечатать локальный рабочий каталог.
</p>
</dd>
<dt>ls [-<a href="#man_005fssh_005fsftp_005fls-1">1</a><a href="#man_005fssh_005fsftp_005fls-a">a</a><a href="#man_005fssh_005fsftp_005fls-f">f</a><a href="#man_005fssh_005fsftp_005fls-h">h</a><a href="#man_005fssh_005fsftp_005fls-l">l</a><a href="#man_005fssh_005fsftp_005fls-n">n</a><a href="#man_005fssh_005fsftp_005fls-r">r</a><a href="#man_005fssh_005fsftp_005fls-S">S</a><a href="#man_005fssh_005fsftp_005fls-t">t</a>] [path] <a name="man_005fssh_005fsftp-ls-_005b_002d1afhlnrSt_005d-_005bpath_005d"></a></dt>
<dd><p>Вывести список удаленных каталогов либо path, либо текущего каталога, если
             path не указан. path может содержать символы glob(3) и может соответствовать
             нескольким файлам.
</p>
<p>Следующие флаги распознаются и соответственно изменяют поведение ls:
</p><dl compact="compact">
<dt>-1 <a name="man_005fssh_005fsftp_005fls-1"></a></dt>
<dd><p>Произвести вывод в один столбец.
</p>
</dd>
<dt>-a <a name="man_005fssh_005fsftp_005fls-a"></a></dt>
<dd><p>Список файлов, начинающихся с точки (‘.’).
</p>
</dd>
<dt>-f <a name="man_005fssh_005fsftp_005fls-f"></a></dt>
<dd><p>Не сортируйте список. Порядок сортировки по умолчанию является
                     лексикографическим.
</p>
</dd>
<dt>-h <a name="man_005fssh_005fsftp_005fls-h"></a></dt>
<dd><p>При использовании с параметром длинного формата используйте суффиксы
                     единиц: Byte, Kilobyte, Megabyte, Gigabyte, Terabyte, Petabyte, и
                     Exabyte, чтобы уменьшить количество цифр до четырех или менее,
                     используя степени 2 для размеров (K=1024, M=1048576 и т.д.).
</p>
</dd>
<dt>-l <a name="man_005fssh_005fsftp_005fls-l"></a></dt>
<dd><p>Показать дополнительную информацию, включая разрешения и
                     информацию о владельце.
</p>
</dd>
<dt>-n <a name="man_005fssh_005fsftp_005fls-n"></a></dt>
<dd><p>Создайте длинный список с информацией о пользователях и группах
                     в числовом формате.
</p>
</dd>
<dt>-r <a name="man_005fssh_005fsftp_005fls-r"></a></dt>
<dd><p>Обратный порядок сортировки списка.
</p>
</dd>
<dt>-S <a name="man_005fssh_005fsftp_005fls-S"></a></dt>
<dd><p>Сортировать список по размеру файла.
</p>
</dd>
<dt>-t <a name="man_005fssh_005fsftp_005fls-t"></a></dt>
<dd><p>Сортировать список по времени последнего изменения.
</p></dd>
</dl>

</dd>
<dt>lumask umask <a name="man_005fssh_005fsftp-lumask-umask"></a></dt>
<dd><p>Установите для локального umask значение umask.
</p>
</dd>
<dt>mkdir path <a name="man_005fssh_005fsftp-mkdir-path"></a></dt>
<dd><p>Создать удаленный каталог, указанный в path.
</p>
</dd>
<dt>progress <a name="man_005fssh_005fsftp-progress"></a></dt>
<dd><p>Переключить отображение индикатора прогресса.
</p>
</dd>
<dt>put [-afPpr] local-path [remote-path] <a name="man_005fssh_005fsftp-put-_005b_002dafPpr_005d-local_002dpath-_005bremote_002dpath_005d"></a></dt>
<dd><p>Загрузите local-path и сохраните его на удаленном компьютере. Если имя
             удаленного пути не указано, ему присваивается то же имя, что и на локальном
             компьютере. local-path может содержать символы glob(3) и может
             соответствовать нескольким файлам. Если это так и указан remote-path, то
             remote-path должен указать каталог.
</p><dl compact="compact">
<dt>a</dt>
<dd><p>Если указан флаг -a, попытайтесь возобновить частичную передачу существующих
             файлов. Обратите внимание, что возобновление предполагает, что любая частичная
             копия удаленного файла соответствует локальной копии. Если содержимое
             локального файла отличается от удаленной локальной копии, то результирующий
             файл может быть поврежден.
</p></dd>
<dt>f</dt>
<dd><p>Если указан флаг -f, то после отправки файла на сервер будет отправлен запрос
             на вызов fsync(2). Обратите внимание, что это поддерживается только серверами,
             которые реализуют расширение &quot;fsync@openssh.com&quot;.
</p></dd>
<dt>P|p</dt>
<dd><p>Если указан флаг -P или -p, то также копируются полные разрешения и
             время доступа к файлу.
</p>
</dd>
<dt>r</dt>
<dd><p>Если указан флаг -r, то каталоги будут копироваться рекурсивно. Обратите
             внимание, что sftp не следует по символическим ссылкам при выполнении
             рекурсивных передач.
</p></dd>
</dl>
</dd>
<dt>pwd <a name="man_005fssh_005fsftp-pwd"></a></dt>
<dd><p>Показать удаленный рабочий каталог.
</p>
</dd>
<dt>quit <a name="man_005fssh_005fsftp-quit"></a></dt>
<dd><p>Завершить sftp.
</p>
</dd>
<dt>reget [-Ppr] remote-path [local-path] <a name="man_005fssh_005fsftp-reget-_005b_002dPpr_005d-remote_002dpath-_005blocal_002dpath_005d"></a></dt>
<dd><p>Возобновить загрузку remote-path. Эквивалентно получить с установленным
             флагом -a.
</p>
</dd>
<dt>reput [-Ppr] [local-path] remote-path <a name="man_005fssh_005fsftp-reput-_005b_002dPpr_005d-_005blocal_002dpath_005d-remote_002dpath"></a></dt>
<dd><p>Возобновить загрузку [local-path]. Эквиваленто установленному флагу -a.
</p>
</dd>
<dt>rename oldpath newpath <a name="man_005fssh_005fsftp-rename-oldpath-newpath"></a></dt>
<dd><p>Переименовать удаленный файл из oldpath в newpath.
</p>
</dd>
<dt>rm path <a name="man_005fssh_005fsftp-rm-path"></a></dt>
<dd><p>Удалить удаленный файл, указанный в path.
</p>
</dd>
<dt>rmdir path <a name="man_005fssh_005fsftp-rmdir-path"></a></dt>
<dd><p>Удалить удаленный каталог, указанный в path.
</p>
</dd>
<dt>symlink oldpath newpath <a name="man_005fssh_005fsftp-symlink-oldpath-newpath"></a></dt>
<dd><p>Создайте символическую ссылку от oldpath до newpath.
</p>
</dd>
<dt>version <a name="man_005fssh_005fsftp-version"></a></dt>
<dd><p>Показать версию протокола sftp.
</p>
</dd>
<dt>!command <a name="man_005fssh_005fsftp-_0021command"></a></dt>
<dd><p>Выполните command в локальной оболочке.
</p>
</dd>
<dt>! <a name="man_005fssh_005fsftp-_0021"></a></dt>
<dd><p>Перейти в локальную оболочку.
</p>
</dd>
<dt>? <a name="man_005fssh_005fsftp-_003f"></a></dt>
<dd><p>Синоним для help.
</p></dd>
</dl>

</dd>
<dt>SEE ALSO</dt>
<dd><p>ftp(1), ls(1), scp(1), ssh(1), ssh-add(1), ssh-keygen(1), glob(3),
     ssh_config(5), sftp-server(8), sshd(8)
</p>
<p>T. Ylonen and S. Lehtinen, SSH File Transfer Protocol, draft-ietf-secsh-
     filexfer-00.txt, January 2001, work in progress material.
</p>
<p>BSD                           September 25, 2015                           BSD
</p></dd>
</dl>
<hr>
<a name="SSH_002dADD_00281_0029"></a>
<div class="header">
<p>
Next: <a href="#SSH_002dAGENT" accesskey="n" rel="next">SSH-AGENT</a>, Previous: <a href="#SFTP_00281_0029" accesskey="p" rel="prev">SFTP(1)</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH_002dADD"></a>
<h2 class="chapter">7 SSH-ADD</h2>

<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh-add — добавляет личный ключ к агенту аутентификации
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>ssh-add [-<a href="#man_005fssh_005fadd-c">c</a><a href="#man_005fssh_005fadd-D">D</a><a href="#man_005fssh_005fadd-d">d</a><a href="#man_005fssh_005fadd-k">k</a><a href="#man_005fssh_005fadd-L">L</a><a href="#man_005fssh_005fadd-l">l</a><a href="#man_005fssh_005fadd-X">X</a><a href="#man_005fssh_005fadd-x">x</a>] [<a href="#man_005fssh_005fadd-_002dE-fingerprint_005fhash">-E fingerprint_hash</a>] [<a href="#man_005fssh_005fadd-_002dt-life">-t life</a>] [file ...]
     ssh-add <a href="#man_005fssh_005fadd-_002ds-pkcs11">-s pkcs11</a>
     ssh-add <a href="#man_005fssh_005fadd-_002de-pkcs11">-e pkcs11</a>
</p></dd>
<dt>Переменные окружения</dt>
<dd><p><a href="#man_005fssh_005fadd-DISPLAY-_0438-SSH_005fASKPASS">DISPLAY и SSH_ASKPASS</a>
        <a href="#man_005fssh_005fadd-SSH_005fAUTH_005fSOCK">SSH_AUTH_SOCK</a>
</p></dd>
<dt>Файлы</dt>
<dd><div class="display">
<pre class="display">        <a href="#man_005fssh_005fadd-_007e_002f_002essh_002fidentity">~/.ssh/identity</a>
        <a href="#man_005fssh_005fadd-_007e_002f_002essh_002fid_005fdsa">~/.ssh/id_dsa</a>
        <a href="#man_005fssh_005fadd-_007e_002f_002essh_002fid_005fecdsa">~/.ssh/id_ecdsa</a>
        <a href="#man_005fssh_005fadd-_007e_002f_002essh_002fid_005fed25519">~/.ssh/id_ed25519</a>
        <a href="#man_005fssh_005fadd-_007e_002f_002essh_002fid_005frsa">~/.ssh/id_rsa</a>
</pre></div>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh-add добавляет личный ключ к агенту аутентификации ssh-agent(1). При запуске
     без аргументов он добавляет файлы ~/.ssh/id_rsa, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa,
     ~/.ssh/id_ed25519 и ~/.ssh/identity. После загрузки закрытого ключа ssh-add
     попытается загрузить соответствующую информацию сертификата из имени файла,
     полученного путем добавления -cert.pub к имени файла закрытого ключа. Альтернативные
     имена файлов могут быть указаны в командной строке.
</p>
<p>Если какой-либо файл требует парольную фразу, ssh-add запрашивает парольную фразу
     от пользователя. Парольная фраза читается из tty пользователя. ssh-add повторяет
     последнюю фразу-пароль, если задано несколько файлов идентификации.
</p>
<p>Агент аутентификации должен быть запущен, а переменная окружения SSH_AUTH_SOCK
     должна содержать имя своего сокета, чтобы ssh-add мог работать.
</p>
<p>Возможны следующие варианты:
</p><dl compact="compact">
<dt>-c <a name="man_005fssh_005fadd-c"></a></dt>
<dd><p>Указывает, что добавленные идентификаторы должны быть подтверждены перед
             использованием для аутентификации. Подтверждение выполняется с помощью
             ssh-askpass(1). Успешное подтверждение сигнализируется нулевым статусом
             выхода из ssh-askpass(1), а не текстом, введенным в запрашивающую сторону.
</p>
</dd>
<dt>-D <a name="man_005fssh_005fadd-D"></a></dt>
<dd><p>Удаляет все удостоверения от агента.
</p>
</dd>
<dt>-d <a name="man_005fssh_005fadd-d"></a></dt>
<dd><p>Вместо добавления идентификаторов удаляет идентификаторы из агента. Если
             ssh-add был запущен без аргументов, ключи для идентификаторов по умолчанию и
             соответствующие им сертификаты будут удалены. В противном случае список
             аргументов будет интерпретирован как список путей к файлам с открытым ключом
             для указания ключей и сертификатов, которые необходимо удалить из агента.
             Если по указанному пути открытый ключ не найден, ssh-add добавит .pub и
             повторит попытку.
</p>
</dd>
<dt>-E fingerprint_hash <a name="man_005fssh_005fadd-_002dE-fingerprint_005fhash"></a></dt>
<dd><p>Определяет алгоритм хеширования, используемый при отображении отпечатков
             клавиш. Допустимые варианты: “md5” и “sha256”. По умолчанию используется
             “sha256”.
</p>
</dd>
<dt>-e pkcs11 <a name="man_005fssh_005fadd-_002de-pkcs11"></a></dt>
<dd><p>Удалить ключи, предоставляемые общей библиотекой PKCS#11 pkcs11.
</p>
</dd>
<dt>-k <a name="man_005fssh_005fadd-k"></a></dt>
<dd><p>При загрузке ключей или удалении ключей из агента обрабатывайте только
             простые личные ключи и пропускайте сертификаты.
</p>
</dd>
<dt>-L <a name="man_005fssh_005fadd-L"></a></dt>
<dd><p>Перечисляет параметры открытого ключа всех идентификаторов, представленных
             в настоящее время агентом.
</p>
</dd>
<dt>-l <a name="man_005fssh_005fadd-l"></a></dt>
<dd><p>Перечисляет отпечатки всех идентификаторов, представленных в
             настоящее время агентом.
</p>
</dd>
<dt>-s pkcs11 <a name="man_005fssh_005fadd-_002ds-pkcs11"></a></dt>
<dd><p>Добавьте ключи, предоставляемые общей библиотекой PKCS#11 pkcs11.
</p>
</dd>
<dt>-t life <a name="man_005fssh_005fadd-_002dt-life"></a></dt>
<dd><p>Установите максимальное время жизни при добавлении идентификаторов агенту.
             Время жизни может быть указано в секундах или в формате времени, указанном
             в sshd_config(5).
</p>
</dd>
<dt>-X <a name="man_005fssh_005fadd-X"></a></dt>
<dd><p>Разблокировать агент.
</p>
</dd>
<dt>-x <a name="man_005fssh_005fadd-x"></a></dt>
<dd><p>Заблокируйте агент паролем.
</p></dd>
</dl>
</dd>
<dt>ENVIRONMENT</dt>
<dd><dl compact="compact">
<dt>DISPLAY и SSH_ASKPASS <a name="man_005fssh_005fadd-DISPLAY-_0438-SSH_005fASKPASS"></a></dt>
<dd><p>Если ssh-add требуется фраза-пароль, она будет считывать фразу-пароль с
             текущего терминала, если она была запущена с терминала. Если ssh-add не имеет
             связанного с ним терминала, но установлены DISPLAY и SSH_ASKPASS, он выполнит
             программу, заданную SSH_ASKPASS (по умолчанию “ssh-askpass”), и откроет окно
             X11 для чтения парольной фразы. Это особенно полезно при вызове ssh-add из
             .xsession или связанного скрипта. (Обратите внимание, что на некоторых
             машинах может потребоваться перенаправить ввод с /dev/null, чтобы сделать
             эту работу.)
</p>
</dd>
<dt>SSH_AUTH_SOCK <a name="man_005fssh_005fadd-SSH_005fAUTH_005fSOCK"></a></dt>
<dd><p>Определяет путь к сокету UNIX-домена, используемому для связи с агентом.
</p></dd>
</dl>
</dd>
<dt>FILES</dt>
<dd><div class="display">
<pre class="display">     ~/.ssh/identity <a name="man_005fssh_005fadd-_007e_002f_002essh_002fidentity"></a>             Содержит протокол аутентификации RSA версии 1 пользователя.

     ~/.ssh/id_dsa <a name="man_005fssh_005fadd-_007e_002f_002essh_002fid_005fdsa"></a>             Содержит протокол аутентификации DSA версии 2 пользователя.

     ~/.ssh/id_ecdsa <a name="man_005fssh_005fadd-_007e_002f_002essh_002fid_005fecdsa"></a>             Содержит протокол аутентификации ECDSA версии 2 пользователя.

     ~/.ssh/id_ed25519 <a name="man_005fssh_005fadd-_007e_002f_002essh_002fid_005fed25519"></a>             Содержит протокол аутентификации Ed25519 версии 2 удостоверения
             личности пользователя.

     ~/.ssh/id_rsa <a name="man_005fssh_005fadd-_007e_002f_002essh_002fid_005frsa"></a>             Содержит протокол аутентификации RSA версии 2 пользователя.

</pre></div>
<p>Идентификационные файлы не должны быть доступны для чтения никому, кроме
     пользователя. Обратите внимание, что ssh-add игнорирует файлы идентификации,
     если они доступны другим.
</p>
</dd>
<dt>EXIT STATUS</dt>
<dd><p>Состояние выхода равно 0 в случае успеха, 1, если указанная команда не
     выполнена, и 2, если ssh-add не может связаться с агентом аутентификации.
</p>
</dd>
<dt>SEE ALSO</dt>
<dd><p>ssh(1), ssh-agent(1), ssh-askpass(1), ssh-keygen(1), sshd(8)
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.
</p>
<p>BSD                             March 30, 2015                             BSD
</p></dd>
</dl>

<hr>
<a name="SSH_002dAGENT"></a>
<div class="header">
<p>
Next: <a href="#SSH_002dARGV0" accesskey="n" rel="next">SSH-ARGV0</a>, Previous: <a href="#SSH_002dADD_00281_0029" accesskey="p" rel="prev">SSH-ADD(1)</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH_002dAGENT-1"></a>
<h2 class="chapter">8 SSH-AGENT</h2>

<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh-agent — агент аутентификации
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>ssh-agent [<a href="#man_005fssh_005fagent-_002dc">-c</a>| -s] [<a href="#man_005fssh_005fagent-_002dD">D</a><a href="#man_005fssh_005fagent-d">d</a>] [<a href="#man_005fssh_005fagent-_002da-bind_005faddress">-a bind_address</a>] [<a href="#man_005fssh_005fagent-_002dE-fingerprint_005fhash">-E fingerprint_hash</a>]
               [<a href="#man_005fssh_005fagent-_002dt-life">-t life</a>] [<a href="#man_005fssh_005fagent-_002dP">-P</a> pkcs11_whitelist] [command [arg ...]]
     ssh-agent [-c | <a href="#man_005fssh_005fagent-_002ds">-s</a>] <a href="#man_005fssh_005fagent-_002dk">-k</a>
</p>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh-agent - это программа для хранения закрытых ключей, используемая для
     аутентификации с открытым ключом (RSA, DSA, ECDSA, Ed25519). ssh-agent обычно
     запускается в начале сеанса X-session или входа в систему, а все остальные окна или
     программы запускаются как клиенты для программы ssh-agent. Благодаря использованию
     переменных среды агент может быть найден и автоматически использован для
     аутентификации при входе на другие машины с использованием ssh(1).
</p>
<p>У агента изначально нет закрытых ключей. Ключи добавляются с помощью ssh(1)
     (подробности см. В AddKeysToAgent в ssh_config(5)) или в ssh-add(1). Несколько
     идентификаторов могут храниться в ssh-agent одновременно, и ssh(1) будет автоматически
     использовать их, если они есть. ssh-add (1) также используется для удаления ключей
     из ssh-agent и для запроса ключей, которые содержатся в одном.
</p>
<p>Возможны следующие варианты:
</p><dl compact="compact">
<dt>-a bind_address <a name="man_005fssh_005fagent-_002da-bind_005faddress"></a></dt>
<dd><p>Привязать агент к сокету UNIX-домена bind_address. По умолчанию
             используется $TMPDIR/ssh-XXXXXXXXXX/agent.&lt;ppid&gt;.
</p>
</dd>
<dt>-c <a name="man_005fssh_005fagent-_002dc"></a></dt>
<dd><p>Генерируйте команды C-shell на stdout. Это значение по умолчанию,
             если SHELL выглядит как оболочка стиля csh.
</p>
</dd>
<dt>-D <a name="man_005fssh_005fagent-_002dD"></a></dt>
<dd><p>Режим переднего плана. Если указан этот параметр, ssh-agent не будет
             выполнять ветвление.
</p>
</dd>
<dt>-d <a name="man_005fssh_005fagent-d"></a></dt>
<dd><p>Режим отладки. Когда указана эта опция, ssh-agent не будет разветвляться
             и записывает отладочную информацию в стандартную ошибку.
</p>
</dd>
<dt>-E fingerprint_hash <a name="man_005fssh_005fagent-_002dE-fingerprint_005fhash"></a></dt>
<dd><p>Определяет алгоритм хеширования, используемый при отображении отпечатков
             клавиш. Допустимые варианты: «md5» и «sha256». По умолчанию это «sha256».
</p>
</dd>
<dt>-k <a name="man_005fssh_005fagent-_002dk"></a></dt>
<dd><p>Убить текущего агента (заданного переменной окружения SSH_AGENT_PID).
</p>
</dd>
<dt>-P <a name="man_005fssh_005fagent-_002dP"></a></dt>
<dd><p>Укажите шаблонный список допустимых путей для разделяемых библиотек PKCS#11,
             которые можно добавить с помощью опции -s в ssh-add (1). По умолчанию
             разрешена загрузка библиотек PKCS#11 из “/usr/lib/*,/usr/local/lib/*”.
             Библиотеки PKCS#11, которые не соответствуют белому списку, будут отклонены.
             Смотри PATTERNS в ssh_config(5) для описания синтаксиса списка шаблонов.
</p>
</dd>
<dt>-s <a name="man_005fssh_005fagent-_002ds"></a></dt>
<dd><p>Генерация команд оболочки Bourne на стандартный вывод. Это значение по
             умолчанию, если SHELL не выглядит как оболочка в стиле csh.
</p>
</dd>
<dt>-t life <a name="man_005fssh_005fagent-_002dt-life"></a></dt>
<dd><p>Задайте значение по умолчанию для максимального времени жизни идентификаторов,
             добавляемых к агенту. Время жизни может быть указано в секундах или в формате
             времени, указанном в sshd_config (5). Время жизни, указанное для
             идентификатора с помощью ssh-add (1), переопределяет это значение. Без
             этой опции максимальное время жизни по умолчанию - навсегда.
</p></dd>
</dl>
<p>Если указана командная строка, она выполняется как подпроцесс агента. Когда команда
     умирает, агент тоже.
</p>
<p>Идея заключается в том, что агент запускается на локальном ПК пользователя,
     ноутбуке или терминале. Данные аутентификации не нужно хранить на каком-либо другом
     компьютере, и пароли аутентификации никогда не передаются по сети. Однако соединение
     с агентом пересылается через удаленные входы SSH, и пользователь может, таким образом,
     безопасно использовать привилегии, заданные удостоверениями в любом месте сети.
</p>
<p>Существует два основных способа настройки агента: во-первых, агент запускает новую
     подкоманду, в которую экспортируются некоторые переменные среды, например, ssh-agent
     xterm &amp;. Во-вторых, агент печатает необходимые команды оболочки (можно сгенерировать
     синтаксис sh(1) или csh(1)), которые можно оценить в вызывающей оболочке, например,
     eval &lsquo;ssh-agent -s&lsquo; для оболочек типа Борна, таких как sh(1) или ksh(1) и
     eval &lsquo;ssh-agent -c&lsquo; для csh(1) и производных.
</p>
<p>Позже ssh(1) просматривает эти переменные и использует их для установления
     соединения с агентом.
</p>
<p>Агент никогда не отправит закрытый ключ по каналу запроса. Вместо этого агент будет
     выполнять операции, для которых требуется закрытый ключ, а результат будет возвращен
     запрашивающей стороне. Таким образом, частные ключи не предоставляются клиентам,
     использующим агент.
</p>
<p>Создается сокет домена UNIX, и имя этого сокета сохраняется в переменной среды
     SSH_AUTH_SOCK. Сокет доступен только для текущего пользователя. Этот метод легко
     используется пользователем root или другим экземпляром того же пользователя.
</p>
<p>Переменная окружения SSH_AGENT_PID содержит процесс агента ID.
</p>
<p>Агент завершается автоматически, когда команда, заданная в командной строке,
     завершается.
</p>
<p>В Debian ssh-agent устанавливается с установленным битом set-group-id, чтобы
     предотвратить атаки ptrace(2) при получении материала с закрытым ключом. Это имеет
     побочный эффект, так как компоновщик во время выполнения удаляет определенные
     переменные среды, которые могут иметь последствия для безопасности для программ с
     заданным идентификатором, включая LD_PRELOAD, LD_LIBRARY_PATH, и TMPDIR. Если вам
     нужно установить любую из этих переменных среды, вам нужно будет сделать это в
     программе, выполняемой ssh-agent.
</p>
</dd>
<dt>FILES</dt>
<dd><p>$TMPDIR/ssh-XXXXXXXXXX/agent.&lt;ppid&gt;
             Сокеты домена UNIX, используемые для подключения к агенту аутентификации.
             Эти розетки должны быть доступны для чтения только владельцу. Сокеты должны
             автоматически удаляться при выходе из агента.
</p>
</dd>
<dt>SEE ALSO</dt>
<dd><p>ssh(1), ssh-add(1), ssh-keygen(1), sshd(8)
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.
</p>
<p>BSD                            November 30, 2016                           BSD
</p></dd>
</dl>
<hr>
<a name="SSH_002dARGV0"></a>
<div class="header">
<p>
Next: <a href="#SSH_002dKEYGEN" accesskey="n" rel="next">SSH-KEYGEN</a>, Previous: <a href="#SSH_002dAGENT" accesskey="p" rel="prev">SSH-AGENT</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH_002dARGV0-1"></a>
<h2 class="chapter">9 SSH-ARGV0</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh-argv0 — заменяет старое имя команды ssh на обработку имени хоста
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>hostname | user@hostname [-l login_name] [command]
</p>
<p>hostname | user@hostname [-afgknqstvxACNTX1246] [-b bind_address]
     [-c cipher_spec] [-e escape_char] [-i identity_file] [-l login_name]
     [-m mac_spec] [-o option] [-p port] [-F configfile] [-L
     port:host:hostport] [-R port:host:hostport] [-D port] [command]
</p>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh-argv0 заменяет старое имя команды ssh как обработку имени хоста. Если вы
     ссылаетесь на этот скрипт с именем хоста, то выполнение ссылки эквивалентно
     выполнению ssh с этим именем хоста в качестве аргумента. Все остальные аргументы
     передаются в ssh и будут обрабатываться в обычном режиме.
</p>
</dd>
<dt>OPTIONS</dt>
<dd><p>See ssh(1).
</p>
</dd>
<dt>FILES</dt>
<dd><p>See ssh(1).
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.  Jonathan Amery wrote this ssh-argv0 script and the
     associated documentation.
</p>
</dd>
<dt>SEE ALSO</dt>
<dd><p>ssh(1)
</p>
<p>Debian Project                 September 7, 2001                Debian Project
</p></dd>
</dl>


<hr>
<a name="SSH_002dKEYGEN"></a>
<div class="header">
<p>
Next: <a href="#SSH_002dKEYSCAN" accesskey="n" rel="next">SSH-KEYSCAN</a>, Previous: <a href="#SSH_002dARGV0" accesskey="p" rel="prev">SSH-ARGV0</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH_002dKEYGEN-1"></a>
<h2 class="chapter">10 SSH-KEYGEN</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh-keygen — генерация ключа аутентификации, управление и преобразование
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><div class="display">
<pre class="display">     ssh-keygen [<a href="#man_005fssh_005fkeygen-_002dq">-q</a>] [<a href="#man_005fssh_005fkeygen-_002db-bits">-b bits</a>] [<a href="#man_005fssh_005fkeygen-_002dt-dsa-_007c-ecdsa-_007c-ed25519-_007c-rsa-_007c-rsa1">-t dsa | ecdsa | ed25519 | rsa | rsa1</a>]
                [<a href="#man_005fssh_005fkeygen-_002dN-new_005fpassphrase">-N new_passphrase</a>] [<a href="#man_005fssh_005fkeygen-_002dC-comment">-C comment</a>] [<a href="#man_005fssh_005fkeygen-_002df-filename">-f output_keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dp">-p</a> [<a href="#man_005fssh_005fkeygen-_002dP-passphrase">-P passphrase</a>] [<a href="#man_005fssh_005fkeygen-_002dN-new_005fpassphrase">-N new_passphrase</a>] [<a href="#man_005fssh_005fkeygen-_002df-filename">-f keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002di">-i</a> [<a href="#man_005fssh_005fkeygen-_002dm-key_005fformat">-m key_format</a>] [<a href="#man_005fssh_005fkeygen-_002df-filename">-f input_keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002de">-e</a> [<a href="#man_005fssh_005fkeygen-_002dm-key_005fformat">-m key_format</a>] [<a href="#man_005fssh_005fkeygen-_002df-filename">-f input_keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dy">-y</a> [<a href="#man_005fssh_005fkeygen-_002df-filename">-f input_keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dc">-c</a> [<a href="#man_005fssh_005fkeygen-_002dP-passphrase">-P passphrase</a>] [<a href="#man_005fssh_005fkeygen-_002dC-comment">-C comment</a>] [<a href="#man_005fssh_005fkeygen-_002df-filename">-f filename</a>-f keyfile]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dl">-l</a> [<a href="#man_005fssh_005fkeygen-_002dv">-v</a>] [<a href="#man_005fssh_005fkeygen-_002dE-fingerprint_005fhash">-E fingerprint_hash</a>] [<a href="#man_005fssh_005fkeygen-_002df-filename">-f input_keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dB">-B</a> [<a href="#man_005fssh_005fkeygen-_002df-filename">-f input_keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dD-pkcs11">-D pkcs11</a>
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dF-hostname">-F hostname</a> [<a href="#man_005fssh_005fkeygen-_002df-filename">-f known_hosts_file</a>] [<a href="#man_005fssh_005fkeygen-_002dl">-l</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dH">-H</a> [<a href="#man_005fssh_005fkeygen-_002df-filename">-f known_hosts_file</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dR-hostname">-R hostname</a> [<a href="#man_005fssh_005fkeygen-_002df-filename">-f known_hosts_file</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dr-hostname">-r hostname</a> [<a href="#man_005fssh_005fkeygen-_002df-filename">-f input_keyfile</a>] [<a href="#man_005fssh_005fkeygen-_002dg">-g</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dG-output_005ffile">-G output_file</a> [<a href="#man_005fssh_005fkeygen-_002dv">-v</a>] [<a href="#man_005fssh_005fkeygen-_002db-bits">-b bits</a>] [<a href="#man_005fssh_005fkeygen-_002dM-memory">-M memory</a>] [<a href="#man_005fssh_005fkeygen-_002dS-start">-S start_point</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dT-output_005ffile">-T output_file</a> <a href="#man_005fssh_005fkeygen-_002df-filename">-f input_file</a> [<a href="#man_005fssh_005fkeygen-_002dv">-v</a>] [<a href="#man_005fssh_005fkeygen-_002da-rounds">-a rounds</a>] [<a href="#man_005fssh_005fkeygen-_002dJ-num_005flines">-J num_lines</a>]
                [<a href="#man_005fssh_005fkeygen-_002dj-start_005fline">-j start_line</a>] [<a href="#man_005fssh_005fkeygen-_002dK-checkpt">-K checkpt</a>] [<a href="#man_005fssh_005fkeygen-_002dW-generator">-W generator</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002ds-ca_005fkey">-s ca_key</a> <a href="#man_005fssh_005fkeygen-_002dI-certificate_005fidentity">-I certificate_identity</a> [<a href="#man_005fssh_005fkeygen-_002dh">-h</a>] [<a href="#man_005fssh_005fkeygen-_002dn-principals">-n principals</a>]
                [<a href="#man_005fssh_005fkeygen-_002dO-option">-O option</a>] [<a href="#man_005fssh_005fkeygen-_002dV-validity_005finterval">-V validity_interval</a>] [<a href="#man_005fssh_005fkeygen-_002dz-serial_005fnumber">-z serial_number</a>] file ...
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dL">-L</a> [<a href="#man_005fssh_005fkeygen-_002df-filename">-f input_keyfile</a>]
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dA">-A</a>
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dk">-k</a> <a href="#man_005fssh_005fkeygen-_002df-filename">-f krl_file</a> [<a href="#man_005fssh_005fkeygen-_002du">-u</a>] [<a href="#man_005fssh_005fkeygen-_002ds-ca_005fkey">-s ca_public</a>] [<a href="#man_005fssh_005fkeygen-_002dz-serial_005fnumber">-z version_number</a>] file ...
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002dQ">-Q</a> <a href="#man_005fssh_005fkeygen-_002df-filename">-f krl_file file ...</a>
     ssh-keygen <a href="#man_005fssh_005fkeygen-_002do">-o</a>(нет в манах)
</pre></div>
</dd>
<dt>Опции &rsquo;-O&rsquo; параметр сертификата при подписи ключа</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fkeygen_005foptions_005fo-clear">clear</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-force_002dcommand_003dcommand">force-command=command</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-no_002dagent_002dforwarding">no-agent-forwarding</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-no_002dport_002dforwarding">no-port-forwarding</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-no_002dpty">no-pty</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-no_002duser_002drc">no-user-rc</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-no_002dx11_002dforwarding">no-x11-forwarding</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-permit_002dagent_002dforwarding">permit-agent-forwarding</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-permit_002dport_002dforwarding">permit-port-forwarding</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-permit_002dpty">permit-pty</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-permit_002duser_002drc">permit-user-rc</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-permit_002dx11_002dforwarding">permit-x11-forwarding</a>
     <a href="#man_005fssh_005fkeygen_005foptions_005fo-source_002daddress_003daddress_005flist">source-address=address_list</a>
</pre></div>
</dd>
<dt>спецификации KRL</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fkeygen_005fspec_005fkrl-serial_003a-serial_005fnumber_005b_002dserial_005fnumber_005d">serial: serial_number[-serial_number]</a>
     <a href="#man_005fssh_005fkeygen_005fspec_005fkrl-id_003a-key_005fid">id: key_id</a>
     <a href="#man_005fssh_005fkeygen_005fspec_005fkrl-key_003a-public_005fkey">key: public_key</a>
     <a href="#man_005fssh_005fkeygen_005fspec_005fkrl-sha1_003a-public_005fkey">sha1: public_key</a>
</pre></div>
</dd>
<dt>Список файлов ssh_keygen</dt>
<dd><div class="display">
<pre class="display">     <a href="#man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fidentity">~/.ssh/identity</a>
     <a href="#man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fidentity_002epub">~/.ssh/identity.pub</a>
     <a href="#man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fid_005fdsa-_007e_002f_002essh_002fid_005fecdsa-_007e_002f_002essh_002fid_005fed25519-_007e_002f_002essh_002fid_005frsa">~/.ssh/id_dsa  ~/.ssh/id_ecdsa  ~/.ssh/id_ed25519  ~/.ssh/id_rsa</a>
     <a href="#man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fid_005fdsa_002epub-_007e_002f_002essh_002fid_005fecdsa_002epub-_007e_002f_002essh_002fid_005fed25519_002epub-_007e_002f_002essh_002fid_005frsa_002epub">~/.ssh/id_dsa.pub  ~/.ssh/id_ecdsa.pub  ~/.ssh/id_ed25519.pub  ~/.ssh/id_rsa.pub</a>
     <a href="#man_005fssh_005fkeygen_005ffiles-_002fetc_002fssh_002fmoduli">/etc/ssh/moduli</a>
</pre></div>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh-keygen генерирует, управляет и преобразует ключи аутентификации для ssh(1).
     ssh-keygen может создавать ключи для использования протоколами SSH версий 1 и 2.
     Протокол 1 не должен использоваться и предлагается только для поддержки устаревших
     устройств. Он страдает от ряда криптографических недостатков и не поддерживает
     многие расширенные функции, доступные для протокола 2.
</p>
<p>Тип генерируемого ключа указывается с помощью опции -t. Если вызывается без
     каких-либо аргументов, ssh-keygen сгенерирует ключ RSA для использования в
     соединениях протокола 2 SSH.
</p>
<p>ssh-keygen также используется для генерации групп для использования в
     Diffie-Hellman групповом обмене (DH-GEX). Смотрите раздел MODULI GENERATION
     для деталей.
</p>
<p>Наконец, ssh-keygen может использоваться для генерации и обновления списков отзыва
     ключей, а также для проверки того, были ли данные ключи отозваны одним из них.
     Смотрите раздел KEY REVOCATION LISTS для деталей.
</p>
<p>Обычно каждый пользователь, желающий использовать SSH с аутентификацией с
     открытым ключом, запускает это один раз, чтобы создать ключ аутентификации
     в ~/.ssh/identity, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 или
     ~/.ssh/id_rsa. Кроме того, системный администратор может использовать это
     для генерации ключей хоста.
</p>
<p>Обычно эта программа генерирует ключ и запрашивает файл, в котором хранится
     закрытый ключ. Открытый ключ хранится в файле с тем же именем, но с добавлением
     “.pub”. Программа также запрашивает пароль. Фраза-пароль может быть пустой, чтобы
     указать, что фраза-пароль отсутствует (ключи хоста должны иметь пустую фразу-пароль),
     или это может быть строка произвольной длины. Фраза-пароль похожа на пароль, за
     исключением того, что это может быть фраза с набором слов, знаков препинания, цифр,
     пробелов или любой строкой символов, которую вы хотите. Хорошие парольные фразы имеют
     длину 10-30 символов, не являются простыми предложениями или иным образом легко
     угадываемыми (английская проза содержит только 1-2 бита энтропии на символ и дает
     очень плохие парольные фразы) и содержит комбинацию прописных и строчных букв,
     цифр, и не алфавитно-цифровые символы. Фраза-пароль может быть изменена позже с
     помощью опции -p.
</p>
<p>Нет способа восстановить потерянную фразу-пароль. Если ключевая фраза утеряна или
     забыта, необходимо сгенерировать новый ключ и скопировать соответствующий открытый
     ключ на другие машины.
</p>
<p>Для ключей RSA1 в файле ключей также имеется поле комментария, которое предназначено
     только для удобства пользователя, чтобы помочь идентифицировать ключ. Комментарий
     может сказать, для чего нужен ключ, или что-то полезное. Комментарий инициализируется
     в “user@host” при создании ключа, но может быть изменен с помощью опции -c.
</p>
<p>После того, как ключ сгенерирован, ниже приведены подробные инструкции о том, где
     ключи должны быть размещены для активации.
</p>
<p>Возможны следующие варианты:
</p><dl compact="compact">
<dt>-A <a name="man_005fssh_005fkeygen-_002dA"></a></dt>
<dd><p>Для каждого из типов ключей (rsa1, rsa, dsa, ecdsa и ed25519), для которых
     	     ключи хоста не существуют, создайте ключи хоста с использованием пути к файлу
	     ключа по умолчанию, пустой парольной фразы, битов по умолчанию для типа ключа
	     и комментария по умолчанию. Это используется сценариями системного
	     администрирования для генерации новых ключей хоста.
</p>
</dd>
<dt>-a rounds <a name="man_005fssh_005fkeygen-_002da-rounds"></a></dt>
<dd><p>При сохранении закрытого ключа нового формата (то есть ключа ed25519 или
	     любого ключа протокола SSH 2, когда установлен флаг -o), эта опция указывает
	     количество используемых раундов KDF (функция вывода ключа). Более высокие
	     числа приводят к более медленной проверке парольной фразы и повышению
	     устойчивости к взлому паролем (в случае кражи ключей).
</p>
<p>При проверке кандидатов в DH-GEX (с помощью команды -T). Эта опция
	     указывает количество тестов простоты для выполнения.
</p>
</dd>
<dt>-B <a name="man_005fssh_005fkeygen-_002dB"></a></dt>
<dd><p>Показать дайджест пузыря указанного файла с закрытым или открытым ключом.
</p>
</dd>
<dt>-b bits <a name="man_005fssh_005fkeygen-_002db-bits"></a></dt>
<dd><p>Определяет количество бит в ключе для создания. Для ключей RSA минимальный
	     размер составляет 1024 бита, а по умолчанию - 2048 бит. Обычно 2048 бит
	     считается достаточным. Ключи DSA должны иметь длину 1024 бита, как указано в
	     FIPS 186-2. Для ключей ECDSA флаг -b определяет длину ключа, выбирая один из
	     трех размеров эллиптической кривой: 256, 384 или 521 бит. Попытка использовать
	     битовые длины, отличные от этих трех значений, для ключей ECDSA потерпит
	     неудачу. Ключи Ed25519 имеют фиксированную длину, и флаг -b будет
	     игнорироваться.
</p>
</dd>
<dt>-C comment <a name="man_005fssh_005fkeygen-_002dC-comment"></a></dt>
<dd><p>Предоставляет новый комментарий.
</p>
</dd>
<dt>-c <a name="man_005fssh_005fkeygen-_002dc"></a></dt>
<dd><p>Запрашивает изменение комментария в файлах с закрытым и открытым ключами.
     	     Эта операция поддерживается только для ключей RSA1. Программа запросит файл,
	     содержащий закрытые ключи, парольную фразу, если ключ есть, и новый
	     комментарий.
</p>
</dd>
<dt>-D pkcs11 <a name="man_005fssh_005fkeygen-_002dD-pkcs11"></a></dt>
<dd><p>Загрузите открытые ключи RSA, предоставляемые общей библиотекой PKCS#11
	     pkcs11. При использовании в сочетании с -s этот параметр указывает, что ключ
	     CA находится в токене PKCS#11 (подробности см. В разделе CERTIFICATES).
</p>
</dd>
<dt>-E fingerprint_hash <a name="man_005fssh_005fkeygen-_002dE-fingerprint_005fhash"></a></dt>
<dd><p>Определяет алгоритм хеширования, используемый при отображении отпечатков
	     клавиш. Допустимые варианты: “md5” и “sha256”. По умолчанию используется
	     “sha256”.
</p>
</dd>
<dt>-e <a name="man_005fssh_005fkeygen-_002de"></a></dt>
<dd><p>Эта опция будет читать частный или открытый файл ключа OpenSSH и печатать,
     	     чтобы выводить ключ в одном из форматов, указанных параметром -m. Формат
	     экспорта по умолчанию - “RFC4716”. Эта опция позволяет экспортировать ключи
	     OpenSSH для использования другими программами, включая несколько коммерческих
	     реализаций SSH.
</p>
</dd>
<dt>-F hostname <a name="man_005fssh_005fkeygen-_002dF-hostname"></a></dt>
<dd><p>Найдите указанное имя хоста в файле known_hosts, в котором перечислены все
	     найденные совпадения. Эта опция полезна для поиска имен или адресов
	     хэшированных хостов и может также использоваться вместе с опцией -H для
	     вывода найденных ключей в хешированном формате.
</p>
</dd>
<dt>-f filename <a name="man_005fssh_005fkeygen-_002df-filename"></a></dt>
<dd><p>Определяет имя файла ключа.
</p>
</dd>
<dt>-G output_file <a name="man_005fssh_005fkeygen-_002dG-output_005ffile"></a></dt>
<dd><p>Генерация кандидатов простых чисел для DH-GEX. Эти простые числа должны
	     быть проверены на безопасность (с использованием опции -T) перед
	     использованием.
</p>
</dd>
<dt>-g <a name="man_005fssh_005fkeygen-_002dg"></a></dt>
<dd><p>Используйте общий формат DNS при печати записей ресурсов отпечатков
	     пальцев с помощью команды -r.
</p>
</dd>
<dt>-H <a name="man_005fssh_005fkeygen-_002dH"></a></dt>
<dd><p>Хешировать файл known_hosts. Это заменяет все имена хостов и адреса
	     хешированными представлениями в указанном файле; исходный контент
	     перемещается в файл с суффиксом .old. Эти хэши могут обычно использоваться
	     ssh и sshd, но они не раскрывают идентифицирующую информацию, если содержимое
	     файла будет раскрыто. Эта опция не изменяет существующие хэшированные имена
	     хостов и поэтому безопасна для использования с файлами, которые смешивают
	     хэшированные и нехэшированные имена.
</p>
</dd>
<dt>-h <a name="man_005fssh_005fkeygen-_002dh"></a></dt>
<dd><p>При подписании ключа создайте сертификат хоста вместо сертификата
	     пользователя. Пожалуйста, смотрите раздел CERTIFICATES для деталей.
</p>
</dd>
<dt>-I certificate_identity <a name="man_005fssh_005fkeygen-_002dI-certificate_005fidentity"></a></dt>
<dd><p>Укажите идентификатор ключа при подписании открытого ключа. Пожалуйста,
	     смотрите раздел CERTIFICATES для деталей.
</p>
</dd>
<dt>-i <a name="man_005fssh_005fkeygen-_002di"></a></dt>
<dd><p>Этот параметр будет считывать незашифрованный файл закрытого (или открытого)
	     ключа в формате, заданном параметром -m, и печатать совместимый с OpenSSH
	     закрытый (или открытый) ключ в стандартный вывод. Эта опция позволяет
	     импортировать ключи из другого программного обеспечения, включая несколько
	     коммерческих реализаций SSH. Формат импорта по умолчанию - “RFC4716”.
</p>
</dd>
<dt>-J num_lines <a name="man_005fssh_005fkeygen-_002dJ-num_005flines"></a></dt>
<dd><p>Выйдите из экрана после указанного количества строк во время проверки
	     кандидатов в DH с помощью опции -T.
</p>
</dd>
<dt>-j start_line <a name="man_005fssh_005fkeygen-_002dj-start_005fline"></a></dt>
<dd><p>Начать проверку с указанного номера строки при выполнении проверки
	     кандидатов DH с помощью опции -T.
</p>
</dd>
<dt>-K checkpt <a name="man_005fssh_005fkeygen-_002dK-checkpt"></a></dt>
<dd><p>Запишите последнюю обработанную строку в файл checkpt при выполнении
	     проверки кандидатов на DH с помощью опции -T. Это будет использоваться для
	     пропуска строк во входном файле, которые уже были обработаны, если
	     задание будет перезапущено.
</p>
</dd>
<dt>-k <a name="man_005fssh_005fkeygen-_002dk"></a></dt>
<dd><p>Создайте файл KRL. В этом режиме ssh-keygen сгенерирует файл KRL в месте,
	     указанном с помощью флага -f, который аннулирует каждый ключ или сертификат,
	     представленный в командной строке. Ключи/сертификаты, которые должны быть
	     отозваны, могут быть указаны в файле открытого ключа или в формате,
	     описанном в разделе KEY REVOCATION LISTS.
</p>
</dd>
<dt>-L <a name="man_005fssh_005fkeygen-_002dL"></a></dt>
<dd><p>Печатает содержимое одного или нескольких сертификатов.
</p>
</dd>
<dt>-l <a name="man_005fssh_005fkeygen-_002dl"></a></dt>
<dd><p>Показать отпечаток указанного файла открытого ключа. Частные ключи RSA1
	     также поддерживаются. Для ключей RSA и DSA ssh-keygen пытается найти
	     соответствующий файл открытого ключа и печатает его отпечаток. В сочетании
	     с -v арт-представление ключа ASCII предоставляется вместе
	     с отпечатком пальца.
</p>
</dd>
<dt>-M memory <a name="man_005fssh_005fkeygen-_002dM-memory"></a></dt>
<dd><p>Укажите объем памяти, который будет использоваться (в мегабайтах)
	     при генерации модулей-кандидатов для DH-GEX.
</p>
</dd>
<dt>-m key_format <a name="man_005fssh_005fkeygen-_002dm-key_005fformat"></a></dt>
<dd><p>Укажите формат ключа для параметров преобразования -i (import) или
	     -e (export). Поддерживаются следующие форматы ключей: «RFC4716»
	     (открытый или закрытый ключ RFC 4716/SSH2), “PKCS8”
	     (открытый ключ PEM PKCS8) или “PEM” (открытый ключ PEM). Формат
	     преобразования по умолчанию - “RFC4716”.
</p>
</dd>
<dt>-N new_passphrase <a name="man_005fssh_005fkeygen-_002dN-new_005fpassphrase"></a></dt>
<dd><p>Предоставляет новую фразу-пароль.
</p>
</dd>
<dt>-n principals <a name="man_005fssh_005fkeygen-_002dn-principals"></a></dt>
<dd><p>Укажите одного или нескольких участников (имена пользователей или хостов),
	     которые будут включены в сертификат при подписании ключа. Можно указать
	     несколько принципов, разделенных запятыми. Пожалуйста, смотрите раздел
	     CERTIFICATES для деталей.
</p>
</dd>
<dt>-O option <a name="man_005fssh_005fkeygen-_002dO-option"></a></dt>
<dd><p>Укажите параметр сертификата при подписи ключа. Эта опция может быть
	     указана несколько раз. Пожалуйста, смотрите раздел CERTIFICATES для
	     деталей. Опции, которые действительны для пользовательских сертификатов:
</p><dl compact="compact">
<dt>clear <a name="man_005fssh_005fkeygen_005foptions_005fo-clear"></a></dt>
<dd><p>Очистите все разрешенные разрешения. Это полезно для очистки набора
		     разрешений по умолчанию, поэтому разрешения можно добавлять по
		     отдельности.
</p>
</dd>
<dt>force-command=command <a name="man_005fssh_005fkeygen_005foptions_005fo-force_002dcommand_003dcommand"></a></dt>
<dd><p>Принудительно выполняет команду вместо любой оболочки или команды,
		     указанной пользователем, когда сертификат используется для
		     аутентификации.
</p>
</dd>
<dt>no-agent-forwarding <a name="man_005fssh_005fkeygen_005foptions_005fo-no_002dagent_002dforwarding"></a></dt>
<dd><p>Отключить пересылку ssh-agent(1) (разрешено по умолчанию).
</p>
</dd>
<dt>no-port-forwarding <a name="man_005fssh_005fkeygen_005foptions_005fo-no_002dport_002dforwarding"></a></dt>
<dd><p>Отключить переадресацию портов (разрешено по умолчанию).
</p>
</dd>
<dt>no-pty <a name="man_005fssh_005fkeygen_005foptions_005fo-no_002dpty"></a></dt>
<dd><p>Отключить выделение PTY (разрешено по умолчанию).
</p>
</dd>
<dt>no-user-rc <a name="man_005fssh_005fkeygen_005foptions_005fo-no_002duser_002drc"></a></dt>
<dd><p>Отключить выполнение ~/.ssh/rc с помощью sshd(8)
		     (разрешено по умолчанию).
</p>
</dd>
<dt>no-x11-forwarding <a name="man_005fssh_005fkeygen_005foptions_005fo-no_002dx11_002dforwarding"></a></dt>
<dd><p>Отключить пересылку X11 (разрешено по умолчанию).
</p>
</dd>
<dt>permit-agent-forwarding <a name="man_005fssh_005fkeygen_005foptions_005fo-permit_002dagent_002dforwarding"></a></dt>
<dd><p>Позволяет пересылку ssh-agent(1).
</p>
</dd>
<dt>permit-port-forwarding <a name="man_005fssh_005fkeygen_005foptions_005fo-permit_002dport_002dforwarding"></a></dt>
<dd><p>Позволяет переадресацию портов.
</p>
</dd>
<dt>permit-pty <a name="man_005fssh_005fkeygen_005foptions_005fo-permit_002dpty"></a></dt>
<dd><p>Разрешает распределение PTY.
</p>
</dd>
<dt>permit-user-rc <a name="man_005fssh_005fkeygen_005foptions_005fo-permit_002duser_002drc"></a></dt>
<dd><p>Позволяет выполнять ~/.ssh/rc с помощью sshd(8).
</p>
</dd>
<dt>permit-x11-forwarding <a name="man_005fssh_005fkeygen_005foptions_005fo-permit_002dx11_002dforwarding"></a></dt>
<dd><p>Позволяет пересылку X11.
</p>
</dd>
<dt>source-address=address_list <a name="man_005fssh_005fkeygen_005foptions_005fo-source_002daddress_003daddress_005flist"></a></dt>
<dd><p>Ограничьте исходные адреса, с которых сертификат считается
		     действительным. address_list - разделенный запятыми список из
		     одной или нескольких пар address/netmask в формате CIDR.
</p>
<p>В настоящее время никакие опции не действительны для ключей хоста.
</p></dd>
</dl>
</dd>
<dt>-o <a name="man_005fssh_005fkeygen-_002do"></a></dt>
<dd><p>Заставляет ssh-keygen сохранять закрытые ключи, используя новый формат
	     OpenSSH, а не более совместимый формат PEM. Новый формат обладает повышенной
	     устойчивостью к взлому паролей, но не поддерживается версиями OpenSSH до 6.5.
	     Ключи Ed25519 всегда используют новый формат закрытого ключа.
</p>
</dd>
<dt>-P passphrase <a name="man_005fssh_005fkeygen-_002dP-passphrase"></a></dt>
<dd><p>Предоставляет (старый) пароль.
</p>
</dd>
<dt>-p <a name="man_005fssh_005fkeygen-_002dp"></a></dt>
<dd><p>Запрашивает изменение ключевой фразы файла закрытого ключа вместо создания
	     нового закрытого ключа. Программа запросит файл, содержащий закрытый ключ,
	     старую парольную фразу и дважды новую парольную фразу.
</p>
</dd>
<dt>-Q <a name="man_005fssh_005fkeygen-_002dQ"></a></dt>
<dd><p>Проверьте, были ли ключи отозваны в KRL.
</p>
</dd>
<dt>-q <a name="man_005fssh_005fkeygen-_002dq"></a></dt>
<dd><p>тихое ssh-keygen.
</p>
</dd>
<dt>-R hostname <a name="man_005fssh_005fkeygen-_002dR-hostname"></a></dt>
<dd><p>Удаляет все ключи, принадлежащие имени хоста, из файла known_hosts. Эта
	     опция полезна для удаления хэшированных хостов (см. Опцию -H выше).
</p>
</dd>
<dt>-r hostname <a name="man_005fssh_005fkeygen-_002dr-hostname"></a></dt>
<dd><p>Распечатайте запись ресурса отпечатка SSHFP с именем hostname для
	     указанного файла открытого ключа.
</p>
</dd>
<dt>-S start <a name="man_005fssh_005fkeygen-_002dS-start"></a></dt>
<dd><p>Укажите начальную точку (в шестнадцатеричном формате) при создании
	     модулей-кандидатов для DH-GEX.
</p>
</dd>
<dt>-s ca_key <a name="man_005fssh_005fkeygen-_002ds-ca_005fkey"></a></dt>
<dd><p>Сертифицируйте (подпишите) открытый ключ, используя указанный ключ CA.
	     Пожалуйста, смотрите раздел CERTIFICATES для деталей.
</p>
<p>При генерации KRL -s указывает путь к файлу открытого ключа CA, который
	     используется для отзыва сертификатов напрямую по ключу ID или серийному
	     номеру. Смотрите раздел KEY REVOCATION LISTS для подробностей.
</p>
</dd>
<dt>-T output_file <a name="man_005fssh_005fkeygen-_002dT-output_005ffile"></a></dt>
<dd><p>Проверьте безопасность кандидатов на обмен с группой DH (генерируется с
	     помощью опции -G).
</p>
</dd>
<dt>-t dsa | ecdsa | ed25519 | rsa | rsa1 <a name="man_005fssh_005fkeygen-_002dt-dsa-_007c-ecdsa-_007c-ed25519-_007c-rsa-_007c-rsa1"></a></dt>
<dd><p>Определяет тип ключа для создания. Возможные значения: “rsa1” для версии
	     протокола 1 и “dsa”, “ecdsa”, “ed25519”, или “rsa” для версии протокола 2.
</p>
</dd>
<dt>-u <a name="man_005fssh_005fkeygen-_002du"></a></dt>
<dd><p>Обновите KRL. При указании с помощью -k ключи, перечисленные через
	     командную строку, добавляются к существующему KRL, а не к создаваемому
	     новому KRL.
</p>
</dd>
<dt>-V validity_interval <a name="man_005fssh_005fkeygen-_002dV-validity_005finterval"></a></dt>
<dd><p>Укажите срок действия при подписании сертификата. Интервал действия может
	     состоять из одного времени, указывая на то, что сертификат действителен,
	     начиная с настоящего момента и заканчивая указаным временем, или может
	     состоять из двух , разделенных двоеточием, для указания явного интервала
	     времени. Время начала может быть указано как дата в формате YYYYMMDD,
	     как время в формате YYYYMMDDHHMMSS или относительное время
	     (к текущему времени), состоящее из знака минус, за которым следует
	     относительное время в формате, описанном в разделе TIME FORMATS
	     sshd_config(5). Время окончания может быть указано в виде даты
	     YYYYMMDD, времени YYYYMMDDHHMMSS или относительного времени,
	     начинающегося с символа плюс.
</p>
<p>Например: “+52w1d” (действует с настоящего момента до 52 недель и
	     один день), “-4w:+4w” (действует с четырех недель до четырех недель с
	     этого момента), “20100101123000:20110101123000” (действует с 12:30 1 января
	     2010 года и до 12:30 , 1 января 2011 г.), “-1d:20110101” (действует
	     со вчерашнего дня до полуночи 1 января 2011 г.).
</p>
</dd>
<dt>-v <a name="man_005fssh_005fkeygen-_002dv"></a></dt>
<dd><p>Детальный режим. Заставляет ssh-keygen печатать отладочные сообщения о его
	     ходе. Это полезно для отладки генерации модулей. Несколько опций -v
	     увеличивают многословие. Максимум 3.
</p>
</dd>
<dt>-W generator <a name="man_005fssh_005fkeygen-_002dW-generator"></a></dt>
<dd><p>Укажите желаемый generator при тестировании модулей-кандидатов
	     для DH-GEX.
</p>
</dd>
<dt>-y <a name="man_005fssh_005fkeygen-_002dy"></a></dt>
<dd><p>Эта опция будет читать приватный файл формата OpenSSH и печатать
	     открытый ключ OpenSSH на стандартный вывод.
</p>
</dd>
<dt>-z serial_number <a name="man_005fssh_005fkeygen-_002dz-serial_005fnumber"></a></dt>
<dd><p>Указывает серийный номер, который должен быть встроен в сертификат, чтобы
	     отличить этот сертификат от других и того же CA. Серийный номер по
	     умолчанию - ноль.
</p>
<p>При генерации KRL флаг -z используется для указания номера версии KRL.
</p></dd>
</dl>
</dd>
<dt>MODULI GENERATION</dt>
<dd><p>ssh-keygen может использоваться для генерации групп для протокола Diffie-Hellman
     Group Exchange (DH-GEX). Генерация этих групп представляет собой двухэтапный
     процесс: во-первых, простые числа кандидатов генерируются с использованием быстрого,
     но интенсивного процесса памяти. Затем эти простые числа проверяются на пригодность
     (процесс, интенсивно использующий процессор).
</p>
<p>Генерация простых чисел выполняется с помощью опции -G. Желаемая длина простых
     чисел может быть указана опцией -b. Например:
</p><div class="display">
<pre class="display">           # ssh-keygen -G moduli-2048.candidates -b 2048
</pre></div>
<p>По умолчанию поиск простых чисел начинается в произвольной точке в нужном диапазоне
     длин. Это может быть отменено с помощью опции -S, которая указывает другую
     начальную точку (в шестнадцатеричном формате).
</p>
<p>Как только набор кандидатов был сгенерирован, они должны быть проверены на
     соответствие. Это может быть выполнено с использованием опции -T. В этом режиме
     ssh-keygen будет считывать кандидатов из стандартного ввода (или файла, указанного
     с помощью опции -f). Например:
</p><div class="display">
<pre class="display">           # ssh-keygen -T moduli-2048 -f moduli-2048.candidates
</pre></div>
<p>По умолчанию каждый кандидат будет подвергнут 100 тестам на примитивность. Это
     может быть отменено с помощью опции -a. Значение генератора DH будет выбрано
     автоматически для рассматриваемого простого числа. Если требуется конкретный
     генератор, он может быть запрошен с использованием опции -W. Допустимые значения
     генератора: 2, 3 и 5.
</p>
<p>Экранированные группы DH могут быть установлены в /etc/ssh/moduli. Важно,
     чтобы этот файл содержал модули с диапазоном битовых длин и чтобы оба конца
     соединения имели общие модули.
</p>
</dd>
<dt>CERTIFICATES</dt>
<dd><p>ssh-keygen поддерживает подписывание ключей для создания сертификатов, которые
     могут использоваться для аутентификации пользователя или хоста. Сертификаты состоят
     из открытого ключа, некоторой идентификационной информации, нуля или более основных
     (пользователей или хостов) имен и набора параметров, которые подписаны ключом (CA)
     центра сертификации. Клиенты или серверы могут доверять только ключу CA и проверять
     его подпись на сертификате, а не доверять многим ключам user/host. Обратите внимание,
     что сертификаты OpenSSH - это другой и намного более простой формат по сравнению с
     сертификатами X.509, используемыми в ssl(8).
</p>
<p>ssh-keygen поддерживает два типа сертификатов: user и host. Пользователь удостоверяет
     подлинность пользователей на серверах, в то время как сертификаты узлов проверяют
     подлинность серверов на пользователях. Чтобы создать сертификат пользователя:
</p><div class="display">
<pre class="display">           $ ssh-keygen -s /path/to/ca_key -I key_id /path/to/user_key.pub
</pre></div>
<p>Полученный сертификат будет помещен в /path/to/user_key-cert.pub. Для
     сертификата хоста требуется опция -h:
</p><div class="display">
<pre class="display">           $ ssh-keygen -s /path/to/ca_key -I key_id -h /path/to/host_key.pub
</pre></div>
<p>Сертификат хоста будет выведен на /path/to/host_key-cert.pub.
</p>
<p>Для подписи можно использовать ключ CA, хранящийся в токене PKCS#11, предоставив
     библиотеку токенов с помощью -D и определив ключ CA, предоставив его открытую
     половину в качестве аргумента для -s:
</p><div class="display">
<pre class="display">           $ ssh-keygen -s ca_key.pub -D libpkcs11.so -I key_id user_key.pub
</pre></div>
<p>Во всех случаях key_id является &quot;key identifier&quot;, который регистрируется
     сервером, когда сертификат используется для аутентификации.
</p>
<p>Сертификаты могут быть ограничены, чтобы быть действительными для набора основных
     (user/host) имен. По умолчанию сгенерированные сертификаты действительны для всех
     пользователей или хостов. Чтобы сгенерировать сертификат для указанного набора
     принципов:
</p><div class="display">
<pre class="display">           $ ssh-keygen -s ca_key -I key_id -n user1,user2 user_key.pub
           $ ssh-keygen -s ca_key -I key_id -h -n host.domain host_key.pub
</pre></div>
<p>Дополнительные ограничения на действительность и использование пользовательских
     сертификатов могут быть указаны через параметры сертификатов. Параметр сертификата
     может отключить функции сеанса SSH, может быть действительным только при
     представлении с определенных адресов источника или может принудительно использовать
     определенную команду. Список допустимых параметров сертификата см. В документации
     к параметру -O выше.
</p>
<p>Наконец, сертификаты могут быть определены со сроком действия. Опция -V позволяет
     указать время начала и окончания сертификата. Сертификат, представленный за
     пределами этого диапазона, не будет считаться действительным. По умолчанию
     сертификаты действительны с эпохи UNIX до далекого будущего.
</p>
<p>Для сертификатов, которые будут использоваться для аутентификации пользователя или
     хоста, публичному ключу CA должен доверять sshd(8) или ssh(1). Пожалуйста,
     обратитесь к этим страницам руководства для деталей.
</p>
</dd>
<dt>KEY REVOCATION LISTS</dt>
<dd><p>ssh-keygen может управлять форматом OpenSSH Key Revocation Lists (списки отзыва ключей)
     (KRLs). Эти двоичные файлы определяют ключи или сертификаты, которые должны быть
     отозваны, в компактном формате, занимая всего один бит на сертификат, если они
     отозваны по серийному номеру.
</p>
<p>KRL могут генерироваться с использованием флага -k. Эта опция читает один или
     несколько файлов из командной строки и генерирует новый KRL. Файлы могут содержать
     спецификацию KRL (см. Ниже) или открытые ключи, по одному в каждой строке. Простые
     открытые ключи аннулируются путем перечисления их хэша или содержимого в KRL и
     сертификатов, отозванных по серийному номеру или ключу ID (если серийный номер
     равен нулю или отсутствует).
</p>
<p>Отзыв ключей с использованием спецификации KRL предлагает явный контроль над
     типами записей, используемых для отзыва ключей, и может использоваться для прямого
     отзыва сертификатов по серийному номеру или ключу ID без наличия полного исходного
     сертификата под рукой. Спецификация KRL состоит из строк, содержащих одну из
     следующих директив, за которыми следует двоеточие, и некоторая информация,
     которая относится к директивам.
</p><dl compact="compact">
<dt>serial: serial_number[-serial_number] <a name="man_005fssh_005fkeygen_005fspec_005fkrl-serial_003a-serial_005fnumber_005b_002dserial_005fnumber_005d"></a></dt>
<dd><p>Аннулирует сертификат с указанным серийным номером. Серийные числа являются
	     значениями 64-bit, не включая ноль, и могут быть выражены в десятичном,
	     шестнадцатеричном или восьмеричном виде. Если заданы два серийных номера,
	     разделенных дефисом, то диапазон серийных номеров, включая и между ними,
	     аннулируется. Ключ CA должен быть указан в командной строке ssh-keygen с
	     использованием параметра -s.
</p>
</dd>
<dt>id: key_id <a name="man_005fssh_005fkeygen_005fspec_005fkrl-id_003a-key_005fid"></a></dt>
<dd><p>Отзывает сертификат с указанным ключом ID string. Ключ CA должен быть
	     указан в командной строке ssh-keygen с использованием параметра -s.
</p>
</dd>
<dt>key: public_key <a name="man_005fssh_005fkeygen_005fspec_005fkrl-key_003a-public_005fkey"></a></dt>
<dd><p>Отменяет указанный ключ. Если сертификат указан в списке, то он отзывается
	     как простой открытый ключ.
</p>
</dd>
<dt>sha1: public_key <a name="man_005fssh_005fkeygen_005fspec_005fkrl-sha1_003a-public_005fkey"></a></dt>
<dd><p>Отменяет указанный ключ по его хэшу SHA1.
</p></dd>
</dl>
<p>KRLs может быть обновлен с использованием флага -u в дополнение к -k. Когда
     указана эта опция, ключи, перечисленные через командную строку, объединяются в KRL,
     добавляя к уже существующим.
</p>
<p>Также с учетом KRL можно проверить, отзывает ли он конкретный ключ (или ключи).
     Флаг -Q будет запрашивать существующий KRL, проверяя каждый ключ, указанный в
     командной строке. Если какой-либо ключ, указанный в командной строке, был отозван
     (или возникла ошибка), то ssh-keygen завершит работу с ненулевым состоянием выхода.
     Статус нулевого выхода будет возвращен только в том случае, если ключ не был отозван.
</p>
</dd>
<dt>FILES</dt>
<dd><dl compact="compact">
<dt>~/.ssh/identity <a name="man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fidentity"></a></dt>
<dd><p>Содержит протокол аутентификации RSA версии 1 пользователя. Этот файл не
	     должен быть доступен для чтения никому, кроме пользователя. Можно указать
	     фразу-пароль при генерации ключа; эта фраза-пароль будет использоваться для
	     шифрования частной части этого файла с использованием 3DES. Ssh-keygen
	     автоматически не обращается к этому файлу, но он предлагается в качестве
	     файла по умолчанию для закрытого ключа. ssh(1) прочитает этот файл при
	     попытке входа в систему.
</p>
</dd>
<dt>~/.ssh/identity.pub <a name="man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fidentity_002epub"></a></dt>
<dd><p>Содержит открытый ключ протокола RSA версии 1 для аутентификации. Содержимое
	     этого файла должно быть добавлено в ~/.ssh/authorized_keys на всех машинах,
	     где пользователь хочет войти в систему с использованием аутентификации RSA.
	     Нет необходимости хранить содержимое этого файла в секрете.
</p></dd>
<dt>~/.ssh/id_dsa  ~/.ssh/id_ecdsa  ~/.ssh/id_ed25519  ~/.ssh/id_rsa <a name="man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fid_005fdsa-_007e_002f_002essh_002fid_005fecdsa-_007e_002f_002essh_002fid_005fed25519-_007e_002f_002essh_002fid_005frsa"></a></dt>
<dd><p>Содержит протокол аутентификации пользователя DSA версии 2, ECDSA, Ed25519
	     или RSA. Этот файл не должен быть доступен для чтения никому, кроме
	     пользователя. Можно указать фразу-пароль при генерации ключа; эта
	     фраза-пароль будет использоваться для шифрования приватной части этого файла
	     с использованием 128-битного AES. Ssh-keygen автоматически не обращается к
	     этому файлу, но он предлагается в качестве файла по умолчанию для закрытого
	     ключа. ssh(1) прочитает этот файл при попытке входа в систему.
</p></dd>
<dt>~/.ssh/id_dsa.pub  ~/.ssh/id_ecdsa.pub  ~/.ssh/id_ed25519.pub  ~/.ssh/id_rsa.pub <a name="man_005fssh_005fkeygen_005ffiles-_007e_002f_002essh_002fid_005fdsa_002epub-_007e_002f_002essh_002fid_005fecdsa_002epub-_007e_002f_002essh_002fid_005fed25519_002epub-_007e_002f_002essh_002fid_005frsa_002epub"></a></dt>
<dd><p>Содержит протокол версии 2 DSA, ECDSA, Ed25519 или открытый ключ RSA для
	     аутентификации. Содержимое этого файла должно быть добавлено в
	     ~/.ssh/authorized_keys на всех машинах, где пользователь хочет войти в
	     систему с использованием аутентификации с открытым ключом. Нет необходимости
	     хранить содержимое этого файла в секрете.
</p>
</dd>
<dt>/etc/ssh/moduli <a name="man_005fssh_005fkeygen_005ffiles-_002fetc_002fssh_002fmoduli"></a></dt>
<dd><p>Содержит группы Diffie-Hellman, используемые для DH-GEX. Формат файла
	     описан в moduli(5).
</p></dd>
</dl>
</dd>
<dt>SEE ALSO</dt>
<dd><p>ssh(1), ssh-add(1), ssh-agent(1), moduli(5), sshd(8)
</p>
<p>Формат файла открытого ключа Secure Shell (SSH), RFC 4716, 2006.
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.
</p>
<p>BSD                            February 17, 2016                           BSD
</p></dd>
</dl>

<hr>
<a name="SSH_002dKEYSCAN"></a>
<div class="header">
<p>
Next: <a href="#SSH_002dKEYSIGN" accesskey="n" rel="next">SSH-KEYSIGN</a>, Previous: <a href="#SSH_002dKEYGEN" accesskey="p" rel="prev">SSH-KEYGEN</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH_002dKEYSCAN-1"></a>
<h2 class="chapter">11 SSH-KEYSCAN</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh-keyscan — собрать открытые ключи ssh
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>ssh-keyscan [-46cHv] [-f file] [-p port] [-T timeout] [-t type]
                 [host | addrlist namelist] ...
</p>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh-keyscan - это утилита для сбора открытых ключей хоста ssh для ряда хостов. Она
     была разработана, чтобы помочь в создании и проверке файлов ssh_known_hosts.
     ssh-keyscan предоставляет минимальный интерфейс, подходящий для использования
     скриптами оболочки и perl.
</p>
<p>ssh-keyscan использует неблокирующий сокет I/O для связи с максимально возможным
     количеством параллельных хостов, поэтому он очень эффективен. Ключи от домена
     хостов 1,000 могут быть собраны за десятки секунд, даже когда некоторые из этих
     хостов не работают или не запускают ssh. Для сканирования не требуется вход в систему
     для проверки компьютеров, а также процесс сканирования не требует шифрования.
</p>
<p>Возможны следующие варианты:
</p><dl compact="compact">
<dt>-4</dt>
<dd><p>Заставляет ssh-keyscan использовать только адреса IPv4.
</p>
</dd>
<dt>-6</dt>
<dd><p>Заставляет ssh-keyscan использовать только адреса IPv6.
</p>
</dd>
<dt>-c</dt>
<dd><p>Запросите сертификаты от целевых хостов вместо простых ключей.
</p>
</dd>
<dt>-f file</dt>
<dd><p>Чтение пар файлов хоста или “addrlist namelist” из файла, по одной на строку.
             Если вместо имени файла указано -, ssh-keyscan будет считывать хосты или
             пары “addrlist namelist” из стандартного ввода.
</p>
</dd>
<dt>-H</dt>
<dd><p>Хэшируйте все имена хостов и адреса в выводе. Хеш-имена могут обычно
             использоваться ssh и sshd, но они не раскрывают идентификационную информацию,
             если содержимое файла будет раскрыто.
</p>
</dd>
<dt>-p port</dt>
<dd><p>Порт для подключения на удаленном хосте.
</p>
</dd>
<dt>-T timeout</dt>
<dd><p>Установите время ожидания для попыток подключения. Если с момента установления
             соединения с хостом или с момента последнего чтения чего-либо с этого хоста
             истекло время ожидания, то соединение закрывается и рассматриваемый хост
             считается недоступным. По умолчанию 5 секунд.
</p>
</dd>
<dt>-t type</dt>
<dd><p>Указывает тип ключа, который нужно получить с отсканированных хостов.
             Возможные значения: “rsa1” для версии протокола 1 и “dsa”, “ecdsa”, “ed25519”,
             или “rsa” для версии протокола 2. Несколько значений можно указать, разделяя
             их запятыми. По умолчанию выбираются ключи “rsa”, “ecdsa”, и “ed25519”.
</p>
</dd>
<dt>-v</dt>
<dd><p>Детальный режим. Заставляет ssh-keyscan печатать отладочные сообщения
             о его ходе.
</p></dd>
</dl>
</dd>
<dt>SECURITY</dt>
<dd><p>Если файл ssh_known_hosts создается с использованием ssh-keyscan без проверки
     ключей, пользователи будут уязвимы для атак посредника. С другой стороны, если
     модель безопасности допускает такой риск, ssh-keyscan может помочь в обнаружении
     несанкционированных ключевых файлов или атак посредников, которые начались после
     создания файла ssh_known_hosts.
</p>
</dd>
<dt>FILES</dt>
<dd><dl compact="compact">
<dt>Формат ввода:</dt>
<dd>
<p>1.2.3.4,1.2.4.4 name.my.domain,name,n.my.domain,n,1.2.3.4,1.2.4.4
</p>
</dd>
<dt>Выходной формат для ключей RSA1:</dt>
<dd>
<p>host-or-namelist bits exponent modulus
</p>
</dd>
<dt>Выходной формат для RSA, DSA, ECDSA, и Ed25519 keys:</dt>
<dd>
<p>host-or-namelist keytype base64-encoded-key
</p>
</dd>
<dt>Где тип ключа “ecdsa-sha2-nistp256”, “ecdsa-sha2-nistp384”, “ecdsa-sha2-nistp521”, “ssh-ed25519”, “ssh-dss” или “ssh-rsa”.</dt>
<dd>
<p>/etc/ssh/ssh_known_hosts
</p></dd>
</dl>
</dd>
<dt>EXAMPLES</dt>
<dd><div class="display">
<pre class="display">     Напечатайте ключ хоста rsa для имени хоста машины:

     $ ssh-keyscan hostname

     Найдите все хосты из файла ssh_hosts, которые имеют новые или отличающиеся
     от ключей в отсортированном файле ssh_known_hosts:

     $ ssh-keyscan -t rsa,dsa,ecdsa,ed25519 -f ssh_hosts | \
             sort -u - ssh_known_hosts | diff ssh_known_hosts -
</pre></div>
</dd>
<dt>SEE ALSO</dt>
<dd><p>ssh(1), sshd(8)
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>David Mazieres &lt;dm@lcs.mit.edu&gt; wrote the initial version, and Wayne
     Davison &lt;wayned@users.sourceforge.net&gt; added support for protocol version
     2.
</p>
</dd>
<dt>BUGS</dt>
<dd><p>It generates &quot;Connection closed by remote host&quot; messages on the consoles
     of all the machines it scans if the server is older than version 2.9.
     This is because it opens a connection to the ssh port, reads the public
     key, and drops the connection as soon as it gets the key.
</p>
<p>BSD                            November 8, 2015                            BSD
</p></dd>
</dl>
<hr>
<a name="SSH_002dKEYSIGN"></a>
<div class="header">
<p>
Next: <a href="#ssh_002dconfig_002dexample" accesskey="n" rel="next">ssh-config-example</a>, Previous: <a href="#SSH_002dKEYSCAN" accesskey="p" rel="prev">SSH-KEYSCAN</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="SSH_002dKEYSIGN-1"></a>
<h2 class="chapter">12 SSH-KEYSIGN</h2>
<dl compact="compact">
<dt>NAME</dt>
<dd><p>ssh-keysign — Вспомогательная программа ssh для аутентификации на основе хоста
</p>
</dd>
<dt>SYNOPSIS</dt>
<dd><p>ssh-keysign
</p>
</dd>
<dt>DESCRIPTION</dt>
<dd><p>ssh-keysign используется ssh(1) для доступа к ключам локального хоста и
     генерирования цифровой подписи, необходимой во время аутентификации на основе хоста.
</p>
<p>ssh-keysign по умолчанию отключен и может быть включен только в глобальном файле
     конфигурации клиента /etc/ssh/ssh_config, если для EnableSSHKeysign установлено
     значение “yes”.
</p>
<p>ssh-keysign предназначен не для вызова пользователем, а из ssh(1). См. ssh(1) и
     sshd(8) для получения дополнительной информации об аутентификации на
     основе хоста.
</p>
</dd>
<dt>FILES</dt>
<dd><div class="display">
<pre class="display">     /etc/ssh/ssh_config
             Управляет включением ssh-keysign.

     /etc/ssh/ssh_host_dsa_key
     /etc/ssh/ssh_host_ecdsa_key
     /etc/ssh/ssh_host_ed25519_key
     /etc/ssh/ssh_host_rsa_key
             Эти файлы содержат закрытые части ключей хоста, используемые для генерации
             цифровой подписи. Они должны принадлежать пользователю root, быть доступными
             для чтения только пользователю root и недоступны для других. Поскольку они
             доступны для чтения только пользователю root, ssh-keysign должен быть
             установлен как root-uid, если используется аутентификация на основе хоста.

     /etc/ssh/ssh_host_dsa_key-cert.pub
     /etc/ssh/ssh_host_ecdsa_key-cert.pub
     /etc/ssh/ssh_host_ed25519_key-cert.pub
     /etc/ssh/ssh_host_rsa_key-cert.pub
             Если эти файлы существуют, предполагается, что они содержат открытую
             сертификационную информацию, соответствующую приведенным выше
             закрытым ключам.
</pre></div>
</dd>
<dt>SEE ALSO</dt>
<dd><p>ssh(1), ssh-keygen(1), ssh_config(5), sshd(8)
</p>
</dd>
<dt>HISTORY</dt>
<dd><p>ssh-keysign first appeared in OpenBSD 3.2.
</p>
</dd>
<dt>AUTHORS</dt>
<dd><p>Markus Friedl &lt;markus@openbsd.org&gt;
</p>
<p>BSD                            February 17, 2016                           BSD
</p></dd>
</dl>

<hr>
<a name="ssh_002dconfig_002dexample"></a>
<div class="header">
<p>
Next: <a href="#sshd_005fconfig_002dexample" accesskey="n" rel="next">sshd_config-example</a>, Previous: <a href="#SSH_002dKEYSIGN" accesskey="p" rel="prev">SSH-KEYSIGN</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="ssh_002dconfig_002dexample-1"></a>
<h2 class="chapter">13 ssh-config-example</h2>

<div class="display">
<pre class="display"># Это общесистемный файл конфигурации клиента ssh. Смотрите ssh_config(5) для
#получения дополнительной информации. Этот файл предоставляет значения по умолчанию
#для пользователей, и значения можно изменить в файлах конфигурации для каждого
#пользователя или в командной строке.

# Данные конфигурации анализируются следующим образом:
#  1. параметры командной строки
#  2. пользовательский файл
#  3. общесистемный файл
# Любое значение конфигурации изменяется только при первой установке. Таким образом,
# специфичные для хоста определения должны быть в начале файла конфигурации, а значения
# по умолчанию - в конце.

# По умолчанию для всего сайта используются некоторые часто используемые параметры.
# Полный список доступных параметров, их значения и значения по умолчанию см. На
# справочной странице ssh_config(5).

Host *
#   ForwardAgent no
#   ForwardX11 no
#   ForwardX11Trusted yes
#   RhostsRSAAuthentication no
#   RSAAuthentication yes
#   PasswordAuthentication yes
#   HostbasedAuthentication no
#   GSSAPIAuthentication no
#   GSSAPIDelegateCredentials no
#   GSSAPIKeyExchange no
#   GSSAPITrustDNS no
#   BatchMode no
#   CheckHostIP yes
#   AddressFamily any
#   ConnectTimeout 0
#   StrictHostKeyChecking ask
#   IdentityFile ~/.ssh/identity
#   IdentityFile ~/.ssh/id_rsa
#   IdentityFile ~/.ssh/id_dsa
#   IdentityFile ~/.ssh/id_ecdsa
#   IdentityFile ~/.ssh/id_ed25519
#   Port 22
#   Protocol 2
#   Cipher 3des
#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
#   MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160
#   EscapeChar ~
#   Tunnel no
#   TunnelDevice any:any
#   PermitLocalCommand no
#   VisualHostKey no
#   ProxyCommand ssh -q -W %h:%p gateway.example.com
#   RekeyLimit 1G 1h
    SendEnv LANG LC_*
    HashKnownHosts yes
    GSSAPIAuthentication yes
    GSSAPIDelegateCredentials no
</pre></div>
<hr>
<a name="sshd_005fconfig_002dexample"></a>
<div class="header">
<p>
Next: <a href="#sshd_005fconfig_005fexample-2" accesskey="n" rel="next">sshd_config_example 2</a>, Previous: <a href="#ssh_002dconfig_002dexample" accesskey="p" rel="prev">ssh-config-example</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="sshd_005fconfig_002dexample-1"></a>
<h2 class="chapter">14 sshd_config-example</h2>
<div class="display">
<pre class="display">#sshd_config,v 1.101 2017/03/14 07:19:07 djm Exp $
# Это общесистемный файл конфигурации сервера sshd. Смотрите sshd_config(5) для
#получения дополнительной информации.

# Этот sshd был скомпилирован с PATH=/usr/bin:/bin:/usr/sbin:/sbin

# Стратегия, используемая для параметров в sshd_config по умолчанию, поставляемом
# с OpenSSH, заключается в том, чтобы по возможности указывать параметры со значениями
# по умолчанию, но оставлять их в комментариях. Некомментированные параметры
# переопределяют значение по умолчанию.

#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
#HostKey /etc/ssh/ssh_host_ed25519_key

# Ciphers and keying
#RekeyLimit default none

# Logging
#SyslogFacility AUTH
#LogLevel INFO

# Authentication:

#LoginGraceTime 2m
#PermitRootLogin prohibit-password
PermitRootLogin yes
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

#PubkeyAuthentication yes

# Ожидайте, что .ssh/authorized_keys2 будет игнорироваться по умолчанию в будущем.
#AuthorizedKeysFile	.ssh/authorized_keys .ssh/authorized_keys2

#AuthorizedPrincipalsFile none

#AuthorizedKeysCommand none
#AuthorizedKeysCommandUser nobody

# Для этого вам также понадобятся ключи хоста в /etc/ssh/ssh_known_hosts
#HostbasedAuthentication no
# Измените на да, если вы не доверяете ~/.ssh/known_hosts 
# HostbasedAuthentication
#IgnoreUserKnownHosts no
# Не читайте файлы пользователя ~/.rhosts и ~/.shosts
#IgnoreRhosts yes

# Чтобы отключить туннельные пароли в виде открытого текста, измените на &rsquo;no&rsquo;здесь!
#PasswordAuthentication yes
#PermitEmptyPasswords no

# Измените на yes, чтобы включить пароли запроса-ответа (остерегайтесь проблем с
#некоторыми модулями и потоками PAM)
ChallengeResponseAuthentication no

# Kerberos опции
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosGetAFSToken no

# GSSAPI options
#GSSAPIAuthentication no
#GSSAPICleanupCredentials yes
#GSSAPIStrictAcceptorCheck yes
#GSSAPIKeyExchange no

# Установите для этого параметра значение &rsquo;yes&rsquo;, чтобы включить проверку
# подлинности PAM, обработку учетной записи и обработку сеанса. Если это
# включено, аутентификация PAM будет разрешена через ChallengeResponseAuthentication
# и PasswordAuthentication. В зависимости от конфигурации PAM аутентификация PAM
# через ChallengeResponseAuthentication может обойти настройку
# &quot;PermitRootLogin without-password&quot;. Если вы просто хотите, чтобы проверки учетных
# записей и сеансов PAM выполнялись без аутентификации PAM, включите эту функцию, но
# установите для PasswordAuthentication и ChallengeResponseAuthentication
# значение &rsquo;no&rsquo;.
UsePAM yes

#AllowAgentForwarding yes
#AllowTcpForwarding yes
#GatewayPorts no
X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes
#PermitTTY yes
PrintMotd no
#PrintLastLog yes
#TCPKeepAlive yes
#UseLogin no
#PermitUserEnvironment no
#Compression delayed
#ClientAliveInterval 0
#ClientAliveCountMax 3
#UseDNS no
#PidFile /var/run/sshd.pid
#MaxStartups 10:30:100
#PermitTunnel no
#ChrootDirectory none
#VersionAddendum none

# отключение баннера по умолчанию
#Banner none

# Разрешить клиенту передавать переменные окружения локали
AcceptEnv LANG LC_*

# переопределить по умолчанию без подсистем
Subsystem	sftp	/usr/lib/openssh/sftp-server

# Пример переопределения настроек для каждого пользователя
# Match User anoncvs
#	X11Forwarding no
#	AllowTcpForwarding no
#	PermitTTY no
#	ForceCommand cvs server
</pre></div>
<hr>
<a name="sshd_005fconfig_005fexample-2"></a>
<div class="header">
<p>
Next: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="n" rel="next">Руководство 1</a>, Previous: <a href="#sshd_005fconfig_002dexample" accesskey="p" rel="prev">sshd_config-example</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="sshd_005fconfig_005fexample-2-1"></a>
<h2 class="chapter">15 sshd_config_example 2</h2>
<div class="display">
<pre class="display">#     Пример конфигурации open-ssh сервера с русскими      #
#                      комментариями.                      #
#           Написан для http://help.ubuntu.ru              #
#                   by MadKox, 01.2010.                    #
#                                                          #
#                                                          #
# Условные обозначения:                                    #
# Под &quot;по умолчанию&quot; - подразумевается поведение sshd при  #
# неуказанной явно директиве. Стоит заметить, что в Ubuntu # 
# файл sshd_config уже содержит ряд настроек, которые      #
# являются настройками по умолчанию для именно для Ubuntu. #
# Такие настройки указаны в этом файле.                    #
#                                                          #
############################################################
################ Настройки адресов/портов и т.д. ###########
############################################################
#                                                          #
## Port ####################################################
#                                                          #
# Используемый порт. Можно указывать несколько, например:  #
# Port 22                                                  #
# Port 23                                                  #
# Port 24                                                  #
# Рекомендуется использовать нестандартный порт, т.к.      #
# стандартный часто сканируется ботами на предмет          #
# потенциальных &quot;дырок&quot;. Может быть опущен, если задан     #
# через адрес. См. также параметр ListenAddress.           #
#                                                          #
Port 22
#                                                          #
## ListenAddress ###########################################
#                                                          #
# Сетевой адрес, на котором &quot;слушает&quot; сервер. Адрес можно  #
# записывать так:                                          #
# ListenAddress host|IPv4_addr|IPv6_addr                   #
# ListenAddress host|IPv4_addr:port                        #
# ListenAddress [host|IPv6_addr]:port                      #
# Если порт не задан, sshd будет слушать на этом адресе и  #
# на порту, указанному в опции Port. Если вы будете        # 
# использовать ListenAddress не указывая порт, то опция    #
# Port должна предшествовать опции ListenAddress. Если не  #
# указывать, то по умолчанию слушает на всех локальных     #
# адресах. Можно указывать несколько адресов.              #
#                                                          #
## AddressFamily ###########################################
#                                                          #
# Указывает, какое семейство IP адресов должно быть        #
# использовано sshd. Возможные варианты:                   #
# “any” - любые                                            #
# “inet” (только IPv4)                                     #
# “inet6” (только IPv6)                                    #
# По умолчанию - “any”.                                    #
AddressFamily inet
#                                                          #
## UseDNS ##################################################
#                                                          #
# Указывает, должен ли sshd проверять имя хоста и          #
# используя это имя сверять IP адрес переданный клиентом с #
# полученным от DNS.                                       #
# Значение по умолчанию - “yes”.                           #
#                                                          #
############################################################
############# Настройки доступа пользователей ##############
############################################################
#                                                          #
# Пустить/не пустить пользователя определяется директивами #
# DenyUsers, AllowUsers, DenyGroups, и AllowGroups.        #
# при этом, проверка проходит сверху - вниз по цепочке:    #
#                   ## DenyUsers ##                        #
#                          ||                              #
#                   ## AllowUsers ##                       #
#                          ||                              #
#                   ## DenyGroups ##                       #
#                          ||                              #
#                   ## AllowGroups ##                      #
# Принимаются только имена пользователей и групп, числовые #
# идентификаторы (UserID) - не распознаются. Корректная    #
# запись нескольких пользователей/групп по очереди, через  #
# пробел. Если записано в виде пользователь@хост - то      #
# пользователь и хост проверяются отдельно, это позволяет  #
# разграничить доступ определенных пользователей с         #
# определенных хостов. Стоит помнить, что директивы        #
# DenyUsers и AllowUsers принимают в качестве параметра    #
# имя пользователя, а DenyGroups и AllowGroups - имя       #
# группы. См. PATTERNS в man ssh_config для дополнительной #
# информации о формах записи имен пользователей и групп.   #
#                                                          #
## DenyUsers ###############################################
#                                                          #
# Список ПОЛЬЗОВАТЕЛЕЙ, которым НЕЛЬЗЯ пользоваться sshd.  #
# По умолчанию - не указан = не запрещен никто. Т.е. если  #
# тут указан пользователь, то ему будет отказано в доступе #
# к ssh серверу.                                           #
#                                                          #
## AllowUsers ##############################################
#                                                          #
# Список ПОЛЬЗОВАТЕЛЕЙ, которым МОЖНО пользоваться sshd,   # 
# По умолчанию - не указан = разрешено всем. Т.е. если     # 
# указан хотя бы один пользователь, ssh доступ к серверу   #
# доступен только для него.                                #
#                                                          #
## DenyGroups ##############################################
#                                                          #
# Список ГРУПП, которым НЕЛЬЗЯ пользоваться sshd.          #
# По умолчанию - не указан = не запрещена ни одна группа.  #
# Т.е. если указана хотя бы одна группа, то пользователям, #
# входящим в эту группу будет отказано в доступе к ssh     #
# серверу.                                                 #
#                                                          #
## AllowGroups #############################################
#                                                          #
# Список ГРУПП, которым МОЖНО пользоваться sshd.           #
# По умолчанию - не указан = разрешено всем. Т.е. если     #
# указана хотя бы одна группа, то только тем пользователям,#
# которые в нее входят будет разрешен доступ к ssh серверу.#
#                                                          #
############################################################
######### Опции определения состояния соединения ###########
############################################################
#                                                          #
## TCPKeepAlive ############################################
#                                                          #
# Указывает, нужно системе посылать TCP сообщения клиенту  #
# с целью поддержания соединения. Если посылать эти пакеты,#
# можно определить разрыв соединения. Однако это также     #
# означает, что соединение может быть разорвано в случае   #
# кратковременного перебоя в работе маршрутизации и        #
# некоторых это сильно раздражает. С другой стороны, если  #
# таких сообщений не посылать - сеансы на сервере могут    #
# длиться бесконечно, порождая пользователей - &quot;призраков&quot;,#
# и пожирая ресурсы сервера. Значение по умолчанию - “yes”,#
# т.е. посылать такие сообщения. Для отключения отправки   #
# таких сообщений нужно задать значение “no”. Ранее эта    #
# опция называлась KeepAlive. Стоит заметить, что          #
# существуют более защищенные способы проверки состояния   #
# соединения (см. ниже).                                   #
#                                                          #
TCPKeepAlive yes
#                                                          #
## ClientAliveCountMax #####################################
#                                                          #
# Задает количество сообщений к клиентам, которые sshd     #
# посылает подряд, не получая какого либо ответа от        #
# клиента. Если пороговое значение будет достигнуто, а     #
# клиент так и не ответил - sshd отключит клиента, прервав #
# ssh сессию. Стоит отметить, что использование таких      #
# сообщений в корне отличается от директивы TCPKeepAlive.  #
# Сообщения к/от клиентов посылаются по зашифрованному     #
# каналу и поэтому не подвержены спуфингу. Сообщения же    #
# TCPKeepAlive спуфингу подвержены. Механизм client alive  #
# особо ценен в тех случаях, когда серверу и клиенту нужно #
# знать когда соединение стало неактивным. По умолчанию    #
# значение равно 3. В случае, если ClientAliveInterval     #
# задан равным 15 и ClientAliveCountMax оставлен по        #
# умолчанию, неотвечающие клиенты будут отключены примерно #
# через 45 секунд. Эта директива работает только для       #
# протокола ssh2.                                          #
#                                                          #
## ClientAliveInterval #####################################
#                                                          #
# Задает временной интервал в секундах. Если в течении     #
# этого интервала не было обмена данными с клиентом, sshd  #
# посылает сообщение по зашифрованному каналу,             #
# запрашивающее ответ от клиента. По умолчанию - 0, т.е.   #
# не посылать таких сообщений. Эта директива работает      #
# только для протокола ssh2.                               #
#                                                          #
############################################################
################ Общие опции аутентификации ################
############################################################
#                                                          #
## AuthorizedKeysFile ######################################
#                                                          #
# Указывает файл, в котором содержатся публичные ключи,    #
# используемые для аутентификации пользователей. Директива #
# может содержать маркеры вида %М, которые подставляются в #
# процессе установки соединения.                           #
# Определены следующие маркеры:                            #
# %% - заменяется литералом &rsquo;%&rsquo;                            #
# %h - заменяется домашней директорией                     #
# аутентифицируещегося пользователя                        #
# %u - заменяется именем аутентифицируещегося пользователя #
# Таким образом, файл с ключами может быть задан как       #
# абсолютным путем (т.е. один общий файл с ключами), так и #
# динамически - в зависимости от пользователя (т.е. по     #
# файлу на каждого пользователя).                          #
# По умолчанию - “.ssh/authorized_keys”.                   #
# Пример для файла ключа в домашней папке пользователя:    # 
# AuthorizedKeysFile %h/.ssh/authorized_key                #
# Пример для общего файла:                                 #
# AuthorizedKeysFile /etc/ssh/authorized_keys              #
# См. описание файла authorized_keys для большей           #
# информации.                                              #
#                                                          #
## ChallengeResponseAuthentication #########################
#                                                          #
# Указывает, разрешить ли аутентификацию вида вопрос-ответ #
# (challenge-response authentication). Поддерживаются все  #
# виды аутентификации из login.conf По умолчанию - “yes”,  #
# т.е. разрешить.                                          #
# В Ubuntu - выключена по соображениям безопасности.       #
#                                                          #
ChallengeResponseAuthentication no
#                                                          #
## HostbasedUsesNameFromPacketOnly #########################
#                                                          #
# Указывает, как сервер должен получать имя хоста клиента  #
# при схеме аутентификации, основанной на проверке хоста.  #
# Если задать &quot;yes&quot; - при проверке соответствия в файлах   #
# ~/.shosts, ~/.rhosts или /etc/hosts.equiv sshd будет     #
# использовать имя хоста, предоставленное клиентом.        #
# (выполняя реверсивное DNS распознование) Если задать &quot;no&quot;#
# - sshd будет ресолвить имя из самого TCP соединения.     # 
# По умолчанию - &quot;no&quot;.                                     #
#                                                          #
## IgnoreRhosts ############################################
#                                                          #
# Запрещает использование файлов .rhosts и .shosts         #
# в процессе аутентификации, основанной на проверке хоста. #
# (RhostsRSAAuthentication или HostbasedAuthentication).   #
# Файлы /etc/hosts.equiv и /etc/ssh/shosts.equiv все еще   #
# используются.                                            #
# По умолчанию - “yes”.                                    #
#                                                          #
IgnoreRhosts yes
#                                                          #
## IgnoreUserKnownHosts ####################################
#                                                          #
# Указывает должен ли sshd игнорировать пользовательские   # 
# &quot;известные хосты&quot; - файл ~/.ssh/known_hosts в процессе   #
# аутентификации, основанной на проверке хоста             # 
# (RhostsRSAAuthentication или HostbasedAuthentication).   #
# По умолчанию - “no”.                                     #
#                                                          #
## PermitBlacklistedKeys ###################################
#                                                          #
# Указывает, стоит ли sshd принимать ключи, занесенные в   #
# черный список как скомпрометированные (known-compromised #
# keys (см. ssh-vulnkey)). Если задано значение “yes” -    #
# попытки аутентификации с такими ключами будут занесены в #
# журнал и приняты, если значение “no” - попытки           #
# аутентификации будут отвергнуты.                         #
# По умолчанию - “no”.                                     #
#                                                          #
## PermitEmptyPasswords ####################################
#                                                          #
# В случае разрешенной аутентификации с помощью пароля,    #
# указывает, возможен ли вход с пустым паролем.            #
# По умолчанию - “no”.                                     #
#                                                          #
PermitEmptyPasswords no
#                                                          #
## PermitRootLogin #########################################
#                                                          #
# Указывает, возможен ли ssh-вход под суперпользователем   #
# (root). Может принимать значения:                        #
# “yes” - суперпользователь может зайти. Применяется       #
# текущая глобальная схема аутентификации.                 #
#                                                          #
# “without-password” - суперпользователь может зайти.      #
# Парольная аутентификация для него будет отключена.       #
#                                                          #
# “forced-commands-only” - суперпользователь сможет зайти, #
# пользуясь аутентификацией на основе публичного ключа и   #
# только если передаст необходимую к исполнению комнаду.   #
# Это удобно для осуществления резервного копирования,     #
# даже в том случае, когда нормальный (т.е. не через ssh)  #
# вход суперпользователя запрещен. Все остальные методы    #
# аутентификации для суперпользователя будут заблокированы.#
#                                                          #
# “no” - суперпользователь не может использовать ssh для   #
# входа в систему.                                         #
#                                                          #
# Значение по умолчанию - “yes”.                           #
#                                                          #
PermitRootLogin yes
#                                                          #
## Protocol ################################################
#                                                          #
# Указывает, какой протокол должен использовать sshd.      #
# Возможные значения ‘1’ и ‘2’ - ssh1 и ssh2               #
# соответственно. Возможна одновременная запись, при       #
# которой значения следует разделять запятыми.             #
# По умолчанию - “2,1”.                                    #
# Стоит отметить, что порядок следования протоколов в      #
# записи не задает приоритет, т.к. клиент выбирает какой   #
# из нескольких предложенных сервером протоколов ему       #
# использовать.Запись &quot;2,1&quot; абсолютно идентична            #
# записи &quot;1,2&quot;.                                            #
#                                                          #
Protocol 2
#                                                          #
## UsePAM ##################################################
#                                                          #
# Включает интерфейс PAM (Pluggable Authentication Module  #
# interface).Если задано значение &quot;yes&quot; - для всех типов   #
# аутентификации помимо обработки модуля сессии и аккаунта #
# PAM будет использоваться аутентификация на основе        #
# запроса-ответа (ChallengeResponseAuthentication и        #
# PasswordAuthentication) Т.к. аутентификация              #
# запросов-ответов в PAM обычно выполняет ту же роль,      #
# что и парольная аутентификация, вам следует отключить    #
# либо PasswordAuthentication, либо                        #
# ChallengeResponseAuthentication. Стоит отметить, что     #
# если директива UsePAM включена - вы не сможете запустить #
# sshd от имени пользователя, отличного от root.           #
# Значение по умолчанию - “no”.                            #
#                                                          #
UsePAM yes
#                                                          #
## PasswordAuthentication ##################################
#                                                          #
# Указывает, разрешена ли аутентификация с использованием  #
# пароля.                                                  #
# По умолчанию - “yes”.                                    #
#                                                          #
## HostKey #################################################
#                                                          #
# Указывает файл, содержащий закрытый хост-ключ,           #
# используемый SSH. По умолчанию - /etc/ssh/ssh_host_key   #
# для протокола ssh1 и /etc/ssh/ssh_host_rsa_key и         #
# /etc/ssh/ssh_host_dsa_key для протокола ssh2. Стоит      #
# отметить, что sshd не станет пользоваться файлом,        #
# который доступен кому либо, кроме пользователя. Можно    #
# использовать несколько файлов с ключами, ключи “rsa1” -  #
# для протокола ssh1 и “dsa”/“rsa” для протокола ssh2.     #
#                                                          #
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_dsa_key
#                                                          #
############################################################
########## Опции протокола SSH версии 1 (ssh1) #############
############################################################
# Настоятельно НЕ РЕКОМЕНДУЕТСЯ использовать протокол ssh1.#
# Протокол ssh2 намного более безопасен, чем ssh1          #
############################################################
#                                                          # 
## KeyRegenerationInterval #################################
#                                                          #
# Для протокола ssh1 - раз в определенное время            #
# автоматически генерируется новый временный ключ сервера  #
# (если он был использован). Это сделано для               #
# предотвращения расшифровки перехваченных сеансов,с целью #
# позже зайти с параметрами этих сеансов на машину и       #
# украсть ключи. Такой ключ нигде не хранится (хранится в  #
# оперативной памяти). Данная директива указывает период   #
# &quot;жизни&quot; ключа в секундах, после которого он будет        #
# сгенерирован заново. Если значение задать равным 0 -     #
# ключ не будет генерироваться заново.                     #
# По умолчанию значение - 3600 (секунд).                   #
#                                                          #
KeyRegenerationInterval 3600
#                                                          #
## RhostsRSAAuthentication #################################
#                                                          #
# Указывает, нужна ли аутентификация на основе файлов      #
# rhosts или /etc/hosts.equiv совместно с успешной         #
# аутентификацией хоста через RSA.                         #
# Актуально только для протокола ssh1.                     #
# По умолчанию - “no”.                                     #
#                                                          #
RhostsRSAAuthentication no
#                                                          #
## RSAAuthentication #######################################
#                                                          #
# Указывает, разрешена ли &quot;чистая&quot; RSA-аутентификация.     #
# Актуально только для протокола ssh1.                     #
# По умолчанию - “yes”.                                    #
#                                                          #
RSAAuthentication yes
#                                                          #
## ServerKeyBits ###########################################
#                                                          #
# Определяет число бит во временном ключе сервера для      #
# протокола ssh1. Минимальное значение 512.                #
# Значение по умолчанию - 1024.                            #
ServerKeyBits 768
#                                                          #
############################################################
########### Опции протокола SSH версии 2 (ssh2) ############
############################################################
#                                                          #
## Ciphers #################################################
#                                                          #
# Указывает алгоритмы шифрования, разрешенные для          #
# протокола ssh2. Несколько алгоритмов должны быть         #
# разделены запятыми. Поддерживаемые алгоритмы:            #
# “3des-cbc”, “aes128-cbc”, “aes192-cbc”, “aes256-cbc”,    #
# “aes128-ctr”, “aes192-ctr”, “aes256-ctr”, “arcfour128”,  #
# “arcfour256”, “arcfour”, “blowfish-cbc”, “cast128-cbc”.  #
# По умолчанию используются:                               #
# aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128, #
# arcfour256,arcfour,aes192-cbc,aes256-cbc,aes128-ctr,     #
# aes192-ctr,aes256-ctr                                    #
#                                                          #
## HostbasedAuthentication #################################
#                                                          #
# Указывает, разрешена ли аутентификация, основанная на    #
# проверке хоста. Проверяется rhosts или /etc/hosts.equiv, #
# и в случае успеха, совместного с успешной проверкой      #
# публичного ключа, доступ разрешается. Данная директива   #
# одинакова с директивой RhostsRSAAuthentication и         #
# подходит только для протокола ssh2.                      #
# По умолчанию - &quot;no&quot;.                                     #
#                                                          #
HostbasedAuthentication no
#                                                          #
## MACs ####################################################
#                                                          #
# Указывает допустимый алгоритм MAC (message               #
# authentication code). Алгоритм MAC используется          #
# протоколом ssh2 для защиты целостности данных. Несколько #
# алгоритмов должны быть разделены запятыми.               #
# По умолчанию используются:                               #
# hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,   #
# hmac-sha1-96,hmac-md5-96                                 #
#                                                          #
## PubkeyAuthentication ####################################
#                                                          #
# Указывает, разрешена ли аутентификация на основе         #
# публичного ключа. Актуально только для протокола ssh2.   #
# По умолчанию - “yes”.                                    #
#                                                          #
PubkeyAuthentication yes
############################################################
#################### Опции GSSAPI ##########################
############################################################
#                                                          #
############ Применимо только для протокола ssh2 ###########
#                                                          #
## GSSAPIAuthentication ####################################
#                                                          #
# Указывает, разрешена ли аутентификация пользователя на   #
# основе GSSAPI. По умолчанию - &quot;no&quot;, т.е. запрещена.      #
#                                                          #
## GSSAPIKeyExchange #######################################
#                                                          #
# Указывает, разрешен ли обмен ключами, основанный на      #
# GSSAPI. Обмен ключам при помощи GSSAPI не полагается на  #
# ssh ключи при верификации идентичности хоста.            #
# По умолчанию - &quot;no&quot; - т.е. обмен запрещен.               #
#                                                          #
## GSSAPICleanupCredentials ################################
#                                                          #
# Указывает, нужно ли автоматически уничтожать             #
# пользовательский кеш аутентификационных полномочий при   #
# завершении сеанса.                                       #
# По умолчанию - &quot;yes&quot; - т.е. нужно уничтожать.            #
#                                                          #
## GSSAPIStrictAcceptorCheck ###############################
#                                                          #
# Указывает, насколько строгой должна быть проверка        #
# идентичности клиента при аутентификации через GSSAPI.    #
# Значение &quot;yes&quot; заставляет клиента аутентифицироваться в  #
# принимающей хост-службе на текущем хосте. Значение &quot;no&quot;  #
# позволяет клиенту аутентифицироваться при помощи любого  #
# ключа служб.                                             #
# Значение по умолчанию - &quot;yes&quot;.                           #
# Стоит заметить, что задание значения &quot;no&quot; может          #
# сработать только с редкими библиотеками Kerberos GSSAPI. #
#                                                          #
############################################################
################### Опции Kerberos #########################
############################################################
#                                                          #
## KerberosAuthentication ##################################
#                                                          #
# Указывает, требует ли пароль, предоставленный            #
# пользователем для аутентификации                         #
# (PasswordAuthentication) валидации в Kerberos KDC.       #
# Для использования этой опции серверу нужно               #
# удостовериться в истинности KDC. (Тhe server needs a     #
# Kerberos servtab which allows the verification of the    #
# KDC’s identity)                                          #
# По умолчанию - “no”.                                     #
#                                                          #
## KerberosGetAFSToken #####################################
#                                                          #
# Если активен AFS и пользователь получил Kerberos 5 TGT,  #
# пытаться ли получить AFS токен до того, как пользователь #
# получит доступ к своей домашней папке.                   #
# По умолчанию - “no”.                                     #
#                                                          #
## KerberosOrLocalPasswd ###################################
#                                                          #
# Указывает, как поступать в случае, если аутентификация   #
# через Kerberos завершилась неудачей. Если                #
# значение = &quot;yes&quot; - пароль будет проверен при помощи      #
# любого дополнительного локального механизма авторизации, #
# например - /etc/passwd.                                  #
# По умолчанию - “yes”.                                    #
#                                                          #
## KerberosTicketCleanup ###################################
#                                                          #
# Указывает, нужно ли автоматически уничтожать файл с      #
# кешем тикета пользователя по завершению сеанса.          #
# По умолчанию - “yes”.                                    #
#                                                          #
############################################################
################# Опции перенаправления ####################
############################################################
#                                                          #
## AllowAgentForwarding ####################################
#                                                          #
# Указывает, разрешить или запретить перенаправление       #
# ssh-agent&rsquo;а. По умолчанию - “yes”, т.е. разрешить.       #
# Стоит заметить, что отключение перенаправления не        #
# увеличит безопасности пока пользователям также не будет  #
# запрещен shell доступ, т.к. они всегда смогут установить #
# свои собственные аналоги агента.                         #
#                                                          #
## AllowTcpForwarding ######################################
#                                                          #
# Указывает, разрешить или запретить перенаправление TCP.  #
# По умолчанию - “yes”, т.е. разрешить. Стоит заметить,    #
# что как и в случае с AllowAgentForwarding отключение     #
# перенаправления не увеличит безопасности, пока у         #
# пользователей будет консольный доступ, т.к. они смогут   #
# установить свои аналоги.                                 #
#                                                          #
#                                                          #
## GatewayPorts ############################################
#                                                          #
# Указывает, разрешать ли удаленным хостам доступ к        #
# перенаправленным портам. По умолчанию, sshd слушает      #
# соединения к перенаправленным портам только на локальном #
# интерфейсе (loopback). Это не дает другим удаленным      #
# хостам подсоединяться к перенаправленным портам. Можно   #
# использовать GatewayPorts, чтобы разрешить sshd это      #
# делать. Директива может принимать 3 значения:            #
# &quot;no&quot; - только loopback.                                  #
# &quot;yes&quot;- любые адреса.                                     #
# &quot;clientspecified&quot; - адреса указанные клиентом.           #
#                                                          #
## PermitOpen ##############################################
#                                                          #
# Указывает куда разрешено перенаправление TCP портов.     #
# Указание перенаправления должно принимать одну из        #
# следующих форм:                                          #
# PermitOpen host:port                                     #
# PermitOpen IPv4_addr:port                                #
# PermitOpen [IPv6_addr]:port                              #
# Несколько записей можно задать, разделяя их пробелами.   #
# Аргумент “any” можно использовать для снятия всех        #
# запретов на перенаправление портов. По умолчанию любое   #
# перенаправление разрешено.                               #
#                                                          #
## PermitTunnel ############################################
#                                                          #
# Указывает, разрешено ли перенаправление tun-устройств.   #
# Может принимать значения:                                #
# “yes”                                                    #
# “point-to-point” (3-й сетевой уровень)                   #
# “ethernet” (2-й сетевой уровень)                         #
# “no”                                                     #
# Значение “yes” разрешает одновременно и “point-to-point” #
# и “ethernet”. По умолчанию - “no”.                       #
#                                                          #
############################################################
################## Опции журналирования ####################
############################################################
#                                                          #
## SyslogFacility ##########################################
#                                                          #
# Задает код объекта журнала для записи сообщений в        #
# системный журнал от sshd. Возможные значения:            #
# DAEMON                                                   #
# USER                                                     #
# AUTH                                                     #
# LOCAL0                                                   #
# LOCAL1                                                   #  
# LOCAL2                                                   #
# LOCAL3                                                   #
# LOCAL4                                                   #
# LOCAL5                                                   #
# LOCAL6                                                   #
# LOCAL7                                                   #
# По умолчанию используется AUTH.                          #
#                                                          #
SyslogFacility AUTH
#                                                          #
## LogLevel ################################################
#                                                          #
# Задает уровень детальности журнала sshd.                 #
# Возможные варианты:                                      #
# SILENT                                                   #
# QUIET                                                    #
# FATAL                                                    #
# ERROR                                                    #
# INFO                                                     #
# VERBOSE                                                  #
# DEBUG                                                    #
# DEBUG1                                                   #
# DEBUG2                                                   #
# DEBUG3                                                   # 
# По умолчанию - INFO.                                     # 
# DEBUG и DEBUG1 эквивалентны друг другу.                  #
# DEBUG2 и DEBUG3 задают самые высокие уровни отладочного  #
# вывода. Запись логов с уровнем DEBUG угрожает            #
# приватности пользователей и не рекомендована.            #
#                                                          #
LogLevel INFO
#                                                          #
############################################################
################### Перенаправление X11 ####################
############################################################
#                                                          #
## X11Forwarding ###########################################
#                                                          #
# Указывает, разрешено ли перенаправление графической      #
# подсистемы X11. Может принимать значения “yes” или “no”. #
# По умолчанию - “no”.                                     # 
# Внимание - включение простого перенаправления Х11 -      #
# большой риск как для сервера, так и для клиентов, т.к. в #
# случае такого перенаправления прокси-дисплей sshd        #
# принимает соединения с любых адресов. Используйте        #
# директиву X11UseLocalhost для ограничения доступа к      #
# серверу перенаправления &quot;иксов&quot;. Стоит отметить, что     #
# отключение перенаправления не даст гарантии, что         #
# пользователи не смогут перенаправлять Х11, т.к. имея     #
# консольный доступ они всегда установить свой             #
# перенаправлятель. Перенаправление Х11 будет              #
# автоматически отключено, если будет задействована        #
# директива UseLogin.                                      #
#                                                          #
X11Forwarding yes
#                                                          #
## X11UseLocalhost #########################################
#                                                          #
# Указывает, должен ли sshd ограничить область             #
# перенаправления Х11 локальным loopback адресом, или      #
# должен разрешить любые адреса. По умолчанию - sshd       #
# &quot;сажает&quot; сервер перенаправления Х11 на локальный адрес   #
# и задает часть переменной окружения DISPLAY, отвечающую  #
# за имя хоста как “localhost”. Стоит заметить, что        #
# некоторые старые клиенты Х11 могут не работать с такими  #
# настройками. По умолчанию - &quot;yes&quot;, т.е. перенаправление  #
# ограничено локалхостом, значение - “no” - отключает      #
# ограничения.                                             #
#                                                          #
## XAuthLocation ###########################################
#                                                          #
# Указывает полный путь к программе xauth.                 #
# По умолчанию - /usr/bin/X11/xauth.                       #
#                                                          #
## X11DisplayOffset ########################################
#                                                          #
# Указывает номер первого дисплея, доступного sshd в       #
# качестве перенаправления X11. Это сделано для того,      #
# чтобы перенаправленные &quot;иксы&quot; не пересекались с          # 
# реальными. По умолчанию - 10.                            #
#                                                          #
X11DisplayOffset 10
#                                                          #
############################################################
################### Различные опции ########################
############################################################
#                                                          #
## LoginGraceTime ##########################################
#                                                          #
# Время, по прошествии которого сервер отключает           #
# пользователя, если тот не смог удовлетворительно         #
# залогиниться. Значение 0 - разрешает пользователю        #
# логиниться бесконечно. По умолчанию - 120 (секунд).      #
#                                                          #
LoginGraceTime 120
#                                                          #
## MaxAuthTries ############################################
#                                                          #
# Указывает максимальное число попыток аутентификации,     #
# разрешенное для одного соединения.                       #
# Как только число неудачных попыток превысит половину     #
# заданного значения, все последующие попытки будут        #
# заноситься в журнал. Значение по умолчанию - 6.          #
#                                                          #
## MaxSessions #############################################
#                                                          #
# Указывает максимальное число одновременных подключений   #
# для каждого сетевого соединения. По умолчанию - 10.      #
#                                                          #
## MaxStartups #############################################
#                                                          #
# Указывает максимальное число одновременных               #
# неавторизованных подключений к sshd. В случае, если      #
# число подключений превысит лимит - все дополнительные    #
# подключения будут сброшены до тех пор, пока текущие      #
# подключения не завершатся либо успешной авторизацией,    #
# либо истечением периода времени указанного в директиве   #
# LoginGraceTime. Значение по умолчанию - 10.              #
# Дополнительно, можно задать ранний сброс соединений,     #
# указав в качестве параметра три значения, разделенные    #
# двоеточием “start:rate:full” (например: &quot;10:30:60&quot;).     #
# sshd отклонит попытку соединения с вероятностью равной   #
# “rate/100” (т.е. в нашем примере - 30%), если уже        #
# имеется “start” (10) неавторизованных соединений.        #
# Вероятность увеличивается линейно и любые попытки        #
# соединения будут отклонены, если число неавторизованных  #
# соединений достигнет значения “full” (60).               #
#                                                          #
## Compression #############################################
#                                                          #
# Указывает, разрешено ли сжатие данных. Может быть        #
# &quot;yes&quot; - сжатие разрешено.                                #
# &quot;delayed&quot; - сжатие отложено до тех пор, пока             #
# пользователь успешно не аутентифицируется.               #
# &quot;no&quot; - сжатие запрещено.                                 #
# По умолчанию - &quot;delayed&quot;.                                #
#                                                          #
## UseLogin ################################################
#                                                          #
# Указывает, должен ли использоваться login для            #
# интерактивного сеанса. Значение по умолчанию - “no”.     #
# Стоит отметить, что login никогда не использовался для   #
# выполнения удаленных команд. Так же заметим, что         #
# использование login сделает невозможным использование    #
# директивы X11Forwarding, потому что login не знает, что  #
# ему делать с xauth. Если включена директива              #
# UsePrivilegeSeparation - она будет отключена после       #
# авторизации.                                             #
#                                                          #
## UsePrivilegeSeparation ##################################
#                                                          #
# Указывает, должен ли sshd разделять привилегии. Если да  #
# - то сначала будет создан непривилегированный дочерний   #
# процесс для входящего сетевого трафика. После успешной   #
# авторизации будет создан другой процесс с привилегиями   #
# вошедшего пользователя. Основная цель разделения         #
# привилегий - предотвращение превышения прав доступа.     #
# Значение по умолчанию - “yes”.                           #
#                                                          #
UsePrivilegeSeparation yes
#                                                          #
## StrictModes #############################################
#                                                          #
# Указывает должен ли sshd проверить режимы доступа и      #
# владения пользовательских папок и файлов перед тем, как  #
# дать пользователю войти. Обычно это объясняется тем, что #
# новички часто делают свои файлы доступными для записи    #
# всем подряд.По умолчанию - “yes”.                        #
#                                                          #
StrictModes yes
#                                                          #
## AcceptEnv ###############################################
#                                                          #
# Указывает, какие переменные окружения, переданные        #
# клиентом будут приняты. См. опцию SendEnv в клиенте.     #
# Стоит заметить, что передача переменных возможна только  #
# для протокола ssh2. Переменные указываются по имени,     #
# можно использовать маски (‘*’ и ‘?’). Можно указывать    #
# несколько переменных через пробел, или разбить на        #
# несколько строк AcceptEnv. Будьте осторожны - некоторые  #
# переменные окружения могут быть использованы для обхода  #
# запрещенных пользовательских окружений. Пользуйтесь этой #
# директивой аккуратно. По умолчанию никакие               #
# пользовательские переменные окружения не принимаются.    #
#                                                          #
AcceptEnv LANG LC_*
#                                                          #
## PermitUserEnvironment ###################################
#                                                          #
# Указывает, должен ли sshd воспринимать                   #
# ~/.ssh/environment и опцию environment= в                #
# ~/.ssh/authorized_keys. По умолчанию - “no”. Стоит       #
# заметить, что разрешение обработки окружения может дать  #
# пользователям возможность обойти ограничения в некоторых #
# конфигурациях, использующих такие механизмы, как         #
# LD_PRELOAD.                                              #
#                                                          #
#                                                          #
## PidFile #################################################
#                                                          #
# Указывает файл, содержащий идентификатор процесса        #
# (process ID, PID) демона SSH.                            #
# По умолчанию - /var/run/sshd.pid                         #
#                                                          #
#                                                          #
## PrintLastLog ############################################
#                                                          #
# Указывает, должен ли sshd выводить на экран дату и время #
# последнего севнса при интерактивном входе пользователя.  #
# По умолчанию - “yes”.                                    #
#                                                          #
PrintLastLog yes
#                                                          #
## PrintMotd ###############################################
#                                                          #
# Указывает, должен ли sshd выводить на экран /etc/motd    #
# при интерактивном входе пользователя. На некоторых       #
# системах (например в Ubuntu) эта информация так же       #
# выводится на экран оболочкой.                            #
# Значение по умолчанию - “yes”.                           #
#                                                          #
PrintMotd no
#                                                          #
## Banner ##################################################
#                                                          #
# Указывает какой файл содержит текстовый баннер, который  #
# будет показан пользователю ПЕРЕД процедурой              #
# аутентификации. Опция доступна только для протокола ssh2.#
# По умолчанию - не показывает ничего.                     #
# В Ubuntu файл issue.net содержит фразу Ubuntu {version}, #
# например, для karmic это &quot;Ubuntu 9.10&quot;. Можно            #
# использовать для дезориентации возможных атакующих,      #
# написав туда например &quot;My D-Link Interet Router&quot; =)      #
#                                                          #
Banner /etc/issue.net
#                                                          #
## ChrootDirectory #########################################
#                                                          #
# Если указан - предоставляет путь, по которому будет      #
# выполнен chroot после аутентификации. Путь и все его     #
# содержимое должны соответствовать принадлежащим          #
# суперпользователю папкам и быть не доступными для        #
# записи другими пользователями.                           #
# В пути могут быть указаны метки, подставляемые в         #
# процессе аутентификации:                                 #
# %% - заменяется литералом &rsquo;%&rsquo;                            #
# %h - заменяется домашней директорией                     #
# аутентифицируещегося пользователя                        #
# %u - заменяется именем аутентифицируещегося пользователя #
# chroot-папка должна содержать все необходимые файлы и    #
# папки для пользовательского сеанса. Для интерактивного   #
# сеанса нужны как минимум:                                #
# оболочка, обычно - sh                                    #
# базовые устройства в /dev, такие как:                    #
# null, zero, stdin, stdout, stderr, arandom и tty         #
# для сеанса передачи данных при помощи sftp никаких       #
# дополнительных настроек не нужно, если используется      #
# внутренний процесс sftp сервера. См. Subsystem для       #
# большей информации. По умолчанию chroot не выполняется.  #
#                                                          #
## ForceCommand ############################################
#                                                          #
# Заставляет выполняться указанную команду. Игнорирует     #
# любые команды переданные клиентом или записанные в       #
# ~/.ssh/rc. Команда вызывается из пользовательской        #
# оболочки с опцией -с. Подходит для запуска оболочки,     #
# команды или подсистемы. Наиболее полезна внутри блока    #
# Match. Команда, изначально переданная клиентом, хранится #
# в переменной окружения SSH_ORIGINAL_COMMAND. Если        #
# указать команду &quot;internal-sftp&quot;, будет запущен           #
# внутренний sftp сервер, которому не нужны дополнительные #
# файлы и папки, описанные в директиве ChrootDirectory.    #
#                                                          #
## Subsystem ###############################################
#                                                          #
# Определяет и настраивает внешнюю подсистему (например    #
# демона передачи файлов - file transfer daemon).          #
# Аргументами служат имя и команда (с возможными           #
# аргументами), которая будет выполнена во время запроса   #
# на подсистемы. Команда sftp-server  запускает “sftp” -   #
# подсистему передачи файлов. Дополнительно можно указать  #
# в качестве подсистемы “internal-sftp” - что запустит     #
# внутренний sftp сервер. Это может значительно упростить  #
# настройку в случае использования директивы               #
# ChrootDirectory По умолчанию никаких подсистем           #
# не вызывается. Актуально только для протокола ssh2.      #
#                                                          #
Subsystem sftp /usr/lib/openssh/sftp-server
#                                                          #
############################################################
##################### Блок Match ###########################
############################################################
#                                                          #
# Специально вынес в конец файла, чтобы было удобнее       #
# писать Match правила.                                    #
#                                                  MadKox. #
#                                                          #
# Директива Match представляет собой начало условного      #
# блока. Если выполнены все критерии, указанные в строке   #
# Match, директивы в последующих строках блока выполняются,#
# позволяя обойти значения глобальных директив файла       #
# sshd_config для случая, являющегося критерием директивы  #
# Match. Блоком считаются все строки, идущие после строки  #
# с критерием (Match - строки) до следующей match-строки   #
# или до конца файла. Аргумент директивы Match - одна или  #
# несколько пар записей критериев. Возможные виды записей: #
# User                                                     #
# Group                                                    #
# Host                                                     #
# Address                                                  #
# Записи могут содержать как одиночные значения            #
# (например User=user), так и несколько значений,          #
# разделенные запятыми (User=user1,user2). Так же могут    #
# быть использованы регулярные выражения, описанные в      #
# секции PATTERNS файла ssh_config. Записи в критерии      #
# Address могут содержать адреса в нотации CIDR            #
# (Адрес/Длинна маски, например “192.0.2.0/24” или         #
# “3ffe:ffff::/32”). Стоит заметить, что представленная    #
# длинна маски должна соответствовать адресу, и слишком    #
# длинные/короткие для адреса не будут работать.           #
# В качестве директив Match может использовать только      #
# определенный набор директив:                             #
# AllowTcpForwarding                                       #
# Banner                                                   #
# ChrootDirectory                                          #
# ForceCommand                                             #
# GatewayPorts                                             #
# GSSAPIAuthentication                                     #
# HostbasedAuthentication                                  #
# KbdInteractiveAuthentication                             #
# KerberosAuthentication                                   #
# MaxAuthTries                                             # 
# MaxSessions                                              #
# PasswordAuthentication                                   #
# PermitOpen                                               #
# PermitRootLogin                                          #
# RhostsRSAAuthentication                                  #
# RSAAuthentication                                        #
# X11DisplayOffset                                         #
# X11Forwarding                                            #
# X11UseLocalHost                                          #
</pre></div>
<hr>
<a name="g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1"></a>
<div class="header">
<p>
Next: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="n" rel="next">Руководство 2</a>, Previous: <a href="#sshd_005fconfig_005fexample-2" accesskey="p" rel="prev">sshd_config_example 2</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="Rukovodstvo-po-nastroike-SSH-CA"></a>
<h2 class="chapter">16 Руководство по настройке SSH CA</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#g_t_0412_0441_0442_0443_043f_043b_0435_043d_0438_0435-SSH-_002d-_0431_0430_0437_043e_0432_0430_044f-_043d_0430_0441_0442_0440_043e_0439_043a_0430" accesskey="1">Вступление SSH - базовая настройка</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041e_0441_043d_043e_0432_044b-_0446_0435_043d_0442_0440_0430-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0446_0438_0438" accesskey="2">Основы центра сертификации</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0412_0441_0442_0443_043f_043b_0435_043d_0438_0435-_0438_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0421_0410-SSH" accesskey="3">Вступление использование СА SSH</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH-_041f_0440_043e_0434_043e_043b_0436_0435_043d_0438_0435-_002d-_0440_0430_0437_0440_0430_0431_043e_0442_043a_0430-CA-_043f_0443_043d_043a_0442-2" accesskey="4">SSH Продолжение - разработка CA пункт 2</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0413_0435_043d_0435_0440_0430_0446_0438_044f-_0441_043f_0438_0441_043a_0430-_043e_0442_0437_044b_0432_0430-_043a_043b_044e_0447_0435_0439-_0028KRL_0029" accesskey="5">Генерация списка отзыва ключей (KRL)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0410_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_044f-SSH-_0447_0435_0440_0435_0437-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-_0028_0441_0435_0440_0432_0435_0440_0029" accesskey="6">Аутентификация SSH через пользовательские сертификаты (сервер)</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#AuthorizedKeysCommand" accesskey="7">AuthorizedKeysCommand</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0420_0430_0431_043e_0442_0430-_0441-_0440_0430_0441_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435_043c-_043a_043b_044e_0447_0435_0439" accesskey="8">Работа с распределением ключей</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0420_0430_0431_043e_0442_0430-_0441-_0437_0430_043f_0430_0437_0434_044b_0432_0430_044e_0449_0438_043c_0438-_0441_0435_0442_044f_043c_0438" accesskey="9">Работа с запаздывающими сетями</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#X11-Forwarding">X11 Forwarding</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041f_0440_0438_043d_0443_0434_0438_0442_0435_043b_044c_043d_044b_0435-_043a_043e_043c_0430_043d_0434_044b">Принудительные команды</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_043f_0430_0440_0430_043c_0435_0442_0440_044b-_043e_0442_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430">параметры открытого ключа</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-IP-_0441-_0443_0441_0442_0440_043e_0439_0441_0442_0432_043e_043c-TUN">туннелирование IP с устройством TUN</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TCP-Forwarding-of-STDIN_002fSTDOUT">TCP Forwarding of STDIN/STDOUT</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SSH-_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-TCP">SSH туннелирование TCP</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_043f_043e_0442_043e_043a-_043f_043e_0434_043a_043b_044e_0447_0435_043d_0438_044f">поток подключения</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041a_043b_0438_0435_043d_0442-Config">Клиент Config</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0437_0430_0449_0438_0442_0430-_0437_0430_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430-SSH">защита закрытого ключа SSH</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_043d_0430_0448_0438-_043f_0435_0440_0432_044b_0435-_043a_043b_044e_0447_0438-SSH">наши первые ключи SSH</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="g_t_0412_0441_0442_0443_043f_043b_0435_043d_0438_0435-SSH-_002d-_0431_0430_0437_043e_0432_0430_044f-_043d_0430_0441_0442_0440_043e_0439_043a_0430"></a>
<div class="header">
<p>
Next: <a href="#g_t_041e_0441_043d_043e_0432_044b-_0446_0435_043d_0442_0440_0430-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0446_0438_0438" accesskey="n" rel="next">Основы центра сертификации</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Vstuplenie-SSH-_002d-bazovaya-nastroika"></a>
<h3 class="section">16.1 Вступление SSH - базовая настройка</h3>

<p>Когда-то давным-давно в месте, не слишком далеко, родился Интернет. В первые дни люди
использовали базовые протоколы для взаимодействия друг с другом и обмена информацией. Одна
партия этих протоколов позволяла людям удаленно подключаться к другому компьютеру и входить
в систему для интерактивной оболочки или передавать удаленные команды для обработки. Это
были telnet, rsh и rlogin. Были также rcp и ftp для передачи файлов. Все это было
замечательно, пока людям не нужно было запирать свои двери ночью, потому что соседи стали
слишком любопытными. Безопасность стала проблемой, и SSH родился.
</p>
<p>Сегодня большинство людей считают OpenSSH де-факто программным обеспечением для служб
SSH. Он содержит как серверный компонент (sshd), так и подсистему sftp (для замены FTP) и
несколько клиентов для обработки удаленных входов в систему и передачи файлов (ssh и scp).
Правда в том, что существует множество пакетов на выбор, для обоих связь на стороне
сервера и на стороне клиента с этими новыми протоколами. Я могу рассказать о некоторых из
них, но эта серия будет начинаться с OpenSSH, потому что он наиболее популярен в настоящее
время. Мы начнем с базовой настройки, а затем перейдем к более сложным настройкам, чтобы
покрыть различные потребности в зависимости от масштаба операции, требующей такого типа
организации доступа.
</p>
<p>Первоначальное объяснение того, как это работает, заключается в том, что пользователь на
рабочей станции A хочет иметь возможность удаленного входа на сервер B для выполнения
некоторой рабочей нагрузки. Помните, что каждый сеанс SSH состоит из фрагментов информации
на самом базовом уровне. Пользователь (User_A) на рабочей станции или сервере
(Workstation_A) хочет удаленно подключиться к серверу (Server_B) как некоторый пользователь
(User_B) для выполнения рабочей нагрузки. Мы будем использовать эти метки в дальнейшем,
чтобы описать, как настроить программное обеспечение для каждого типа сценария, который мы
хотим охватить. В конце концов будет задействована третья система (либо LDAP,
либо Certificate Authority, либо и то и другое), поэтому мы добавим метку _C, когда
дойдем до этого. На данный момент, просто помните, что “_A” будет представлять
“coming from” (приходящий из), а “_B” будет представлять “going to” (собирается в) для
направленности каждого потока сеанса.
</p>
<p>Таким образом, прежде чем User_A сможет подключиться к Server_B с SSH, Server_B должен
иметь запущенную службу SSH. Программное обеспечение может быть установлено из исходного
кода или из любой системы управления пакетами, которую поддерживает ваш сервер OS.
RPM/yum и DPKG/apt-get являются общими для систем на базе RedHat и Debian, соответственно.
В AIX есть installp/RPM. HP-UX имеет Swinstall. Просто используйте соответствующее
программное обеспечение для системы, которую вы поддерживаете, но помните, что для
некоторых из более продвинутых функций потребуются более новые версии OpenSSH, поэтому,
если вы попробуете что-то, и это не сработает, проверьте версию вашего сервера.
</p>
<p>Теперь, когда OpenSSH sshd был установлен с помощью любых средств, которые вы выбрали,
User_A требуется клиентское программное обеспечение. Здесь должно быть то же самое дело,
как раньше. Используйте любое программное обеспечение для управления пакетами, которое
вы выберете. Существует клиент OpenSSH через проект Cygwin для Windows для “follow along”,
когда ваша рабочая станция - Windows, но другие клиенты могут работать лучше для
большинства этих сценариев. PuTTy и его производные, WinSCP, MobaXTerm - отличные клиенты
для Windows. Однако когда мы добираемся до соединений на основе сертификатов, их может быть
недостаточно. Просто установите клиент OpenSSH сейчас на любой платформе, с которой вы
работаете, и давайте двигаться дальше.
</p>
<p>Теперь у Workstation_A и Server_B есть программное обеспечение, необходимое для
установления соединения. Если User_A хочет подключиться к Server_B как User_B,
учетная запись “User_B” должна существовать на сервере или, по крайней мере, быть
пользователем, который может проходить аутентификацию (LDAP или аналогичный). Пока мы
будем предполагать, что используются локальные учетные записи. Таким образом, чтобы
установить соединение, User_A на Workstation_A необходимо знать пароль для User_B на
Server_B. Затем введите следующее, чтобы установить соединение (при условии, что
учетная запись активна и не заблокирована).
</p>
<p>Как User_A из терминальной подсказки:
</p><div class="display">
<pre class="display">ssh User_B@Server_B
</pre></div>
<p>Это так просто. Это почти не стоит освещать, я знаю. Тем не менее, каждая публикация
в этой серии будет делать шаг к тому, чтобы все работало более гладко с точки зрения
эксплуатации и безопасности, так что оставайтесь со мной. Далее мы рассмотрим
настройку пар открытого и закрытого ключей для аутентификации без пароля.
</p>
<hr>
<a name="g_t_041e_0441_043d_043e_0432_044b-_0446_0435_043d_0442_0440_0430-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0446_0438_0438"></a>
<div class="header">
<p>
Next: <a href="#g_t_0412_0441_0442_0443_043f_043b_0435_043d_0438_0435-_0438_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0421_0410-SSH" accesskey="n" rel="next">Вступление использование СА SSH</a>, Previous: <a href="#g_t_0412_0441_0442_0443_043f_043b_0435_043d_0438_0435-SSH-_002d-_0431_0430_0437_043e_0432_0430_044f-_043d_0430_0441_0442_0440_043e_0439_043a_0430" accesskey="p" rel="prev">Вступление SSH - базовая настройка</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Osnovy-centra-sertifikacii"></a>
<h3 class="section">16.2 Основы центра сертификации</h3>

<p>Принцип работы OpenSSH Certificate Authority зависит от нескольких компонентов.
Во-первых, должен быть один доверенный подписывающий орган. Это может быть любая
система, и для этого необходимо, чтобы было ИСКЛЮЧЕНО активное подключение к сети,
этой системы и рукопожатие client/server происходило с использованием подписанных
ключей CA. Должен также быть Key Revocation List, а также средство для обновления
KRL. Правильная Identity и платформа Access Management (IAM) могли бы справиться
с этим. Быстродействие можно достигнуть с помощью подходящего инструментария
Configuration Management/Server Automation, таким как Puppet, Chef, Salt, или Ansible.
Мы не будем рассматривать использование любого из этих инструментов в этой серии,
но мы (скорее всего) рассмотрим альтернативное решение, когда ни одна из предыдущих
рекомендаций не доступна. Сейчас мы только представим основные понятия и основы
работы OpenSSH Certificate Authority.
</p>
<p>Давайте настроим участников. Есть человек (User_A), которому нужно войти на целевую
машину (Server_A) под своим именем. Он делает вход со своего ноутбука (Workstation_A.)
Обычно User_A генерирует свою пару ключей, регистрируется в Server_A под своим именем
и помещает открытый ключ в файл author_keys в своей домашней директории. Вместо этого
мы собираемся привлечь нового участника, который действует как доверенная третья
сторона. Это будет Certificate Authority (CA). CA должен запускаться
непривилегированным пользователем на сервере, который либо не подключен напрямую к сети,
либо защищен. Практическая возможность подписи также должна быть ограничена небольшой
группой людей. Для нашего примера предположим, что он изолирован от сети.
</p>
<p>Мы предполагаем, что CA уже настроен, но вот шаги, которые нужно было сделать для этого.
Создайте непривилегированного пользователя (и группу) для подписи. Переключитесь на
этого пользователя и создайте структуру каталогов подписи CA. Используйте ssh-keygen,
чтобы создать ключ(и) подписи сертификата.
</p>
<p>Есть два типа сертификатов, которые могут быть подписаны. Сертификат пользователя
аутентифицирует пользователей на серверах. Сертификат хоста аутентифицирует хосты
для пользователей. Зачем нам оба?
</p>
<p>Сертификат хоста дает нам возможность установить новый сервер в нашей среде, подписать
его ключи хоста центром сертификации, и тогда клиент узнает, что новый ключ в порядке,
не предлагая пользователю сначала доверять ключу. Это уменьшает некоторые проблемы с
управлением файлом known_hosts.
</p>
<p>Пользовательский сертификат дает нам возможность сообщить серверу, что с нашим ключом
все в порядке, без необходимости сначала помещать ключ на сервер. Это устраняет некоторые
проблемы с управлением распределением ключей.
</p>
<p>Подписанный сертификат пользователя может накладывать ограничения на подписанный открытый
ключ, включая все ограничения, которые мы обсуждали в разделе pre-amble для записей
authorized_keys.
</p>
<p>Давайте посмотрим на общий обзор рабочего процесса сейчас. Далее мы рассмотрим команды,
необходимые для поддержки вышеупомянутой структуры центра сертификации, а также команды
для подписи сертификатов хоста и пользователя.
</p>
<p>Сценарий рабочего процесса:
</p><div class="display">
<pre class="display">   Используется новая машина.

   Ключи хоста регенерируются (если, например, это клонированная виртуальная машина)
   и подписываются Certificate Authority. Этот подписанный сертификат помещается
   обратно на новый компьютер, и это все, что нужно, если клиенты настроены правильно.

   Чтобы клиент мог воспользоваться этим, ему нужна специальная запись known_hosts,
   которая начинается с @cert-authority и сопровождается открытым ключом для
   подписанных сертификатов хоста. Когда пользователь входит в систему на новом
   компьютере, поток подключения будет включать в себя сервер, представляющий
   сертификат хоста клиенту, который затем проверяет, что запись known_hosts
   “@cert-authority” может расшифровать сертификат хоста, и затем соединение
   успешно принимается. Это помогает предотвратить путаницу в специально созданных
   системах, когда IP или имена хостов регулярно меняются.
</pre></div>
<p>Сценарий рабочего процесса: новому пользователю необходим доступ к системе. Пользователь
генерирует свой ключ, отправляет открытый ключ для подписи и, когда сертификат получен,
помещает его в свой каталог .ssh вместе с остальными файлами, связанными с ключом.
Хост-машины уже настроены на доверие к центру сертификации в файле sshd_config. Когда
пользователь подключается к ssh, клиент представляет подписанный сертификат целевому
компьютеру. Sshd целевой машины открывает запись TrustedUserCAKeys, чтобы открыть
соответствующий открытый ключ для декодирования сертификата. При удачном декодировании,
соединение определяется как доверенное, как если бы ключ был в authorized_keys для
этого пользователя. Это помогает снизить нагрузку на управление несколькими файлами
authorized_keys для каждого пользователя.
</p>
<p>Конечно, в этом есть нечто большее, но мы рассмотрим более тонкие детали в течение
следующих разделов. В следующем разделе будет объяснение команд, необходимых для
настройки CA (включая списки отзыва и почему они важны).
</p>
<hr>
<a name="g_t_0412_0441_0442_0443_043f_043b_0435_043d_0438_0435-_0438_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0421_0410-SSH"></a>
<div class="header">
<p>
Next: <a href="#SSH-_041f_0440_043e_0434_043e_043b_0436_0435_043d_0438_0435-_002d-_0440_0430_0437_0440_0430_0431_043e_0442_043a_0430-CA-_043f_0443_043d_043a_0442-2" accesskey="n" rel="next">SSH Продолжение - разработка CA пункт 2</a>, Previous: <a href="#g_t_041e_0441_043d_043e_0432_044b-_0446_0435_043d_0442_0440_0430-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0446_0438_0438" accesskey="p" rel="prev">Основы центра сертификации</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Vstuplenie-ispolxzovanie-SA-SSH"></a>
<h3 class="section">16.3 Вступление использование СА SSH</h3>

<p>Прежде чем мы перейдем к сути обсуждения, нам нужно установить некоторые
определения. На прошлой неделе мы упоминали, что центр сертификации может
создавать сертификаты как для хостов, так и для пользователей. Мы собираемся
охватить оба сегодня. Если кажется, что мы повторяемся, то на самом деле
это не так. Обратите внимание, в каком разделе вы находитесь, когда будете
следовать, так как флаги будут отличаться.
</p><div class="display">
<pre class="display">    Определения:

    Certificate Authority (CA) – Доверенная третья сторона, которая подписывает
       ключи для производства сертификатов.
    User Key – Открытый ключ пользователя, который будет подписан CA для создания
       пользовательского сертификата.
    Host Key – Открытый ключ хоста, который будет подписан CA для создания
       сертификата хоста.
    User Certificate – Сертификат, сгенерированный CA из предоставленного ключа
       пользователя. Это уменьшает потребность в AuthorizedKeysFile или
       AuthorizedKeysCommand.
    Host Certificate – Сертификат, сгенерированный CA из предоставленного ключа
       хоста. Это упрощает управление known_hosts и делает этот процесс более
       безопасным.
    Principal – Средство ограничения действия сертификата определенным набором имен
       user/host. По умолчанию сгенерированные сертификаты действительны для всех
       пользователей или хостов.
    Trust – Для того чтобы выданный сертификат CA работал, серверу необходимо
       указать, чтобы он доверял CA, прежде чем он будет принимать пользовательские
       сертификаты, а клиенту нужно сказать, что он должен доверять CA, прежде
       чем он примет сертификаты хоста.
    Key Revocation List – Средство отзыва ключей и сертификатов, когда они больше
       не действительны.
    Validity Lifetime – Средство ограничения срока действия сертификата. Если
       сертификат становится недействительным после ограниченного периода времени,
       его необходимо будет повторно выдать с новым сроком действия. Это позволяет
       автоматически отзывать сертификаты в случае, если управление
       Key Revocation List упускает из виду предполагаемое удаление.
    Additional Limitations – Дополнительные ограничения могут быть применены к
       сертификатам в том же ключе, что и параметры префикса открытого ключа,
       описанные в предыдущем сообщении в блоге.
</pre></div>
<p>Первое, что нам нужно сделать после того, как вы настроете и защитите машину, на
которой будет установленн CA, - это добавить непривилегированного пользователя,
который будет использоваться для подписи ключей для выдачи сертификатов.
</p><div class="example">
<pre class="example">sudo groupadd -g 3000 sshca
useradd -m -u 3000 -g sshca -G sshca -c &quot;SSH Certificate Authority Signing User&quot; \
-s /bin/bash -d /home/sshca sshca
</pre></div>
<p>Теперь нам нужно построить структуру каталогов.
</p><div class="example">
<pre class="example">sudo -i -u sshca
mkdir -p {hostca,userca}
</pre></div>
<p>Далее нам нужно создать ключ, который будет использоваться для выдачи
сертификатов HOST.
</p><div class="example">
<pre class="example">cd hostca
ssh-keygen -t rsa -b 4096 -f host_ca -C &quot;Host Certificate Signing Key&quot;
</pre></div>
<p>Нам также необходимо создать ключ, который будет использоваться для
выдачи сертификатов USER.
</p><div class="example">
<pre class="example">cd ../userca
ssh-keygen -t rsa -b 4096 -f user_ca -C &quot;User Certificate Signing Key&quot;
</pre></div>
<p>На данный момент в каждом каталоге есть два файла. Файл закрытого ключа не
будет иметь расширения, а файл открытого ключа будет иметь расширение “.pub”.
Все сертификаты будут подписаны с использованием файла закрытого ключа, но
нам также нужен этот файл открытого ключа, поэтому не удаляйте его.
</p>
<p>Чтобы создать TRUST, необходимый серверу для распознавания USER CERTIFICATES,
подписанного нашим CA, нам нужно отправить этот открытый ключ USER CA на каждый
хост и установить параметр конфигурации. Вы можете разместить его где угодно,
но я рекомендую создать подкаталог в каталоге /etc/ssh для хранения этих ключей.
</p><div class="example">
<pre class="example">sudo mkdir -p /etc/ssh/sshca
</pre></div>
<p>Затем скопируйте файл pub из CA и вставьте его в этот каталог. Отредактируйте
файл /etc/ssh/sshd_config, чтобы включить эту директиву:
</p><div class="example">
<pre class="example">TrustedUserCAKeys /etc/ssh/sshca/user_ca.pub
</pre></div>
<p>Перезапустите sshd (или заставьте его перезагрузить файл конфигурации), и это
доверие должно быть создано.
</p>
<p>Чтобы воспользоваться этим доверием, для входа пользователя на сервер необходимо,
чтобы его открытый ключ был подписан USER CA. Это выдает сертификат, который
необходимо будет вернуть пользователю.
</p>
<p>Синтаксис для подписи ключа выглядит следующим образом:
</p><div class="example">
<pre class="example">ssh-keygen -s &lt;ca_key&gt; -I &lt;certificate_identity&gt; [-h] -n &lt;principals&gt; -O &lt;options&gt; \
-V &lt;validity_interval&gt; -z &lt;serial_number&gt; &lt;public_key_to_be_signed&gt;
</pre></div>
<div class="display">
<pre class="display">“ca_key” - это закрытый ключ для USER CA при подписании открытых ключей пользователя
   или закрытый ключ для HOST CA при подписании открытых ключей хоста.

“certificate_identity” - это “key identifier”, который регистрируется сервером,
   когда сертификат используется для аутентификации. Рекомендуется использовать
   для этого уникальный идентификатор, который распознается вашей организацией,
   поскольку вы можете настроить доверие для нескольких CAs. Для нашего примера,
   certificate_identity будет “unixseclab”.
</pre></div>
<p>Если это подпись HOST KEY, убедитесь, что вы включили флаг “-h”.
</p><div class="display">
<pre class="display">“principals” - это список пользователей, которые могут быть аутентифицированы с
   помощью этого USER CERTIFICATE. Кроме того, это список хостов, которые могут
   быть аутентифицированы с помощью этого HOST CERTIFICATE. Можно указать
   несколько принципалов, разделенных запятыми. Настоятельно рекомендуется
   установить в качестве субъекта имя пользователя или имя хоста сервера, для
   которого он выдан. Полная аутентификация может создать проблемы с
   криминалистикой.

“options” - это список ограничений, которые могут быть применены. Это как префиксы,
   которые мы упоминали ранее. Имейте в виду, что новейшие версии OpenSSH изменили
   одно поведение в отношении принудительных команд. Также обратите внимание, что
   “options” действительны только для USER CERTIFICATES. Вы должны были бы
   отключить “-O &lt;options&gt;” при выдаче HOST CERTIFICATES.
</pre></div>
<p>От неожиданностей:
</p><div class="display">
<pre class="display">    Начиная с OpenSSH 7.4, когда принудительная команда появляется как в сертификате,
    так и в разрешении “command=” для авторизованных ключей/принципалов, sshd теперь
    откажется принимать сертификат, если они не идентичны. Предыдущее
    (задокументированное) поведение, связанное с принудительным изменением команды
    сертификата над другим, может быть немного запутанным и подверженным ошибкам.
</pre></div>
<div class="display">
<pre class="display">“validity_interval” используется для установки не только даты истечения срока действия
    выданного сертификата, но также для установки даты начала в случае, если он станет
    действительным только в будущем.

“serial_number” - это произвольное число, которое можно назначить, чтобы
    упростить KEY REVOCATION.
</pre></div>
<p>Выпускаемое HOST CERTIFICATE должно находиться в том же каталоге, что и HOST KEYS.
Файл sshd_config необходимо изменить, чтобы включить новый “HostCertificate” для
каждого нового выпущенного HOST CERTIFICATE. Ключ HOST также должен все еще
существовать и иметь собственную запись “HostKey” в файле sshd_config. Не удаляйте
их в обмен на записи сертификата.
</p><div class="display">
<pre class="display">HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
HostCertificate /etc/ssh//etc/ssh/ssh_host_ecdsa_key-cert.pub
</pre></div>
<p>Когда сервер настроен для предоставления HOST CERTIFICATE, клиентская сторона
также должна быть настроена для TRUST CA, который его подписал. Для этого нам
нужно добавить следующую запись в пользовательский файл “known_hosts”:
</p><div class="example">
<pre class="example">@cert-authority *.example.com &lt;public key of the HOST CA that signed the host keys&gt;
</pre></div>
<p>Может потребоваться удалить существующие записи ключей хоста в файле known_hosts
для этого хоста, если он был недавно перенесен для использования сертификатов.
Чистый способ справиться с этим - создать резервную копию ваших known_hosts,
обнулить файл и добавить только строки сертификата (вручную). Затем каждый раз,
когда вы сталкиваетесь с хостом без сертификата, вы можете сравнить предложенное
введите ваш заведомо исправный ключ в резервную копию и примите, если он подходит
для хостов, которые еще не используют сертификаты.
</p>
<p>В следующем разделе мы рассмотрим Key Revocation Lists, проверку сертификатов и
запустим реальный пример генерации нашего исходного CA, подписи ключа хоста и
подписи ключа пользователя, а затем их использования, чтобы позволить клиенту
подключиться на сервер. 
</p>
<hr>
<a name="SSH-_041f_0440_043e_0434_043e_043b_0436_0435_043d_0438_0435-_002d-_0440_0430_0437_0440_0430_0431_043e_0442_043a_0430-CA-_043f_0443_043d_043a_0442-2"></a>
<div class="header">
<p>
Next: <a href="#g_t_0413_0435_043d_0435_0440_0430_0446_0438_044f-_0441_043f_0438_0441_043a_0430-_043e_0442_0437_044b_0432_0430-_043a_043b_044e_0447_0435_0439-_0028KRL_0029" accesskey="n" rel="next">Генерация списка отзыва ключей (KRL)</a>, Previous: <a href="#g_t_0412_0441_0442_0443_043f_043b_0435_043d_0438_0435-_0438_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0421_0410-SSH" accesskey="p" rel="prev">Вступление использование СА SSH</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="SSH-Prodolzhenie-_002d-razrabotka-CA-punkt-2"></a>
<h3 class="section">16.4 SSH Продолжение - разработка CA пункт 2</h3>
<p>SSH Продолжение - разработка CA пункт 2
</p>
<p>На прошлой неделе мы рассмотрели большинство объяснений и команд для поддержки
SSH CA. На этой неделе мы рассмотрим Key Revocation List (KRL) и как проверить
сгенерированные сертификаты. Мы также включим демонстрацию asciinema процесса.
Давайте начнем.
</p>
<p>Когда вы генерируете сертификат, один из флагов позволяет вам создать &rsquo;область&rsquo; действия
сертификата. Это больше, чем срок действия, потому что он также включает в себя дату,
когда сертификат впервые становится действительным. Это отличный способ создания
определенных пользовательских сертификатов, поскольку вам может потребоваться
предоставить пользователю доступ только на четыре часа в выходные дни, и вы можете
выдать сертификат в течение рабочей недели, но он будет работать только тогда, когда
начальная дата/время достигнуто и перестает работать, когда достигнута дата/время
окончания.
</p>
<p>Теперь давайте предположим, что вы выпускаете сертификаты на срок один год для
постоянных сотрудников. Сотруднику выдается свидетельство, которое вступает в силу
с первого февраля этого года, что означает, что его необходимо будет переиздать к
следующему февралю. Если сотрудник меняет рабочее место и больше не нуждается в
доступе к тем же наборам серверов, этот сертификат теперь является проблемой. У
них есть доступ к системам, которым они обладать  не должны, и необходимо отозвать
этот доступ. Для этого мы должны использовать Key Revocation List.
</p>
<p>В нашем примере KRL создается USER CA и должен распространяться на каждый хост
при каждом обновлении. Это средство распространения очень похоже на управление
файлами authorized_keys, и означает, что оно может быть громоздким. Это, по
крайней мере, управление одним файлом, хотя это еще на один файл больше от
идеала.
</p>
<p>Со страницы руководства sshd_config:
</p><div class="display">
<pre class="display">    RevokedKeys
    Указывает отозванный файл открытых ключей или ни один, чтобы не использовать
    его. Ключи, перечисленные в этом файле, будут отклонены для аутентификации
    с открытым ключом. Обратите внимание, что если этот файл недоступен для чтения,
    аутентификация с открытым ключом будет отклонена для всех пользователей. Ключи
    могут быть указаны в виде текстового файла с указанием одного открытого ключа
    в строке или в виде OpenSSH Key Revocation List (KRL), сгенерированного
    ssh-keygen(1). Для получения дополнительной информации об KRLs см. Раздел
    KEY REVOCATION LISTS в ssh-keygen(1).
</pre></div>
<p>Хорошо.  Теперь, проверим справочную страницу ssh-keygen:
</p><div class="display">
<pre class="display">    ssh-keygen умеет управлять OpenSSH format Key Revocation Lists (KRLs). В этих
       двоичных файлах указываются ключи или сертификаты, которые должны быть
       отозваны в компактном формате; для каждого сертификата требуется всего
       один бит, если они аннулируются по серийному номеру.

    serial: serial_number[–serial_number]
       Аннулирует сертификат с указанным серийным номером. Серийные числа являются
       64-битными значениями, не включая ноль, и могут быть выражены в десятичном,
       шестнадцатеричном или восьмеричном виде. Если заданы два серийных номера,
       разделенных дефисом, то анулируется весь диапазон серийных номеров, включая
       каждый из них. Ключ CA должен быть указан в командной строке ssh-keygen
       с использованием параметра -s.
</pre></div>
<p>Раньше мы говорили, что для KRL нужен серийный номер? Вот почему. Пользователь
генерирует свои ключи. Они посылают вам свой открытый ключ для подписи. Вы
подписываете ключ для генерации сертификата и отправляете ему сертификат. На этом
этапе нужно правильно удалить свою копию открытого ключа AND выданного сертификата.
</p>
<p>Теперь когда у этого человек был взломана рабочая станция, ключу больше нельзя
доверять. Вы, естественно, не можете просто дождаться истечению срока действия
сертификата. У этого человека была привилегированная роль, и вы хотите, чтобы
SURE аутентификация была полностью отменена, но только для этого одного
сертификата, который был выпущен. Вам необходимо выполнить оператор KRL, но
у вас нет копии действующего сертификата или открытого ключа, который нужно
отозвать. В этом случае вам нужно отозвать по серийному номеру.
</p>
<p>Предполагается, что серийный номер является уникальным, поэтому рекомендуется
создавать серийные номера по схеме. Вы могли бы рассмотреть что-то вроде
“a UID number + some base range” (номер UID + некоторый базовый диапазон).
Если UID пользователя равен 2352, и вы устанавливаете базовый диапазон из
четырех цифр, например, первый серийный номер будет 235320001. Этот номер будет
увеличиваться при каждой выдаче сертификата для этого пользователя. Либо
зарегистрируйте серийный номер в базе данных для каждого выданного сертификата,
чтобы его можно было быстро найти. Это, работает лучше всего.
</p>
<p>Когда приходит время отозвать все сертификаты, которыми может обладать
пользователь (в случае нескольких действительных сертификатов), вы также
можете отозвать их с помощью ID.
</p>
<p>Помните, что при создании сертификата флаг “-z” предназначен для установки
серийного номера, а флаг “-I” - для идентификатора. При отзыве сертификата
вы будете использовать флаг “-k”, как показано ниже:
</p><div class="example">
<pre class="example">ssh-keygen -s &lt;ca_key&gt; -I &lt;certificate_identity&gt; -u -k
ssh-keygen -s &lt;ca_key&gt; -z &lt;serial_number&gt; -u -k
</pre></div>
<p>Причина, по которой мы указываем флаг “-u”, заключается в том, что он заставит
обновить KRL, а не заменить его новым. Это означает, что мы случайно не удалим
другие аннулирования, которые все еще должны присутствовать.
</p>
<p>Каковы некоторые проблемы с этим решением?
</p>
<p>Если мы укажем серверу использовать KRL, файл должен существовать, иначе sshd
не запустится. Это означает, что там должен быть пустой файл, если сервер настроен
для указания на файл KRL, и нет пока ключей для фактического отзыва. Если системный
администратор, незнакомый с этим, удаляет файл, потому что он пуст, при попытке
очистить файлы нулевой длины в системе, sshd при следующем перезапуске не запустится.
</p>
<p>KRL должен управляться для каждого конечного сервера. Это очень похоже на проблему
обработки отдельных файлов author_keys для каждого сервера. Причина, по которой я
специально упомянул проблему с серийным номером, состоит в том, чтобы точно
определить сценарий, в котором мы не отменяем доступ для определенного пользователя,
поскольку его больше нет, но отозвали сертификат ONE для этого пользователя из-за
нарушения.
</p>
<p>Есть несколько способов справиться с ситуацией KRL. Вы можете создать скрипт, который
извлекает KRL с одного сайта и вставляет его в задание cron. Вы можете использовать
процесс rsync, чтобы выдавать его нескольким конечным точкам каждый раз, когда файл
обновляется. Ни один из них не идеален, но я рекомендую NOT сделать что-то, что
кажется легким, но может вызвать кошмары в крошечные часы утра в один из выходных
для какого-нибудь неудачного инженера по вызову. Обязательно укажите конфигурацию
на общий сетевой ресурс с поддержкой сети. Если бы общий ресурс выпадал, файл больше
не был бы там в глазах sshd, и, если никто не заметил, при следующем перезапуске
службы (скажем, поздним ночным автоматическим обновлением ОС) sshd отказался бы
запускаться. Вы можете рассмотреть возможность использования общего сетевого ресурса,
но используйте сценарий, который регулярно проверяет наличие файла для обновления,
прежде чем копировать его на место локально. Что бы вы ни выбрали, решение не будет
красивым.
</p>
<p>Еще одна заметка об KRLs. Вы можете проверить наличие сертификата или ключа в
списке отзыва с флагом “-Q” для ssh-keygen.
</p><div class="example">
<pre class="example">ssh-keygen -Q -f &lt;KRL_file&gt; &lt;key_or_certificate_file&gt;
</pre></div>
<p>Пришло время для перехода к проверке сертификатов. Для проверки сертификата
используйте флаг ssh-keygen “-L”.
</p><div class="example">
<pre class="example">ssh-keygen -L -f &lt;key_or_certificate_file&gt;
</pre></div>
<p>Вот как выглядит пример файла:
</p><div class="display">
<pre class="display">$ ssh-keygen -Lf ./.ssh/id_rsa-cert.pub
./.ssh/id_rsa-cert.pub:
Type: ssh-rsa-cert-v01@openssh.com user certificate
Public key: RSA-CERT 04:29:a8:fd:55:04:db:8f:1e:0d:45:18:a7:8e:a7:a6
Signing CA: RSA 27:cc:19:a3:67:1b:5e:2e:6a:48:a9:25:25:6d:64:6c
Key ID: &quot;root&quot;
Serial: 1234
Valid: forever
Principals:
root
Critical Options: (none)
Extensions:
permit-X11-forwarding
permit-agent-forwarding
permit-port-forwarding
permit-pty
permit-user-rc
</pre></div>
<hr>
<a name="g_t_0413_0435_043d_0435_0440_0430_0446_0438_044f-_0441_043f_0438_0441_043a_0430-_043e_0442_0437_044b_0432_0430-_043a_043b_044e_0447_0435_0439-_0028KRL_0029"></a>
<div class="header">
<p>
Next: <a href="#g_t_0410_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_044f-SSH-_0447_0435_0440_0435_0437-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-_0028_0441_0435_0440_0432_0435_0440_0029" accesskey="n" rel="next">Аутентификация SSH через пользовательские сертификаты (сервер)</a>, Previous: <a href="#SSH-_041f_0440_043e_0434_043e_043b_0436_0435_043d_0438_0435-_002d-_0440_0430_0437_0440_0430_0431_043e_0442_043a_0430-CA-_043f_0443_043d_043a_0442-2" accesskey="p" rel="prev">SSH Продолжение - разработка CA пункт 2</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Generaciya-spiska-otzyva-kliuchei-_0028KRL_0029"></a>
<h3 class="section">16.5 Генерация списка отзыва ключей (KRL)</h3>

<p>KRL - это компактный двоичный формат, который позволяет отзывать подписанные
          сертификаты SSH.
</p>
<p>Создать пустой список отзыва:
</p><div class="example">
<pre class="example">❯ touch /etc/ssh/revoked_keys
</pre></div>
<p>Обновите /etc/ssh/sshd_config, чтобы включить новый список отзыва ключей:
</p><div class="example">
<pre class="example">❯ RevokedKeys /etc/ssh/revoked_keys
</pre></div>
<p>При необходимости отозвать первый подписанный сертификат:
</p><div class="example">
<pre class="example">❯ ssh-keygen -k -f revoked_keys -s sshuser.root.ca.pub foo-cert.pub
</pre></div>
<p>При необходимости добавьте больше отозванных сертификатов (используя -u):
</p><div class="example">
<pre class="example">❯ ssh-keygen -k -f revoked_keys -s sshuser.root.ca.pub -u bar-cert.pub
</pre></div>
<p>Проверка, что отзыв сработал:
</p><div class="example">
<pre class="example">❯ ssh-keygen -Qf revoked_keys foo-cert.pub
</pre></div>
<p>Распространите обновленный revoked_keys на каждый хост (/etc/ssh/revoked_keys)
          с помощью rsync, scp  или другой утилиты.
</p>
<p>ПРИМЕЧАНИЕ: ssh-keygen не должен требовать подписанный публичный сертификат для
его отзыва. Вместо этого следует использовать только серийный номер. Тем не менее,
в настоящее время это не работает на OpenSSH 7.2p2 (Ubuntu).
</p>
<hr>
<a name="g_t_0410_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_044f-SSH-_0447_0435_0440_0435_0437-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-_0028_0441_0435_0440_0432_0435_0440_0029"></a>
<div class="header">
<p>
Next: <a href="#AuthorizedKeysCommand" accesskey="n" rel="next">AuthorizedKeysCommand</a>, Previous: <a href="#g_t_0413_0435_043d_0435_0440_0430_0446_0438_044f-_0441_043f_0438_0441_043a_0430-_043e_0442_0437_044b_0432_0430-_043a_043b_044e_0447_0435_0439-_0028KRL_0029" accesskey="p" rel="prev">Генерация списка отзыва ключей (KRL)</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Autentifikaciya-SSH-cherez-polxzovatelxskie-sertifikaty-_0028server_0029"></a>
<h3 class="section">16.6 Аутентификация SSH через пользовательские сертификаты (сервер)</h3>

<p>Сложным аспектом безопасности является надежность и гарантия согласованности всех
мер безопасности. Вместо того чтобы полагаться на центральный орган аутентификации,
такой как LDAP или Kerberos, мы можем использовать преимущества SSH или, в частности,
OpenSSH, для обеспечения обоих составляющих.
</p>
<p>В дополнение к аутентификации доступа клиента SSH с помощью PIV и PKCS # 11, можно
повысить безопасность удаленной аутентификации SSH. Facebook и Yahoo перешли на
SSH User Certificates, чтобы избежать блокировки, если центральная система
аутентификации выходит из строя. Это также помогает поддерживать файл author_keys,
так как это плохо масштабируется (требуется соответствие 1:1).
</p>
<p>Центр сертификации пользователей SSH может подписывать и, таким образом, безопасно
проверять подлинность каждого клиента, подключающегося к серверу.
</p>
<p>Подписанный сертификат также обозначает участников (учетные данные), которые можно
использовать с этим сертификатом. Для каждого пользователя принципы могут быть
описаны в файле:
</p><div class="display">
<pre class="display">❯ mkdir /etc/ssh/auth_principals
❯ echo -e &rsquo;access-root&rsquo; &gt; /etc/ssh/auth_principals/root
❯ echo -e &rsquo;access-databases&rsquo; &gt; /etc/ssh/auth_principals/foobar
</pre></div>
<p>В этом примере любой подписанный сертификат с принципалом &rsquo;access-root&rsquo; будет разрешен
SSH вход на этот хост под именем корневого пользователя, и любой подписанный сертификат
с субъектом &rsquo;access-databases&rsquo;сможет войти в систему под именем пользователя foobar.
</p>
<p>Теперь давайте создадим центр сертификации пользователей SSH.
</p>
<p>Используя компьютер ,без доступа к сети, создайте центр сертификации пользователя:
</p><div class="example">
<pre class="example">❯ ssh-keygen -C &quot;SSH User Certificate Authority&quot; -f sshuser.root.ca
</pre></div>
<p>Распространите открытый ключ (sshuser.root.ca.pub) на /etc/ssh/ на каждом хосте.
    Убедитесь, что файл chmod 644.
</p>
<p>Обновите /etc/ssh/sshd_config, чтобы включить новый файл CA и принципалов:
</p><div class="example">
<pre class="example">TrustedUserCAKeys /etc/ssh/sshuser.root.ca.pub
AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u
</pre></div>
<p>Попросите пользователя/клиента извлечь открытый ключ из своего Yubikey, чтобы он мог
    быть подписан новым ЦС на компьютере отключенном от сети:
</p><div class="example">
<pre class="example">ssh-keygen -D /usr/local/opt/opensc/lib/pkcs11/opensc-pkcs11.so -e
</pre></div>
<p>Подпишите сертификат пользователя на отключеном от сети компьютере, уделяя особое
    внимание имени пользователя (&lt;user&gt;), принципалам, на которые этот сертификат сможет
    претендовать (&lt;principals&gt;,, разделенных запятыми), сроку действия сертификата
    (+52w) и серийному номеру (&lt;serial&gt;,, целому числу, которое следует отслеживать):
</p><div class="example">
<pre class="example">❯ ssh-keygen -s sshuser.root.ca -I &lt;user&gt; -n &lt;principals&gt; -V +52w -z &lt;serial&gt; &lt;user&gt;.pub
</pre></div>
<p>Подписанный ключ пользователя foobar-cert.pub: id &quot;foobar&quot; serial 1928121 для access-root
действует с 2016-12-10T00:10:00 по 2017-12-09T00:10:10
</p>
<p>Проверим, что сертификат пользователя выглядит хорошо:
</p><div class="display">
<pre class="display">❯ ssh-keygen -Lf &lt;user&gt;-cert.pub

user-cert.pub:
    Type: ssh-rsa-cert-v01@openssh.com user certificate
    Public key: RSA-CERT SHA256:NWmw3siRlxn3bsIhzaFrCsh66KKIWapFuZsNiDXhRLw
    Signing CA: RSA SHA256:HLD1Eb4XiCoyXew23skyisJt+3P02MOsrHHbK/DmlgY
    Key ID: &quot;foobar&quot;
    Serial: 1928121
    Valid: from 2016-12-10T00:10:00 to 2017-12-09T00:10:10
    Principals:
            access-root
    Critical Options: (none)
    Extensions:
            permit-X11-forwarding
            permit-agent-forwarding
            permit-port-forwarding
            permit-pty
            permit-user-rc

    Скопируйте &lt;user&gt;-cert.pub в каталог клиента ~/.ssh и назовите его
    id_rsa-cert.pub. Название довольно специфично, так как кажется, что
    opensc-pkcs11 имеет ограничение для обнаружения сертификата,
    отличного от id_rsa-cert.pub.
</pre></div>
<hr>
<a name="AuthorizedKeysCommand"></a>
<div class="header">
<p>
Next: <a href="#g_t_0420_0430_0431_043e_0442_0430-_0441-_0440_0430_0441_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435_043c-_043a_043b_044e_0447_0435_0439" accesskey="n" rel="next">Работа с распределением ключей</a>, Previous: <a href="#g_t_0410_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_044f-SSH-_0447_0435_0440_0435_0437-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-_0028_0441_0435_0440_0432_0435_0440_0029" accesskey="p" rel="prev">Аутентификация SSH через пользовательские сертификаты (сервер)</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="AuthorizedKeysCommand-1"></a>
<h3 class="section">16.7 AuthorizedKeysCommand</h3>

<p>Раннее мы кратко остановились на этом, но в этом разработан сценарий
для углубления в детали.
</p><div class="display">
<pre class="display">Итак, чтобы установить это, в настоящее время задействованы три системы.
1) Ноутбук Windows 10 с опцией “ubuntu on windows 10 on crack”. Используя оболочку
   bash, я создал пару ключей ssh ​​и остановился там, пока все остальное не было готово.
2) Система “target” для входа в систему. Это сервер OpenBSD, на котором я поиграл с
   asciinema ранее в эти выходные и решил использовать его для этой конкретной лаборатории.
   Это машина, которая будет настроена на использование AuthorizedKeysCommand и
   AuthorizedKeysCommandUser вместо AuthorizedKeysFile. На этом сервере я создал две
   новые группы и двух новых пользователей:
</pre></div>
<div class="display">
<pre class="display">groupadd testgrp
groupadd sshpub
useradd -m -g testgrp -G testgrp -c “Test User” -s /bin/ksh -d /home/testuser testuser
useradd -m -g sshpub -G sshpub -c “SSH Public Key Provider” \
-s /bin/ksh -d /home/sshpub sshpub

Я также создал новый скрипт: /usr/local/bin/query_ssh_pub.ksh с разрешениями 750 и
принадлежащий root:sshpub.
##############################################################################
#!/bin/ksh

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
HOSTNAME=$(hostname -s)
USER=${1}
ssh -i ~sshpub/.ssh/id_rsa sshpub@192.168.0.89 “/usr/local/bin/query_ssh_pub_keys.ksh \
${USER} ${HOSTNAME}”
##############################################################################

3) Система “query server” будет центральным хранилищем ключей ssh ​​для системных
учетных записей и/или пользователей (гипотетически). Я создал того же пользователя
и группу sshpub в этой системе, но добавил новый скрипт:
/usr/local/bin/query_ssh_pub_keys.ksh с разрешениями 750 и также принадлежащий
root:sshpub.
##############################################################################
#!/bin/ksh
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

if [ $# -ne 2 ]; then
exit 255
fi

USER=${1}
TARGET=${2}

echo ${USER} | grep -q -E -e ‘^[a-zA-Z0-9]+$’ || exit 255
echo ${TARGET} | grep -q -E -e ‘^[a-zA-Z0-9]+$’ || exit 255

ls /home/sshpub/key-store/ | grep -q “^${TARGET}\.${USER}\.pub\$” || exit 255
cat /home/sshpub/key-store/${TARGET}.${USER}.pub
##############################################################################
</pre></div>
<p>Я сгенерировал пару ключей ssh ​​из sshpub на сервере “TARGET”, а затем скопировал
файл открытого ключа на сервер “QUERY”, чтобы он мог выполнять удаленный вызов ssh. Если
бы я собирался использовать систему, подобную этой, в производстве, я бы применил еще
несколько проверок работоспособности ко всем входам, а также рассмотрел бы принудительную
команду для этого пользователя либо с помощью sshd_config, либо путем изменения файла
открытого ключа, но это ни тут ни там не используется. Это не идеальный способ получения
ключей, но он демонстрирует, как это работает простым способом.
</p>
<p>Когда все было готово, я поместил копию открытого ключа с ноутбука “CLIENT” в файл
/home/sshpub/key-store/asciicast.testuser.pub на сервере “QUERY”, а затем проверил, что
все команды работают должным образом.
</p>
<p>Наконец, я обновил sshd_config, чтобы использовать следующие записи на сервере “TARGET”,
и перезапустил sshd:
</p><div class="display">
<pre class="display">AuthorizedKeysCommand /usr/local/bin/query_ssh_pub.ksh
AuthorizedKeysCommandUser sshpub
</pre></div>
<p>После того, как все это было сделано, я смог проверить, могу ли я войти в систему как
“testuser” на машину “TARGET”, и он успешно получил открытый ключ с машины “QUERY”,
разрешив вход в систему, как и ожидалось.
</p>
<p>Сценарий запроса может вызвать любую службу, правда. Вы можете вызывать ключи,
хранящиеся в LDAP, SQL или любой другой базе данных. Окончательный результат,
возвращаемый скриптом, должен содержать ноль или более открытых ключей, и ничего
более. Чаще всего это делается для запроса к LDAP, и есть примеры файла LDIF для
OpenLDAP, свободно распространяющегося в Интернете, если вы решите пойти по этому пути.
Просто убедитесь, что ваш LDIF работает для вашей конкретной службы LDAP, и что вы
можете санировать вывод, чтобы только представить ключи в конце, когда вы запрашиваете.
</p>
<hr>
<a name="g_t_0420_0430_0431_043e_0442_0430-_0441-_0440_0430_0441_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435_043c-_043a_043b_044e_0447_0435_0439"></a>
<div class="header">
<p>
Next: <a href="#g_t_0420_0430_0431_043e_0442_0430-_0441-_0437_0430_043f_0430_0437_0434_044b_0432_0430_044e_0449_0438_043c_0438-_0441_0435_0442_044f_043c_0438" accesskey="n" rel="next">Работа с запаздывающими сетями</a>, Previous: <a href="#AuthorizedKeysCommand" accesskey="p" rel="prev">AuthorizedKeysCommand</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Rabota-s-raspredeleniem-kliuchei"></a>
<h3 class="section">16.8 Работа с распределением ключей</h3>

<p>Это будет краткий пост с не таким большим содержанием, но он объяснит,
куда мы идем отсюда.
</p>
<p>Одним из самых больших преимуществ SSH является дополнительный уровень шифрования,
который он обеспечивает. Вторым важным преимуществом является отсутствие необходимости
в пароле. Пароли могут быть заменены парольными фразами, что помогает сделать его еще
более безопасным. Однако существует риск, связанный с типом файлов vanilla
authorized_keys.
</p>
<p>Открытые ключи должны быть управляемыми. Что это значит? Открытый ключ должен быть
предоставлен соответствующим файлам authorized_keys вручную для каждого пользователя,
который использует преимущества этой системы. Когда пользователю требуется отозвать
доступ, файлы authorized_keys также должны быть проанализированы, чтобы убедиться,
в отсутствии записи ключа, к которому у этого пользователя больше нет доступа. Когда
вы удаляете пользователя из рабочей среды, его собственные файлы учетной записи
пользователя authorized_keys удаляются вместе с домашним каталогом, если вы используете
стандартную команду “userdel -r ”. Однако, если у них есть ключи для доступа к общей
учетной записи службы, такой как www, apache или аналогичная, необходимо выполнить
дополнительные шаги для проверки каждой системы, где может существовать этот ключ.
</p>
<p>Это может быть выполнено с помощью чего-то вроде puppet, chef или одного из других
распространенных инструментов управления типами обеспечения и конфигурации, или это
может быть сделано с помощью чего-то такого же простого, как распределенная проверка
ssh (dsh), но наличие нескольких файлов является кошмаром обеспечения , Предположим,
что система отключена, когда пользователь отключен. Без решения по управлению
конфигурацией/управлению доступом к учетным записям ваши ручные проверки могут
пропустить единственный ключ, всплывающий в файле author_keys.
</p>
<p>Так как мы справимся с этим? Есть несколько способов, и они не все включают инструменты
управления конфигурацией. Один из способов справиться с этим - использовать опцию
“AuthorizedKeysCommand” в sshd_config. Для его использования требуется второй параметр
(“AuthorizedKeysCommandUser”). Они позволяют вам установить скрипт, вызываемый
(мы надеемся) непривилегированным пользователем, который может запросить некоторую
службу для получения ключа для данного пользователя. Это может быть LDAP, SQL, плоский
файл на удаленной машине ... все, что возвращает ожидаемые результаты. Мы рассмотрим
это более подробно в следующем разделе.
</p>
<p>Другой вариант - настроить Certificate Authority для OpenSSH и подписать открытые
ключи вашего пользователя. Для обеспечения, это не требует инструмента управления
конфигурацией/управления доступом, но для отмены подготовки, это может произойти.
Тем не менее, вы можете автоматизировать это удаление по расписанию, чтобы избежать
решения CF/IAM, и мы рассмотрим такие настройки, когда перейдем к обзору
Certificate Authority через несколько разделов.
</p>
<p>В идеале вы могли бы рассмотреть возможность объединения этих методов в конце,
но мы сначала представим их как отдельные принципы и методы управления ключами.
</p>

<hr>
<a name="g_t_0420_0430_0431_043e_0442_0430-_0441-_0437_0430_043f_0430_0437_0434_044b_0432_0430_044e_0449_0438_043c_0438-_0441_0435_0442_044f_043c_0438"></a>
<div class="header">
<p>
Next: <a href="#X11-Forwarding" accesskey="n" rel="next">X11 Forwarding</a>, Previous: <a href="#g_t_0420_0430_0431_043e_0442_0430-_0441-_0440_0430_0441_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435_043c-_043a_043b_044e_0447_0435_0439" accesskey="p" rel="prev">Работа с распределением ключей</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Rabota-s-zapazdyvaiushchimi-setyami"></a>
<h3 class="section">16.9 Работа с запаздывающими сетями</h3>

<p>Один из аспектов серверов и клиентов, которые общаются друг с другом по сети, которая
иногда требует обработки, - как сохранить соединение открытым. Иногда сеть ненадежна
из-за отсутствия лучшего термина, и это означает, что пакеты могут быть отброшены.
OpenSSH не является исключением, и у него есть несколько опций, которые можно установить
в файлах sshd_config, ssh_config, и локальных ~/.ssh/config, чтобы помочь определить,
как обрабатывать такие случаи.
</p>
<p>И сервер, и клиент совместно используют опцию “TCPKeepAlive”. Этот параметр определяет,
следует ли отправлять сообщения поддержки активности TCP. Это помогает завершить
соединение в случае сбоя клиента или сервера, но может быть проблематичным в сети,
которая имеет значительную задержку. Однако, если он не установлен, это может означать,
что в пуле подключений к серверу может быть много пользователей-призраков, поэтому
рекомендуется включить его, если сеть не очень плохая. Возможные варианты: “yes” или
“no”, в зависимости от того, включен он или нет.
</p>
<p>Есть также “ClientAliveCountMax” (sshd_config) и “ServerAliveCountMax”
(ssh_config and ~/.ssh/config). Они устанавливают количество живых сообщений,
которые могут быть отправлены без получения клиентом или сервером ответа от
кореспондента. Эти сообщения отличаются от сообщений TCPKeepAlive. Живые сообщения
отправляются через зашифрованный канал и, следовательно, не могут быть подделаны. С
другой стороны, сообщения поддержки активности TCP могут быть подделаны, так что это
может быть лучшим вариантом в более (потенциально) враждебной среде. Этот параметр
является числом, и по умолчанию используется значение “3”. Помните, что это COUNT,
который считает количество раз, когда сообщение будет отправлено до завершения
сеанса из-за отсутствия ответа на другом конце.
</p>
<p>Другая переменная, необходимая для работы вышеупомянутого, - это
</p><div class="display">
<pre class="display">“ClientAliveInterval” (sshd_config) и
“ServerAliveInterval” (ssh_config and ~/.ssh/config)
</pre></div>
<p>Они определяют количество
секунд между отправляемыми сообщениями. По умолчанию используется “0”, что означает,
что ничего не отправлено, поэтому вы должны задать для этого значение больше 0,
чтобы включить эту опцию. Если для этого значения установлено значение “5” на
обоих концах, а для максимального числа активных пользователей по умолчанию
установлено значение “3,”, то соединение будет прервано через 15 секунд, если
сообщения не получат ответ.
</p>
<p>Помимо параметров TCPKeepAlive и *AliveCountMax и *AliveInterval, есть также
параметр, определяющий, как долго ждать успешного входа пользователя. Чтобы люди
не могли выполнить первоначальное рукопожатие по ssh-запросу, но не входить и не
связывать сокет. , это может быть установлено, и этот пользователь будет удален
через указанное количество времени. Значение по умолчанию составляет 120 секунд,
но если вам это вообще не нужно, вы можете изменить его на 0, чтобы отключить его,
как и параметры *AliveInterval.
</p>
<hr>
<a name="X11-Forwarding"></a>
<div class="header">
<p>
Next: <a href="#g_t_041f_0440_0438_043d_0443_0434_0438_0442_0435_043b_044c_043d_044b_0435-_043a_043e_043c_0430_043d_0434_044b" accesskey="n" rel="next">Принудительные команды</a>, Previous: <a href="#g_t_0420_0430_0431_043e_0442_0430-_0441-_0437_0430_043f_0430_0437_0434_044b_0432_0430_044e_0449_0438_043c_0438-_0441_0435_0442_044f_043c_0438" accesskey="p" rel="prev">Работа с запаздывающими сетями</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="X11-Forwarding-1"></a>
<h3 class="section">16.10 X11 Forwarding</h3>

<p>X11 - это протокол client/server, который означает, что вы можете запускать программное
обеспечение на одном компьютере и отображать его графический вывод на другом. Он также
имеет некоторые риски для безопасности, поэтому распространенным способом снижения
некоторых из этих рисков является предоставление SSH возможности пересылать клиентское
соединение X11 на локальный сервер X11 при запуске клиента в удаленной системе.
</p>
<p>Для некоторых это кажется обратным, но вы запускаете сервер на своей рабочей станции
и запускаете удаленную графическую команду как клиент, который обращается к вашему
серверу. Сервер генерирует графику от имени клиента. Если вы работаете на рабочей
станции с Linux, производной BSD или чем-то вроде одной из вилок OpenSolaris, вы,
вероятно, уже используете X11 для своих настольных ПК. Мы сделаем предположение,
что вы используете этот процесс.
</p>
<p>Чтобы выполнить пересылку X11, необходимо настроить удаленный сервер, чтобы разрешить
такую ​​пересылку. Имеют значение следующие параметры: “X11Forwarding yes” для включения
пересылки, “X11DisplayOffset 10” (default) для определения смещения для дисплея, который
будет использоваться, “X11UseLocalhost loopback” (default) для указания sshd связать
сервер пересылки с устройством обратной связи и
“XAuthLocation /usr/X11R6/bin/xauth” (default), если необходимо указать путь к
программе xauth, потому что она не находится по умолчанию в вашей системе.
</p>
<p>Может случиться так, что единственной настройкой, которую вам нужно настроить,
является “X11Forwarding” от “no” до “yes” в вашей целевой системе.
</p>
<p>После этого вы можете подключиться к целевой системе, передав флаги -X или -Y
клиенту ssh. Флаг -X применяет параметры ForwardX11Trusted для клиента ssh, которые
устанавливают более строгие ограничения на использование пересылки X11, а также
устанавливает 20-минутный таймер истечения срока действия для токена xauth. Флаг -Y
не устанавливает эти ограничения. Вам решать, какой флаг вы хотите использовать.
</p>
<p>После подключения вы можете проверить, правильно ли настроена ваша среда. У вас должен
быть файл “.Xauthority” в вашем домашнем каталоге, и у вас должна быть уже установлена 
переменная окружения под названием ${DISPLAY}, которая, вероятно, должна отображать
“localhost:10.0”, когда вы выводите его.
</p><div class="display">
<pre class="display">ls -ld .Xauthority
echo ${DISPLAY}
</pre></div>
<p>После того как вы подтвердите это, вы можете проверить свою переадресацию с помощью
чего-то простого, например, xeyes или xclock, если они установлены на целевой машине.
Если нет, попробуйте любую программу X11, которую вы намеревались запустить. Вы должны
увидеть, как программа появится на вашем рабочем столе, как только вы это сделаете.
</p>
<p>Наконец, если вам нужно запустить программу X11 от имени другого пользователя, вы
можете использовать команду xauth, чтобы объединить ваши токены .Xauthority с
окружением другого пользователя, а затем переключиться на этого пользователя для
запуска вашей команды. Вам нужно будет извлечь токен xauth для вашего DISPLAY и
объединить его для среды другого пользователя. Стандартный способ сделать это с
помощью “xauth extract”, переданного по каналу «xauth merge», как показано в полном
примере сеанса ниже.
</p><div class="display">
<pre class="display">ssh -Y User_A@Server_B
ls -ld .Xauthority
echo ${DISPLAY}
xclock
xauth extract – ${DISPLAY} | sudo -i -u User_B xauth merge –
#OR xauth extract – ${DISPLAY} | sudo su – User_B xauth merge –
sudo -i -u User_B #(или sudo su – User_B)
echo ${DISPLAY} #(Может потребоваться вручную установить это на то, что вы дали при входе в систему)
xclock
</pre></div>
<p>Конфигурация клиента имеет несколько настроек, чтобы всегда или никогда не устанавливать
это для вас. Вероятно, они должны быть установлены в блоках Match только для серверов,
на которых вам нужно регулярно запускать программы X, и не устанавливаться вообще.
</p><div class="display">
<pre class="display">ForwardX11 yes/no
ForwardX11Trusted yes/no
ForwardX11Timeout
XAuthLocation #как sshd_config
</pre></div>
<p>Формат времени будет числом, за которым следует блок модификатора. “S” или “s” для секунд.
“M” или “m” для минут и так далее вплоть до недель. По умолчанию если не указана ни одна
единица подразумевает секунды.
</p>
<p>Вы можете использовать команды xauth, чтобы удалить свои токены вручную, когда вы
закончите, выполнив “xauth remove ${DISPLAY}”, если пожелаете.
</p>
<p>Надеюсь, это помогло пролить некоторый свет на то, как заставить X11 Forwarding работать
от простого к сложному сценарию. Это один из наиболее часто задаваемых вопросов, которые
у меня были в прошлом, и я сожалею, что он не был рассмотрен раньше.
</p>
<hr>
<a name="g_t_041f_0440_0438_043d_0443_0434_0438_0442_0435_043b_044c_043d_044b_0435-_043a_043e_043c_0430_043d_0434_044b"></a>
<div class="header">
<p>
Next: <a href="#g_t_043f_0430_0440_0430_043c_0435_0442_0440_044b-_043e_0442_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430" accesskey="n" rel="next">параметры открытого ключа</a>, Previous: <a href="#X11-Forwarding" accesskey="p" rel="prev">X11 Forwarding</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Prinuditelxnye-komandy"></a>
<h3 class="section">16.11 Принудительные команды</h3>

<p>В прошлых разделах мы рассмотрели параметры ключа SSH, которые могут ограничивать
использование закрытого ключа для подключения к серверу. Одной из этих опций была
опция “command=”, которая позволяет ограничить ключ вызовом только одной команды,
независимо от команды, выданной как часть попытки соединения ssh. Есть несколько
способов обеспечить это.
</p>
<p>Вы можете использовать опцию открытого ключа “command=”, которую мы уже рассмотрели.
Вы также можете использовать настройки sshd_config для применения опции ForceCommand.
Это наиболее полезно для применения того же сценария принудительной команды, который мы
описали в прошлом разделе с помощью директивы “Match User”. Это также полезно для
применения ситуации только с sftp к данному пользователю, так что единственное, что может
сделать пользователь, - это передать файлы. Опция будет выглядеть так, если это ваша цель:
</p><div class="display">
<pre class="display">ForceCommand internal-sftp
</pre></div>
<p>Оболочка пользователя должна быть действительной, чтобы это работало, поскольку
принудительная команда вызывается через “ -c”. Это означает, что оболочка
/bin/false или /bin/nologin не нужна. Поскольку вы заставляете команду, это
должно быть меньшей проблемой.
</p>
<p>Наконец, есть также способ заставить эту команду с помощью параметров ssh-keygen при
подписании ключа через систему центра сертификации для OpenSSH, но мы более подробно
расскажем об этом, когда перейдем к материалу CA.
</p>
<p>Параметры принудительной команды не позволяют запускать пользовательский ~/.ssh/rc, так
что это не будет обходной путь, который пользователь может использовать для взлома этой
системы. ControlMaster переопределяет команду принудительного использования открытого
ключа, если опция установлена ​​после того, как основной сеанс уже установлен, поэтому вам
может потребоваться прервать все соединения ssh для этого пользователя после внесения
изменений, которые вводят ограничения, и двигаться вперед.
</p>
<p>Многие люди ворчат о параметрах принудительных команд, потому что считают, что для
каждой передаваемой команды необходим один ключ, но на самом деле есть средства для
обработки этого. Существует переменная окружения, которая устанавливается, когда сеанс
ssh, который хочет вызвать удаленную команду, используется для подключения, пока для
пользователя используется принудительная команда. Эта переменная окружения -
SSH_ORIGINAL_COMMAND, и она сохраняет запрошенную команду. Это означает, что у вас
может быть скрипт-обертка, который является вашей принудительной командой, он должен
проверить эту переменную среды на предмет работоспособности (все ли команды в списке
представлены в нашем белом списке или нет? Если нет, запишите отклонение и прекратите
работу. Если так , зарегистрируйте вызов и выполните.) Переменная сбрасывается, если
пользователь просто пытается войти в ssh, не вызывая удаленную команду, поэтому
обязательно проверьте это, если вы идете по этому пути. Предположим, что переменная
unset/empty (не установлена ​​/ пуста), что они пытались войти в систему для интерактивного
сеанса, и обработать, как вы считаете, лучше. Я бы предположил, что
“log a rejection and terminate” (зарегистрируйте отклонение и завершение) лучше,
хотя, поскольку интерактивный сеанс не может быть должным образом ограничен без
ограниченной оболочки, который все равно может быть поврежден из-за джейла в случае
неправильной настройки. Ваши собственные потребности могут отличаться. Просто будьте
очень тщательны в своем дизайне и убедитесь, что все входные данные очищены перед
выполнением, и все будет в порядке.
</p>
<hr>
<a name="g_t_043f_0430_0440_0430_043c_0435_0442_0440_044b-_043e_0442_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430"></a>
<div class="header">
<p>
Next: <a href="#g_t_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-IP-_0441-_0443_0441_0442_0440_043e_0439_0441_0442_0432_043e_043c-TUN" accesskey="n" rel="next">туннелирование IP с устройством TUN</a>, Previous: <a href="#g_t_041f_0440_0438_043d_0443_0434_0438_0442_0435_043b_044c_043d_044b_0435-_043a_043e_043c_0430_043d_0434_044b" accesskey="p" rel="prev">Принудительные команды</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="parametry-otkrytogo-kliucha"></a>
<h3 class="section">16.12 параметры открытого ключа</h3>

<p>Поскольку мы представили несколько способов туннелирования, я подумал, что сейчас
самое время рассказать о некоторых способах ограничения действий пользователя в случае,
если у него есть доступ к закрытому ключу, которого быть не должно.
</p>
<p>Мы уже говорили об установке парольной фразы на стороне закрытого ключа, но все еще
существует вероятность того, что пользователь смог это сделать грубо, поэтому предположим,
что у него есть доступ к этому секретному ключу. Какие у нас есть варианты для обеспечения
безопасности?
</p>
<p>Для начала, мы можем ограничить, из каких исходных имен IP/DNS может прийти пользователь,
используя этот ключ. Если мы изменим запись открытого ключа в файле author_keys для
включения директивы “from” до запуска ключа, мы можем предоставить список
IP addresses/hostnames, от которого мы ожидаем. Это предотвращает атаку с рабочей
станции пользователя, например. Одним из предостережений этого является то, что вы не
можете использовать источник NAT, так как это снизит эффективность этого ограничения.
Каждый, кто входит в коробку из источника NAT VLAN или подсети, выглядит так, как будто
он пришел из одного места.
</p>
<p>Чтобы установить эту директиву, нам нужно изменить открытый ключ вручную. Лучше
изменить открытый ключ перед добавлением его в файл authorized_keys, но вы можете
изменить запись файла authorized_keys для этого ключа, если хотите.
</p>
<p>Чтобы использовать эту директиву, нам нужно поставить опцию “from” со всеми ее значениями,
разделенными запятыми, BEFORE - ключ запускается. Вот пример того, как это может выглядеть:
</p><div class="display">
<pre class="display">   from=”172.16.84.1,lanturtle,lanturtle.mydomain” ssh-rsa AAAA User_A@lanturtle
</pre></div>
<p>Теперь предположим, что вы также хотите запретить проксирование с помощью этого ключа.
Чтобы ограничить это, нам нужно установить несколько параметров:
</p><div class="display">
<pre class="display">no-X11-forwarding – Предотвращает пересылку сеансов X11 обратно на X-сервер через
   туннель SSH.
no-port-forwarding – Предотвращает переадресацию портов через устройства TCP, TUN и
   прямое проксирование через stdin.
no-agent-forwarding – Предотвращает “forwarding” ssh-агента для обработки закрытого ключа.
</pre></div>
<p>Чтобы добавить их в приведенный выше пример, мы будем использовать список параметров,
разделенных запятыми:
</p><div class="display">
<pre class="display">from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding, \
    no-port-forwarding,no-agent-forwarding ssh-rsa AAAA User_A@lanturtle
</pre></div>
<p>Мы можем дополнительно ограничить это только разрешением использования этого конкретного
ключа для выполнения определенной команды. Это игнорирует любые команды, переданные
пользователем при подключении, и не дает пользователю получить полную оболочку входа
(если это не принудительная команда).
</p><div class="display">
<pre class="display">command=”/usr/local/bin/ssh-restricted-command.sh” (где
   “/usr/local/bin/ssh-restricted-command.sh” это команда, которую вы хотите запустить.
   Введите фактическую команду, которую вы хотите использовать, здесь.)
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding,no-port-forwarding, \
   no-agent-forwarding,command=”/usr/local/bin/ssh-restricted-command.sh” ssh-rsa  \
   AAAA User_A@lanturtle
</pre></div>
<p>Наконец, если мы хотим быть уверены, что в файле .ssh/rc пользователя нет наземной
мины, мы можем запретить ее чтение, используя следующую опцию:
</p><div class="display">
<pre class="display">no-user-rc
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding,no-port-forwarding, \
   no-agent-forwarding,no-user-rc,command=”/usr/local/bin/ssh-restricted-command.sh” \
   ssh-rsa AAAA User_A@lanturtle
</pre></div>
<p>Когда мы перейдем к управлению центром сертификации, вы обнаружите, что ssh-keygen может
установить эти параметры для ключей, связанных с сертификатами, но имена параметров
немного отличаются. К сожалению, использование ssh-keygen для генерации начального
открытого/закрытого ключа с этими параметрами не работает. Работает только на
сертификатах. Однако изменение записи открытого ключа вручную ограничивает это.
</p>
<hr>
<a name="g_t_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-IP-_0441-_0443_0441_0442_0440_043e_0439_0441_0442_0432_043e_043c-TUN"></a>
<div class="header">
<p>
Next: <a href="#TCP-Forwarding-of-STDIN_002fSTDOUT" accesskey="n" rel="next">TCP Forwarding of STDIN/STDOUT</a>, Previous: <a href="#g_t_043f_0430_0440_0430_043c_0435_0442_0440_044b-_043e_0442_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430" accesskey="p" rel="prev">параметры открытого ключа</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="tunnelirovanie-IP-s-ustroistvom-TUN"></a>
<h3 class="section">16.13 туннелирование IP с устройством TUN</h3>

<p>Мы рассмотрели различные  tunneling/proxy  (туннелирование/прокси) возможности OpenSSH
для туннелирования TCP и настройки прокси портов, но флаг “-w” может позволить вам
пересылать IP-трафик. Это происходит путем создания временного устройства “tun” при
подключении по SSH, которое можно настроить как любой сетевой интерфейс с помощью
стандартных инструментов, таких как “ifconfig”. Должно произойти некоторое последующее
установление соединения, включая изменение информации таблицы маршрутов, поэтому
относитесь к этому как к нормальному и правильному решению VPN. Вот что это значит.
Решение VPN, встроенное в клиентское и серверное программное обеспечение SSH. Я сделаю
правильную запись с лабораторией и примерами позже. А пока знайте, что на сервере
должна быть установлена ​​опция “PermitTunnel”, и для нее должно быть установлено
значение, отличное от “no”, которое является значением по умолчанию.
</p><div class="display">
<pre class="display">Варианты:
point-to-point – Это позволяет настраивать туннельное устройство уровня 3.
ethernet – Это позволяет настроить туннельное устройство уровня 2.
yes – Это позволяет настроить любой тип устройства.
</pre></div>
<p>При подключении к серверу необходимо передать флаг “-w” и указать идентификатор
устройства tun. Вы также можете указать идентификатор устройства удаленной настройки.
Если вы не предоставляете удаленный идентификатор, по умолчанию используется “any”,
который предоставляет следующий доступный. Вы также можете указать “any” для
идентификатора локального устройства настройки.
</p>
<p>В следующем примере настраивается определенный “tun0” как на локальной, так и на
удаленной стороне.
</p><div class="display">
<pre class="display">ssh -w 0:0 User_B@Server_B
</pre></div>
<p>Далее будет настроено устройство “tun” с использованием следующего доступного ID как
на локальной, так и на удаленной сторонах.
</p><div class="display">
<pre class="display">ssh -w any:any User_B@Server_B
</pre></div>
<p>Следующие действия сделают то же, что и в примере выше, но сохранят значение,
необходимое для ввода 4 символов.
</p><div class="display">
<pre class="display">ssh -w any User_B@Server_B
</pre></div>
<p>Просто настроить их будет недостаточно. Разумеется, вам также потребуется настроить
информацию routes/interface (маршруты/интерфейс). Вам также нужно будет настроить
все правила трафика для бастионного хоста (локального брандмауэра), если вы его
используете. Лучшее объяснение этому я нашел здесь:
Daemon Forums
</p>
<hr>
<a name="TCP-Forwarding-of-STDIN_002fSTDOUT"></a>
<div class="header">
<p>
Next: <a href="#SSH-_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-TCP" accesskey="n" rel="next">SSH туннелирование TCP</a>, Previous: <a href="#g_t_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-IP-_0441-_0443_0441_0442_0440_043e_0439_0441_0442_0432_043e_043c-TUN" accesskey="p" rel="prev">туннелирование IP с устройством TUN</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="TCP-Forwarding-of-STDIN_002fSTDOUT-1"></a>
<h3 class="section">16.14 TCP Forwarding of STDIN/STDOUT</h3>

<p>В предыдущем разделе мы рассмотрели стандартные флаги перенаправления TCP: -L, -R, и -D.
</p>
<p>Я явно воздержался от показа -W и -w, потому что чувствовал, что они заслуживают
отдельного освещения.
</p>
<p>Мы рассмотрим -w (работа с туннельными устройствами) в следующем разделе. Сейчас все о -W.
Прежде чем мы продолжим, вы должны заметить, что одна из моих публикаций в среду была
кратким обзором семейства инструментов netcat. Если вы думаете о “-W :” как о встроенном
netcat для ssh, вы довольно быстро поймете силу этого флага. Наиболее распространенный
пример использования этого флага - использование опции ProxyCommand для вызова SSH с
использованием Jumphost и передачи этого флага этому хосту. Старый способ использования
ProxyCommand таким способом заключался в том, чтобы фактически вызывать netcat в качестве
команды удаленного прокси-сервера, например так:
</p><div class="display">
<pre class="display">ssh -o ProxyCommand=’ssh jumphost netcat target_server 22′ target_server
</pre></div>
<p>Или, если “Server_B” является нашим прыжковым хостом, и мы действительно хотим
использовать “Server_A”, используя “Server_B” в качестве прокси, мы сделаем это
следующим образом:
</p><div class="display">
<pre class="display">ssh -o ProxyCommand=’ssh Server_B netcat Server_A 22′ Server_A
</pre></div>
<p>Это было все хорошо, если netcat был фактически установлен, но иногда это не так. К
счастью, SSH имеет свой собственный встроенный тип netcat через флаг -W. Чтобы сделать
то же самое, что и выше, мы бы сделали это вместо этого:
ssh -o ProxyCommand=”ssh -W %h:%p Server_B” Server_A
</p>
<p>Это короче, чище и не зависит от netcat в прокси-сервере перехода. Теперь давайте
сделаем еще один шаг вперед. Предположим, вы хотите перетащить страницу вниз с помощью
командной строки и хотите прокси через Server_B, чтобы получить эту страницу из Server_A.
</p><div class="display">
<pre class="display">echo “GET /some/page.html” | ssh -W Server_A:80 Server_B &gt;page.html
</pre></div>
<p>Почему вы можете захотеть сделать это? Если у вас нет прямого маршрута к Server_A на
этом порту, но вы можете получить доступ к Server_B через SSH, и ИТ-отдел имеет доступ к
Server_A на этом порту, у вас есть быстрый и грязный временный прокси.
</p>
<p>Давайте на минуту отложим этот мыслительный процесс и подумаем о том, сколько людей
пытаются заблокировать локальные учетные записи (хранящиеся в /etc/passwd.) Многие люди
будут предоставлять учетную запись процесса “/bin/false” как “shell”, чтобы предотвратить
вход в оболочку. Однако, если вы никогда не пытаетесь получить оболочку с этой учетной
записью, вы можете использовать эту учетную запись для прокси в течение всего дня с
настройками по умолчанию sshd_config. Если вы хотите отключить эту функцию (и вы должны
учитывать ее по причинам, указанным выше), вы должны установить для AllowTCPForwarding
значение “no” в файле sshd_config и перезапустить sshd.
</p>
<p>Сейчас в социальных сетях витает разговор о ботнете Internet of Things, который недавно
снял блог Кребса. Один из поставщиков безопасности предположил, что атака, которую они
называют “SSHowDowN”, и этот вид функциональности - именно то, на что они ссылаются.
</p>
<p>Подобные вещи действительно хороши, когда используются правильно, но они также опасны
для того, чтобы пробить дыры в списках контроля доступа маршрутизатора и
межсетевого экрана.
</p>
<hr>
<a name="SSH-_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-TCP"></a>
<div class="header">
<p>
Next: <a href="#g_t_043f_043e_0442_043e_043a-_043f_043e_0434_043a_043b_044e_0447_0435_043d_0438_044f" accesskey="n" rel="next">поток подключения</a>, Previous: <a href="#TCP-Forwarding-of-STDIN_002fSTDOUT" accesskey="p" rel="prev">TCP Forwarding of STDIN/STDOUT</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="SSH-tunnelirovanie-TCP"></a>
<h3 class="section">16.15 SSH туннелирование TCP</h3>

<p>Одним из значительных преимуществ SSH является возможность создания перенаправлений
переадресации портов для временного доступа к системе, которая в противном случае не
смогла бы получить доступ к машине. Это действительно легко настроить, и он работает
довольно хорошо для многих сценариев, но недостатком этого является то, что… это
действительно легко настроить и работает довольно хорошо для многих сценариев, для
которых вы можете не использовать его. Это можно использовать, чтобы пробить дыры в
правилах брандмауэра, и это может привести вас к горячим отношениям с не теми людьми,
поэтому убедитесь, что вы понимаете свою корпоративную политику, прежде чем пытаться
использовать что-то подобное на работе.
</p>
<p>SSH обеспечивает несколько видов переадресации портов TCP, поэтому мы рассмотрим их
по одному. На этот раз мы НЕ будем рассматривать туннелирование устройств “TUN” через
флаг -w. Это будет рассмотрено позже.
В этот раз мы также НЕ будем рассматривать стандартную переадресацию ввода/вывода через
флаг -W. Это будет только охватывать пересылку TCP.
</p>
<p>Первый тип пересылки TCP, который мы рассмотрим, это Dynamic Port Forwarding
(используя SOCKS4/SOCKS5 протокол). Флаг для этого - -D и принимает необязательный
“bind_address” и требуемый “port”, который будет передан ему.
</p><div class="display">
<pre class="display">-D [bind_address:]port
</pre></div>
<p>Это создает прослушивающий сокет локально на предоставленном порту и, необязательно,
заданный адрес bind_address, который будет действовать как прокси-сервер уровня
приложения SOCKS4 / SOCKS5. Лучше всего настроить это на привязку к localhost, а затем
использовать один из других параметров туннелирования, чтобы указать на него, чтобы
защитить прокси от пользователей, которым вы не хотите его использовать. Конечно, любой,
кто может получить доступ к машине через ssh, сможет использовать это, так что будьте
внимательны с тем, где вы его настроили. Любое приложение, поддерживающее SOCKS, может
воспользоваться этим, если оно может подключаться к порту прослушивания.
</p>
<p>Следующие два параметра на самом деле одно и то же, но один настраивает порт прослушивания
на локальном (клиентском) компьютере, а другой настраивает порт прослушивания на удаленном
(серверном) компьютере. Флаги -L и -R соответственно.
</p><div class="display">
<pre class="display">-L [bind_address:]port:host:hostport
-R [bind_address:]port:host:hostport
</pre></div>
<p>Если вы хотите перенаправить локальный (клиентский) прослушивающий порт на удаленный
компьютер, используйте “L” для “local”.
Если вы хотите перенаправить удаленный (серверный) прослушивающий порт на клиентский
компьютер, используйте “R” для “remote”.
</p>
<p>Другими словами, этот “listening port” связан локально или удаленно и является одним
концом туннеля. “host” и “hostport” не обязательно совпадают с целевым сервером, к
которому вы подключаетесь через SSH. Они просто должны быть хостом и портом, к
которому удаленная система может фактически добраться.
</p>
<p>“-L 8080:example.com:80” связывает локальный порт 8080 с клиентом, когда он устанавливает
соединение с удаленным ssh-сервером. Затем удаленный ssh-сервер связывает соединение с
портом 80 на example.com на его конце. Оттуда вы сможете локально подключиться к порту
8080 на своей клиентской машине и подключиться к этому удаленному серверу example.com
через его порт 80, все через туннель через ssh на сервер ssh.
</p>
<p>“-R 2222:localhost:22” создаст прослушивающую привязку “localhost” к порту 2222 на
удаленном сервере, который указывает на порт 22 на локальном клиенте. Если вы
подключитесь к этому вне вашей сети, это позволит людям вне сети подключаться по ssh с
этой удаленной машины, если они имеют правильные учетные данные.
</p>
<p>Все эти опции, как указано, создают оболочку при входе в систему. Вы можете установить
JUST туннель, используя опции “-N” “-T” и “-f”.
</p><div class="display">
<pre class="display">“-N” говорит не вызывать удаленную команду, просто установить туннели.
“-T” говорит не устанавливать псевдо-TTY (PTY) терминал, что подходит, так как вы
     не передаете никаких команд.
“-f” говорит SSH работать в фоне, так как вы, вероятно, хотите сделать больше работы
     после установления сеанса.

ssh -fNT -L localhost:8080:google.com:80 User_B@jumphost
</pre></div>
<p>Это говорит фоновому SSH после установки туннеля и не выделяет PTY. Установите
туннель с локально связанным портом 8080, и пусть удаленный ssh-сервер “jumphost”
установит туннель к “google.com” на порту 80. Подключитесь как User_B к ssh-серверу.
</p>
<p>Вы можете проверить с помощью “netstat -an | grep LISTEN”, есть ли у вас прослушивающий
порт 8080 после установки этого. Вы можете протестировать туннель с помощью netcat или
telnet к localhost через порт 8080 и ввести “GET /”, а затем нажать Enter. Возможно, вам
придется нажать Enter дважды, в некоторых случаях. Вам придется заменить “User_B” и
“jumphost” на реальную систему, к которой у вас есть доступ, которая также имеет доступ
к Интернету, конечно.
</p>
<hr>
<a name="g_t_043f_043e_0442_043e_043a-_043f_043e_0434_043a_043b_044e_0447_0435_043d_0438_044f"></a>
<div class="header">
<p>
Next: <a href="#g_t_041a_043b_0438_0435_043d_0442-Config" accesskey="n" rel="next">Клиент Config</a>, Previous: <a href="#SSH-_0442_0443_043d_043d_0435_043b_0438_0440_043e_0432_0430_043d_0438_0435-TCP" accesskey="p" rel="prev">SSH туннелирование TCP</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="potok-podkliucheniya"></a>
<h3 class="section">16.16 поток подключения</h3>

<p>Прежде чем мы перейдем к более сложным вещам с настройкой SSH, я подумал, что нам
следует взглянуть на то, что на самом деле происходит, когда клиент подключается к
серверу OpenSSH, и что такое дерево решений для предоставления или не предоставления
доступа.
</p>
<p>Со страниц руководства sshd:
</p><div class="display">
<pre class="display">Когда пользователь успешно входит в систему, sshd делает следующее:
1. Если для входа используется tty, а команда не указана, печатается время последнего
   входа и /etc/motd (если это не запрещено в файле конфигурации или с помощью
   ~/.hushlogin; см. Раздел FILES).
~/.hushlogin
   Этот файл используется для подавления печати времени последнего входа в систему и
   /etc/motd, если PrintLastLog и PrintMotd, соответственно, включены. Он не подавляет
   печать баннера, указанного в Banner.
2. Если логин на tty, записывает время входа.
3. Проверяет /etc/nologin; если он существует, печатает содержимое и выходит (если не root).
4. Изменения для запуска с правами обычного пользователя.
5. Устанавливает основную среду.
6. Читает файл ~/.ssh/environment, если он существует, и пользователям разрешено
   изменять свою среду. Смотрите опцию PermitUserEnvironment в sshd_config(5).
~/.ssh/environment
   Этот файл считывается в среду при входе в систему (если он существует). Он может
   содержать только пустые строки, строки комментариев (начинающиеся с ‘#’) и строки
   присваивания в форме name=value (name = value). Файл должен быть доступен для записи
   только пользователю; это не должно быть доступно для чтения кем-либо еще. Обработка
   среды по умолчанию отключена и управляется с помощью опции PermitUserEnvironment.
7. Изменения в домашнем каталоге пользователя.
8. Если ~/.ssh/rc существует, запускает его; иначе, если /etc/ssh/sshrc существует,
   запускает его; в противном случае работает Xauth. Файлы “rc” получают протокол
   аутентификации X11 и cookie при стандартном вводе. Смотрите SSHRC ниже.
~/.ssh/rc
   Содержит процедуры инициализации, которые должны быть выполнены до того, как домашний
   каталог пользователя станет доступным. Этот файл должен быть доступен для записи только
   пользователю, и не должен быть доступен для чтения кем-либо еще.
9. Запускает пользовательскую оболочку или команду.
</pre></div>
<p>Итак, из вышесказанного мы можем увидеть еще несколько способов управления нашим
клиентским подключением и что он выводит при подключении. Раньше мы рассмотрели
“LogLevel QUIET” в файле ~/.ssh/config, но мы также можем воспользоваться файлом
“.hushlogin” для подавления некоторой информации.
</p>
<p>Мы также видим, что логин регистрируется, только если есть связанный TTY. Это важно
помнить для судебно-медицинской экспертизы.
</p>
<p>Мы можем временно отключить вход в систему с SSH (отличным от root), создав файл
/etc/nologin, и содержимое этого файла будет отображаться при отклонении попытки
подключения. Это опасно, если у вас нет доступа к консоли, поэтому будьте осторожны с этим.
</p>
<p>Служба отбрасывает привилегии и устанавливает базовую среду, затем настраивает ее из
файла ~/.ssh/environment, если он существует, и пользователям разрешается изменять свою
среду. Поведение по умолчанию запрещает это, но это нужно проверить при блокировке ваших
систем. Наконец, он переходит в домашний каталог пользователя, чтобы завершить подготовку
среды.
</p>
<p>Затем он читает и автоматически запускает файл ~/.ssh/rc, если он существует. Это также
важно знать для судебной экспертизы и для блокировки вашей системы. Это отличное место
для того, чтобы отказаться от постоянного недостоверного сценария, поэтому его стоит
поискать и просмотреть.
</p>
<p>Наконец, он запускает оболочку или любую команду, которая была запрошена. Кажется
довольно просто, верно? Ну, man-страницы на этом заканчиваются.
</p>
<p>Таким образом, с точки зрения защиты, мы хотим рассмотреть больше, чем просто файлы
~/.ssh/{config,authorized_keys,authorized_keys2,known_hosts}. Мы также хотим посмотреть
на любые файлы rc и environment в этом каталоге. Это особенно верно для пользователя root.
</p>
<hr>
<a name="g_t_041a_043b_0438_0435_043d_0442-Config"></a>
<div class="header">
<p>
Next: <a href="#g_t_0437_0430_0449_0438_0442_0430-_0437_0430_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430-SSH" accesskey="n" rel="next">защита закрытого ключа SSH</a>, Previous: <a href="#g_t_043f_043e_0442_043e_043a-_043f_043e_0434_043a_043b_044e_0447_0435_043d_0438_044f" accesskey="p" rel="prev">поток подключения</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="Klient-Config"></a>
<h3 class="section">16.17 Клиент Config</h3>


<p>На этой неделе мы сосредоточимся на файлах конфигурации на стороне клиента и на том, как
их использовать, чтобы сделать ssh более приятным. В конфигурационных файлах много опций,
поэтому мы собираемся разбить это на разные части. Мы рассмотрим некоторые общие настройки,
с которыми люди могут захотеть поиграть, чтобы сделать обработку сессий более эффективной,
а затем, после того, как мы обсудим некоторые более сложные темы в течение следующих
нескольких разделов, мы выполним вторую часть, чтобы рассмотреть некоторые из более
продвинутых параметров конфигурации, связанные с этими ранее затронутыми темами Это
означает, что вторая часть не будет в следующем разделе.
</p>
<p>Есть два файла по умолчанию, которые обрабатывают конфигурацию ssh на стороне клиента
в OpenSSH. Глобальный файл обычно находится по адресу /etc/ssh/ssh_config и содержит
все настройки по умолчанию для всех пользователей системы. Пользователь также может
написать параметры конфигурации, которые переопределяют глобальный файл конфигурации,
включив файл “config” в каталог .ssh этого пользователя. Когда вызывается ssh-клиент,
порядок приоритета при разборе параметров покрывается следующим образом:
</p><div class="display">
<pre class="display">1. опции командной строки
2. пользовательский конфигурационный файл (~/.ssh/config)
3. общесистемный конфигурационный файл (/etc/ssh/ssh_config)
</pre></div>
<p>Все, что указано в командной строке, превосходит все остальное. Конфигурация пользователя
превосходит общесистемную конфигурацию. Общесистемный конфиг охватывает все, что не было
явно переопределено двумя другими. Это имеет смысл, но важно знать, каков приоритет
синтаксического анализа при устранении неполадок.
</p>
<p>Сейчас акцент будет сделан на файле ~/.ssh/config, который должен содержать
пользовательские настройки.
</p>
<p>Одним из первых параметров, которые я установил в своем собственном конфиге, является
настройка “LogLevel”. Я предпочитаю подавлять постороннюю информацию (например, баннеры),
потому что мне нравится обрабатывать отчеты с нескольких серверов, и я хочу получать
информацию только из команд, которые я запускаю, а не что-нибудь еще. Для подавления этих
сообщений я использую:
</p><div class="display">
<pre class="display">LogLevel QUIET
</pre></div>
<p>Вы можете настроить его на любой уровень шума, который вы предпочитаете, вплоть до
DEBUG3, что эквивалентно “ssh -vvv” для “verbose debugging”. Однако я не рекомендую
использовать для этого конфигурацию пользователя. Просто используйте флаги для
переопределения и используйте конфигурацию для подавления, как указано выше.
</p>
<p>Следующий набор опций, которые люди часто используют, - это настройки “Match,” “User,”
“Host,” и “HostName”.
Параметр “User” используется для установки того, какое целевое имя пользователя должно
использоваться при входе в в систему. Это похоже на переход от сценария
User_A@Workstation_A к сценарию User_B@Server_B, который мы создали ранее. В этом
случае установка “User User_B” будет означать, что вы можете набрать “ssh Server_B”,
и он будет знать, что в качестве цели будет использоваться “User_B” вместо значения
по умолчанию “User_A”.
</p>
<p>Опция “Host” устанавливает блок для опций, которые применяются к данному имени хоста до
следующего блока “Host” или “Match”. Имя может соответствовать шаблону с подстановочными
знаками и может включать отрицание начинающееся с “!”, если это необходимо.
</p><div class="display">
<pre class="display">“Host !*.web.com”

    сказал бы, что “the following settings up to and not including the next Match or Host
    block apply to all systems that are NOT like *.web.com” (следующие настройки вплоть
    до следующего блока Match или Host и без него применяются ко всем системам, которые
    НЕ являются *.web.com).
</pre></div>
<p>Предыдущий пример плохой, но в нем есть смысл. Чтобы установить глобальное содержимое
внизу, используйте параметр “Host *”, чтобы соответствовать всему, и более ранние блоки
Match/Host будут переопределять это по мере необходимости, так как они уже установили
значения, если что-то соответствует им.
</p>
<p>Опция “Match” используется для точной настройки соответствия различных объектов. Она
может сопоставить имя пользователя с “Match user” или адрес с “Match address” и так
далее. Вы можете сделать “Match host”, но использование “Host” в качестве опции блока,
вероятно, лучше для почти всех случаев.
</p>
<p>Опция “HostName” позволяет вам устанавливать псевдонимы в вашей конфигурации. Обычно это
устанавливается как опция после совпадения “Host”. Вы можете использовать “%h”, чтобы
указать имя хоста, которое было передано ssh в командной строке, прежде чем изменять его
с помощью “HostName”, так что “HostName” добавляется к нему по мере необходимости. Вы
также можете установить для этого адреса переопределение, например, всего, что
возвратил бы DNS.
</p>
<p>Используя то, что мы узнали, давайте предположим, что User_A хочет войти в систему как
User_B почти во всех случаях. Однако User_A является системным администратором AIX,
поэтому для виртуальной установки IO может потребоваться войти на сервер VIO, что
означает, что целевой пользователь, скорее всего, является “padmin”, а не User_A или
User_B. Кроме того, AIX управляется Hardware Management Console (HMC) (аппаратные
средства консоли управления), который часто использует пользователя “hscroot”, а не
локальные учетные записи. Конечно, каждый набор отличается, но это стандартная практика,
поэтому мы пойдем этим путем. Организация использует стандартную схему именования,
согласно которой все серверы VIO имеют имя, которое начинается с “vio”, за которым
следует некоторый уникальный идентификатор. Объект HMCs аналогичным образом называется
“hmc”, за которым следует некоторый уникальный идентификатор. Серверы VIO также находятся
в другом домене, отличном от стандартного, который называется ‘internal.net’. Мы также
знаем, что если пользователь входит в систему как root, ключ никогда не будет
использоваться, поэтому мы хотим пропустить обмен ключами и вместо этого ввести пароль для
root. Вооружившись этими знаниями, мы можем упростить жизнь в User_A’s, если создадим
конфигурацию, которая выглядит следующим образом:
</p><div class="display">
<pre class="display">LogLevel QUIET
Host vio*
   HostName “%h.internal.net”
   User padmin
Host hmc*
   User hscroot
Match user root
   PubkeyAuthentication no
   PasswordAuthentication yes
   PreferredAuthentications password
Match user User_B
   PreferredAuthentications publickey,password
Host *
   User User_B
</pre></div>
<p>Параметры, которые мы установили для блока “Match user root”, должны быть достаточно
понятными на данный момент. Вариантов намного больше, чем это, и мы рассмотрим их в конце
концов, но это неплохой общий обзор того, как со временем создать конфигурацию. Не
забудьте поставить свои глобальные элементы внизу, так как они читаются сверху вниз
до первого совпадения, которое и используется для установки.
</p>
<hr>
<a name="g_t_0437_0430_0449_0438_0442_0430-_0437_0430_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430-SSH"></a>
<div class="header">
<p>
Next: <a href="#g_t_043d_0430_0448_0438-_043f_0435_0440_0432_044b_0435-_043a_043b_044e_0447_0438-SSH" accesskey="n" rel="next">наши первые ключи SSH</a>, Previous: <a href="#g_t_041a_043b_0438_0435_043d_0442-Config" accesskey="p" rel="prev">Клиент Config</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="zashchita-zakrytogo-kliucha-SSH"></a>
<h3 class="section">16.18 защита закрытого ключа SSH</h3>

<p>В нашем предыдущем посте было показано, как сгенерировать пару ключей public/private без
использования пароля. Иногда это желаемая конфигурация, но лучше заблокировать закрытый
ключ с помощью ключевой фразы. Когда вы генерируете пару ключей, вы можете добавить
фразу-пароль в ответ на приглашение, также вы можете изменить существующую фразу-пароль
или добавить фразу-пароль для ключа, у которого её еще нет. Средства для этого показаны
ниже:
</p><div class="example">
<pre class="example">ssh-keygen -f ~/.ssh/id_rsa -p
</pre></div>
<p>Если существующая фраза пуста, это сразу же попросит вас ввести новую фразу-пароль. Если
существует фраза-пароль, она сначала запросит ввести её, прежде чем запрашивать новую.
Установка пароля на закрытый ключ является важным шагом для защиты этого ключа. Если
кому-то, не имеющему права использовать этот ключ, каким-либо образом удалось получить
его копию, он не сможет использовать ключ, пока не выяснит для него ключевую фразу. Хотя
можно грубо взломать ключ, если вы используете прилично длинную фразу, которая не является
чем-то обычно произносимым или написанным, шансы ее взлома снижаются. Также обратите
внимание, что ключевые фразы SSH допускают пробелы, так что вы можете буквально писать
бессмысленные предложения, пробелы и все остальное. Существует еще многое, что можно
сделать, чтобы снизить риск того, что кто-то использует украденный закрытый ключ для
причинения вреда, но это на стороне клиента, и есть предостережения.
</p>
<p>Теперь, когда у нас есть парольная фраза, защищающая наш закрытый ключ, что изменилось в
том, как работает ssh? Для начала, если вы не используете Агента для загрузки ваших ключей,
каждый раз, когда вы заходите на сервер, используя этот ключ, вам будет предложено ввести
пароль. Это делает удобство хуже, а не лучше. Чтобы использовать агент, запустите ssh-add.
Если вы используете стандартное имя ключа, такое как id_rsa, id_dsa, или id_ecdsa, он
автоматически найдет и загрузит этот ключ для вас. Для каждого ключа со стандартным именем,
которое он находит, он запросит пароль. Вы даете ему фразу, а остальное он обрабатывает.
Он действует от вашего имени до тех пор, пока не получит указание выгрузить ключ или не
будет остановлен. Когда вы войдете в систему, клиент SSH увидит, что агент работает, и
когда сервер запросит ключ, он передаст этот запрос агенту, который предоставит
подтверждение того, что он знает ключ, и, таким образом, вам не будет предложено ввести
пароль. Это похоже на быстрый SSH, но сначала требуется дополнительный шаг загрузки агента.
</p>
<p>Если вы получаете сообщение об ошибке при запуске ssh-add, есть вероятность, что
ssh-agent еще не запущен. Если это так, вы можете сначала запустить ssh-agent, взять
полученный вывод и экспортировать эти переменные. Например:
</p><div class="example">
<pre class="example">ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-w8iG9Aq6KWLR/agent.1070; export SSH_AUTH_SOCK;
SSH_AGENT_PID=1071; export SSH_AGENT_PID;
</pre></div>
<p>Если у вас есть ключ с пользовательским именем, например id_rsa_2016, вы можете загрузить
его, передав его имя, например, так:
</p><div class="example">
<pre class="example">ssh-add /home/User_A/.ssh/id_rsa_2016
</pre></div>
<p>Использование агента опасно в общей среде, где другие люди имеют повышенные привилегии.
Любой пользователь с правами root может извлечь приватный ключ из памяти, пока агент
работает от вашего имени. Вы можете выгрузить ключи перед блокировкой вашей рабочей
станции, если вы параноик, используя -D или -d, как показано ниже:
</p><div class="example">
<pre class="example">ssh-add -D #Delete all identities
ssh-add -d /home/User_A/.ssh/id_rsa_2016 #Удаляет только ключ id_rsa из списка агента
</pre></div>
<p>Вы также можете заблокировать и разблокировать свой агент, используя флаги “-x” и “-X”
соответственно, если вы не хотите полностью выгружать из соображений безопасности. Они
предложат вам ввести пароль для блокировки и разблокировки агента, если вы решите
использовать их.
</p>
<p>Если вы хотите увидеть, какие ключи загружены, вы можете перечислить их с помощью
“ssh-add -l”. И если вам необходимо убедиться, какой открытый ключ соответствует
загруженному закрытому ключу, вы можете использовать “ssh-add -L”.
</p>
<p>Наконец, если вы хотите установить ограничение по времени для загружаемого ключа, вы
можете использовать флаг -t, чтобы сделать его временным. Требуется число указывающее
(в секундах), как долго ключ должен оставаться загруженным агентом.
</p>
<p>Остальные флаги предназначены для более продвинутых вещей, о которых я расскажу отдельно,
поэтому это все, что мы расскажем на сегодня. Если вы до сих пор не отставали, то на
данный момент вы в значительной степени находитесь на уровне среднего пользователя SSH.
(И это еще не все.) Далее мы рассмотрим некоторые параметры конфигурации клиента,
чтобы упростить управление сеансами.
</p>
<hr>
<a name="g_t_043d_0430_0448_0438-_043f_0435_0440_0432_044b_0435-_043a_043b_044e_0447_0438-SSH"></a>
<div class="header">
<p>
Previous: <a href="#g_t_0437_0430_0449_0438_0442_0430-_0437_0430_043a_0440_044b_0442_043e_0433_043e-_043a_043b_044e_0447_0430-SSH" accesskey="p" rel="prev">защита закрытого ключа SSH</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="u" rel="up">Руководство 1</a> &nbsp; </p>
</div>
<a name="nashi-pervye-kliuchi-SSH"></a>
<h3 class="section">16.19 наши первые ключи SSH</h3>


<p>Раннее мы подготовили почву для установки и настройки SSH для входа в систему с паролем.
Это работает для многих людей, но не очень гибко. Что если пользователю необходимо
удаленно запустить рабочую нагрузку из сценария? Сценарию будет предложено ввести пароль,
и он не будет корректно обрабатываться без какого-либо помощника, такого как оболочка
Expect. Вызов perl для Expect.pm, или необработанное ожидание, основанное на TCL, или
одного из множества других языков с модулем Expect, добавит раздувание к тому, что
потенциально может быть скудным и средним сценарием оболочки, в итоге. Кроме того,
пароли часто легко взламываются, если целевая система (Server_B) плохо настроена для
обработки повторных попыток ввода пароля. Попытки грубой силы все время случаются на
машинах, обращенных к интернету. Так как же нам избавиться от необходимости пароля?
Мы будем использовать пару открытый/закрытый ключ для обработки аутентификации для нас.
</p>
<p>Помните, что лучшее место для генерации вашей пары открытых/закрытых ключей - это
пользователь на машине, к которой вы подключаетесь FROM. В нашем примере сценария это
будет User_A на Workstation_A. Генерация ключа может быть сложной, но сейчас мы просто
сгенерируем ключ без ключевой фразы. Далее мы расскажем об использовании ключевой фразы
на ключе, почему это важно сделать и как справиться с возможностью использовать сценарии
без запроса.
</p>
<p>Для генерации нашего начального набора ключей мы будем использовать утилиту ssh-keygen,
поставляемую OpenSSH.
</p><div class="example">
<pre class="example">ssh-keygen -t rsa -b 4096 -C “User_A@Workstation_A initial key”
</pre></div>
<p>Это должно запросить путь и имя (обычно home_directory/.ssh/id_rsa), где будет
сгенерирован ключ.
Она также должна запрашивать парольную фразу, но мы пока оставляем это поле пустым,
поэтому просто нажимайте “Enter”, чтобы двигаться дальше.
Наконец, она выполнит некоторые вычисления, выведет вывод “bubble babble” и завершит
работу. Как только это будет сделано, вы должны увидеть два новых ключа в каталоге,
созданные ей. Сделайте “ls -l ~/.ssh” и посмотрите, есть ли у вас файлы “id_rsa” и
“id_rsa.pub”, сейчас (при условии, что вы не меняли путь или имя при появлении запроса).
</p>
<p>Хорошо, с этой командой происходит несколько вещей. Во-первых, флаг “-t rsa” указывает
команде на создание ключей с использованием алгоритма шифрования RSA. “-b 4096” говорит,
чтобы сделать это алгоритм 4096 бит RSA. Флаг “-C” помещает в файл комментарий, который
помогает определить назначение ключа и того, кому он принадлежит. Этот комментарий
появляется в открытом ключе из пары. Если вы отследите этот файл, вы должны увидеть тег
комментария в конце ключа.
</p>
<p>Получив пару ключей, поймите, что файл “id_rsa” - это ваш закрытый ключ. Это должно быть
заблокировано (обычно с 600 разрешениями) и не должно копироваться ни в какие другие
системы (за исключением некоторых очень редких исключений.) Открытый ключ - “id_rsa.pub” и
это то, что вам нужно отправить для User_B на Server_B. Содержимое этого файла открытого
ключа фактически помещается в другой файл для этого пользователя. Они должны быть помещены
в файл ~User_B/.ssh/authorized_keys. Есть несколько способов избавиться от этого. Многие
люди предпочитают использовать команду “ssh-copy-id”, чтобы вытолкнуть это, но мне не
нравится, как она обычно обрабатывает файл authorized_keys. Она просто слепо добавляет
к нему. Я предпочитаю написать функцию, которая обрабатывает передачу содержимого на
удаленный сервер, а также выводит файл author_keys удаленного сервера, выводит выходные
данные и записывает их обратно в файл authorized_keys. Эта процедура гарантирует, что
только одна копия открытого ключа когда-либо будет отправлена, независимо от того, сколько
раз вы делаете это. Детали функции находятся в моем продукте
“DSH – Distributed/Dancer’s Shell”. Если вы еще не видите ссылку для этого, это потому,
что продукт проходит тестирование Alpha и скоро будет запущен как Beta. Я опубликую
ссылку, когда она выйдет в эфир, для тех, кто заинтересован.
</p>
<p>Как только открытый ключ окажется на удаленном сервере, убедитесь, что права доступа к
файлу авторизованному файлу также равны 600. Каталог .ssh должен быть 700. Домашний
каталог не должен быть доступен для чтения всем. Затем проверьте подключение от
User_A@Workstation_A к User_B@Server_B. Он должен “just work” и вывести вас в
командной строке. Если это не так, вы можете проверить журналы на удаленном сервере
(обычно /var/log/secure.log или /var/log/sshd.log или аналогичные) на наличие подсказок,
и вы можете повторить попытку соединения с “ssh -vvv”, чтобы получить подробный вывод для
других подсказок. Часто это ошибка прав доступа, поэтому дважды проверьте права доступа
к файлам.
</p>
<p>Теперь это позволит User_A на рабочей станции_A писать сценарии, которые могут вызывать
“ssh User_B@Server_B ” для запуска удаленных рабочих нагрузок, без запроса пароля.
</p>
<p>Однако это не самый лучший способ справиться с этим, поэтому мы рассмотрим, как защитить
личный ключ с помощью ключевой фразы в следующем разделе, и все же сможем сделать это,
не запрашивая при каждом соединении.
</p>
<div class="display">
<pre class="display">

How to Harden SSH with Identities and Certificates

    The Source Fantastic
    Blog Archive
    About

    2014-August-07
    Dublin Maker 2014
    New column: The Source Fantastic!
</pre></div>


<hr>
<a name="g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2"></a>
<div class="header">
<p>
Previous: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-1" accesskey="p" rel="prev">Руководство 1</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<a name="Rukovodstvo-2"></a>
<h2 class="chapter">17 Руководство 2</h2>


<p>Secure Shell [SSH], вероятно, является наиболее важным инструментом
административного доступа к вашим серверам. Это также одна из наименее
защищенных критически важных служб на большинстве серверов UNIX. Почему?
Потому что по какой-то причине люди все еще используют простые пароли
для защиты своих корневых учетных записей. Это не так плохо, как при
использовании telnet, но не слишком. Вы могли бы также использовать
обычный FTP для передачи данных на ваш сервер ... о, подождите, это
другая статья.
</p>
<p>Использование паролей для ваших удаленных серверов подвергает вас
целому классу ненужных угроз безопасности, которых легко избежать,
переключаясь на идентификаторы SSH или сертификаты SSH. Эта статья
будет охватывать оба, так как они концептуально очень похожи. Мы
будем очень тесно работать с файлами конфигурации OpenSSH, надеясь
объяснить некоторые из более пугающих опций, с которыми вы можете
столкнуться.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#g_t_041f_043e_0447_0435_043c_0443-_043f_0430_0440_043e_043b_0438-_043f_043b_043e_0445_043e-_0434_043b_044f-_0432_0430_0441" accesskey="1">Почему пароли плохо для вас</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041f_043e_0434_0433_043e_0442_043e_0432_043a_0430-_0441_0435_0440_0432_0435_0440_0430" accesskey="2">Подготовка сервера</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041e_0442_043a_043b_044e_0447_0435_043d_0438_0435-_0430_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438-_043d_0430-_043e_0441_043d_043e_0432_0435-_043f_0430_0440_043e_043b_044f" accesskey="3">Отключение аутентификации на основе пароля</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0421_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-SSH" accesskey="4">Сертификаты SSH</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0421_043e_0437_0434_0430_043d_0438_0435-_043a_043e_0440_043d_0435_0432_043e_0433_043e-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_0430" accesskey="5">Создание корневого сертификата</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430" accesskey="6">Подписание ключей хоста</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430" accesskey="7">Использование сертификатов ключей хоста</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044f" accesskey="8">Подписание ключей пользователя</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0445-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432" accesskey="9">Использование пользовательских сертификатов</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041e_0442_0434_0435_043b_044c_043d_044b_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0438-_0445_043e_0441_0442-_0421_0410">Отдельные пользовательские и хост СА</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_041e_0442_0437_044b_0432-_043a_043b_044e_0447_0435_0439-_0438-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432">Отзыв ключей и сертификатов</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0414_0430_043b_044c_043d_0435_0439_0448_0438_0435-_0443_043b_0443_0447_0448_0435_043d_0438_044f-_0431_0435_0437_043e_043f_0430_0441_043d_043e_0441_0442_0438">Дальнейшие улучшения безопасности</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0423_043a_0440_0435_043f_0438_0442_044c-_043e_0441_0442_0430_0432_0448_0438_0435_0441_044f-_043a_043b_044e_0447_0438">Укрепить оставшиеся ключи</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#g_t_0427_0442_043e-_0435_0449_0435-_043f_043e_0447_0438_0442_0430_0442_044c">Что еще почитать</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="g_t_041f_043e_0447_0435_043c_0443-_043f_0430_0440_043e_043b_0438-_043f_043b_043e_0445_043e-_0434_043b_044f-_0432_0430_0441"></a>
<div class="header">
<p>
Next: <a href="#g_t_041f_043e_0434_0433_043e_0442_043e_0432_043a_0430-_0441_0435_0440_0432_0435_0440_0430" accesskey="n" rel="next">Подготовка сервера</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Pochemu-paroli-plokho-dlya-vas"></a>
<h3 class="section">17.1 Почему пароли плохо для вас</h3>

<p>Мне будет нелегко объяснить энтропийную часть лучше, чем этот xkcd, но я
бы хотел подключиться к той части, где люди пытаются угадать ваши пароли. Если вы
недавно настроили новый сервер с SSH, вы, вероятно, обнаружили много шума в
системном журнале об ошибках аутентификации. Большинство из них будут вызваны
ботами, которые пытаются угадать общие сочетания имени пользователя и пароля - и
часто также пытаются использовать известные уязвимости в определенных версиях
OpenSSH. Вы можете устранить первые из этих проблем с помощью таких программ,
как Fail2Ban, однако вы должны помнить, что надежда не является стратегией, а
подобные бандиты только отсрочивают неизбежное: бот получает достаточно догадок,
чтобы угадать ваш пароль.
Введение SSH-идентичностей
</p>
<p>К счастью, SSH включает функцию, позволяющую значительно повысить безопасность
и потенциально сделать ее более удобной для вас. Это маленькое волшебство
называется SSH-идентификатором или, чаще, SSH-ключами. Ключи работают следующим
образом: вместо аутентификации на сервере с помощью пароля вы генерируете пару
открытых/закрытых ключей, как в PGP/GPG. Вы сохраняете свой закрытый ключ в
безопасности при загрузке открытого ключа на свой сервер. Преимущество? Вы
увеличиваете энтропию с менее чем 50 бит до длины вашего ключа: обычно 4096 бит
или более. Это примерно на два порядка.
Preparing the Client
</p>
<p>Использовать ключи SSH очень и очень просто. Вот как это делается:
вы генерируете новый ключ на клиентском компьютере с помощью такой команды:
</p><div class="example">
<pre class="example">$ ssh-keygen -b 4096 -t rsa -f ~/.ssh/id_rsa
</pre></div>
<p>Это создаст два файла: ваш закрытый ключ ~/.ssh/id_rsa и ваш открытый
ключ ~/.ssh/id_rsa.pub. Команда попросит вас ввести пароль для защиты
вашего закрытого ключа - вам решать, удобно ли вам, чтобы этот файл не
попал в чужие руки, поэтому выбирайте осторожно, если вы установили пароль
или нет. Мы использовали следующие варианты:
</p><div class="example">
<pre class="example">-b 4096
</pre></div>
<p>Это инструктирует ssh-keygen генерировать 4096-битный ключ. Не стесняйтесь
    увеличивать это до желаемой длины ключа - не забывайте использовать степени двух.
</p><div class="example">
<pre class="example">-t rsa
</pre></div>
<p>Заставляет ssh-keygen генерировать ключи RSA. Согласно справочной странице,
    допустимыми алгоритмами являются rsa, dsa, ecdsa и ed25519. ed25519 - это новый
    алгоритм, основанный на эллиптических кривых, который был представлен в OpenSSH 6.5,
    тогда как ecdsa - это старая реализация DSA на эллиптических кривых, которая, как
    известно, имеет серьезные уязвимости. Криптография с эллиптической кривой
    основывается на невозможности найти дискретный логарифм для элемента случайной
    эллиптической кривой и считается математически сложнее, чем первичная факторизация,
    на которую опирается RSA, поэтому в теории она должна быть более надежной даже
    при значительно более низких значениях силы ключа. Однако единственная реализация
    этого, доступная в SSH - до недавнего времени - была ошибочной, как и DSA, и
    ed25519 может быть недоступен на многих машинах, на которых вы можете захотеть
    использовать ключ. Наконец, dsa - стандартный вариант DSA без эллиптической кривой -
    имеет много известных векторов атаки, поэтому вам следует избегать этого.
</p><div class="example">
<pre class="example">-f ~/.ssh/id_rsa
</pre></div>
<p>Опция -f устанавливает имя выходного файла для вашего нового закрытого ключа.
    .ssh/id_rsa в вашем домашнем каталоге используется по умолчанию для
    идентификаторов SSH RSA, поэтому он будет использоваться автоматически. Вы
    можете использовать любое выбранное вами место, однако вы должны убедиться,
    что ваш файл закрытого ключа доступен для чтения только вашей учетной записи,
    иначе OpenSSH откажется от его использования. Кроме того, открытый ключ находится
    рядом с этим файлом с расширением .pub.
</p>
<p>После того, как ваш ключ будет сгенерирован, вам будет представлено небольшое
    изображение ASCII randomart. Не стесняйтесь запоминать это изображение, так как
    вы можете использовать его позже для визуальной идентификации подозрительного ключа.
    Чтобы получить это изображение позже, используйте эту команду:
</p><div class="display">
<pre class="display">$ ssh-keygen -lv -f .ssh/id_rsa.pub 
2048 fa:86:25:1d:9c:c9:89:58:b2:dd:a5:5c:17:5b:f1:5f  user@some-host.example.com (RSA)
+&ndash;[ RSA 2048]&mdash;-+
|            ..o. |
|    . .   o .o . |
|     * * B ..   E|
|    o o &nbsp;      o|
|       .S.      .|
|      ..o        |
|      .+         |
|      ...        |
|       ..        |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
</pre></div>
<p>Сгенерированный randomart довольно отчетливый - этот, в частности, выглядит как пальма
с кокосовым орехом, падающим с правой стороны, не так ли? Вы, вероятно, сможете выбрать
свой, увидев его несколько раз. Однако вы редко будете определять такие открытые ключи.
Эта опция скорее предназначена для идентификации ключей хоста благодаря настройке
VisualHostKey в конфигурационном файле SSH. Вам следует включить этот параметр в вашем
~/.ssh/config file - или в общесистемном /etc/ssh/ssh_config, если у вас есть доступ
для записи в него - добавив следующую строку в начале:
</p><div class="example">
<pre class="example">VisualHostKey yes
</pre></div>
<p>Это будет отображать изображение randomart удаленной системы каждый раз, когда вы
входите в систему - и если вы используете пароль, он сделает это до того, как вы
введете его, что позволит вам визуально сравнить ключ удаленного хоста с тем, как
он обычно выглядит Посмотрите, если что-то не так, прежде чем раздавать секретные
пароли. Это работает с помощью ключей хоста SSH, в значительной степени просто являясь
парой закрытого/открытого ключа, подобной той, которую вы только что сгенерировали,
уникальной для каждой машины.
</p>
<hr>
<a name="g_t_041f_043e_0434_0433_043e_0442_043e_0432_043a_0430-_0441_0435_0440_0432_0435_0440_0430"></a>
<div class="header">
<p>
Next: <a href="#g_t_041e_0442_043a_043b_044e_0447_0435_043d_0438_0435-_0430_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438-_043d_0430-_043e_0441_043d_043e_0432_0435-_043f_0430_0440_043e_043b_044f" accesskey="n" rel="next">Отключение аутентификации на основе пароля</a>, Previous: <a href="#g_t_041f_043e_0447_0435_043c_0443-_043f_0430_0440_043e_043b_0438-_043f_043b_043e_0445_043e-_0434_043b_044f-_0432_0430_0441" accesskey="p" rel="prev">Почему пароли плохо для вас</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Podgotovka-servera"></a>
<h3 class="section">17.2 Подготовка сервера</h3>


<p>Теперь, когда у вас есть файл идентификации, вам нужно будет войти на сервер и
добавить содержимое файла ~/.ssh/id_rsa.pub в список ~/.ssh/authorized_keys вашего
сервера. Если на удаленном хосте нет каталога ~/.ssh, создайте его. Ваш открытый
ключ будет просто одной строкой, хотя и длинной, и этот список авторизованных ключей
займет столько открытых ключей, сколько вы захотите. Кстати, вы должны создать новую
пару секретных/открытых ключей на каждом хосте - не так уж много людей, кажется, на
самом деле делают это, заметьте, но если бы вы сделали это, вы могли бы очень легко
отозвать доступ с определенного, скомпрометированные машины, удалив соответствующую
запись в списке авторизованных ключей. Также обратите внимание, что список ключей
зависит от пользователя. Это означает, что любой пользователь, для которого ваш
открытый ключ находится в файле ~/.ssh/authorized_keys пользователя, является
пользователем, с которым вы можете войти в систему, что также означает, что вы можете
легко предоставить кому-то еще доступ к своей учетной записи из другой машины, не
выдавая никаких паролей и не будучи root.
</p>
<p>После добавления ключа вы можете просто войти в систему с помощью инструмента
командной строки ssh, как обычно. Если для вашего ключа требуется пароль, вам будет
предложено ввести его - в противном случае для входа в систему достаточно иметь файл
закрытого ключа. Чтобы убедиться, что ключ действительно использовался, и чтобы
проверить, какой ключ использовался, вы можете использовать -v флаг в OpenSSH, вот так:
</p><div class="example">
<pre class="example">$ ssh -v magnus@stinger.becquerel.org
[...]
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Trying private key: /Users/magnusdeininger/.ssh/id_rsa
debug1: read PEM private key done: type RSA
debug1: Authentication succeeded (publickey).
Authenticated to stinger.becquerel.org ([46.226.106.4]:22).
[...]
magnus@stinger:~$ 
</pre></div>
<p>В этом примере я вошел на свой веб-сервер. Я сократил несколько строк вывода,
так как они не актуальны. Выделенные сообщения debug1 указывают, какой файл
закрытого ключа OpenSSH пытался использовать и, что более важно, он пытался -
и успешно - войти в систему, используя метод аутентификации publickey. Сканируйте
выходные данные отладки на наличие подобных строк, чтобы убедиться, что они работают,
прежде чем переходить к следующему разделу.
</p>
<hr>
<a name="g_t_041e_0442_043a_043b_044e_0447_0435_043d_0438_0435-_0430_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438-_043d_0430-_043e_0441_043d_043e_0432_0435-_043f_0430_0440_043e_043b_044f"></a>
<div class="header">
<p>
Next: <a href="#g_t_0421_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-SSH" accesskey="n" rel="next">Сертификаты SSH</a>, Previous: <a href="#g_t_041f_043e_0434_0433_043e_0442_043e_0432_043a_0430-_0441_0435_0440_0432_0435_0440_0430" accesskey="p" rel="prev">Подготовка сервера</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Otkliuchenie-autentifikacii-na-osnove-parolya"></a>
<h3 class="section">17.3 Отключение аутентификации на основе пароля</h3>

<p>Теперь, когда вы можете войти в систему с использованием идентификатора SSH, а не
обычного пароля, вам следует полностью отключить аутентификацию на основе пароля.
Делайте это только после того, как вы убедились, что можете войти в систему с учетной
записью, которая может перейти в root, или что у вас есть альтернативный способ вернуться
на свою машину. Чтобы заблокировать ваш сервер, отредактируйте ваш /etc/sshd/sshd_config
и установите следующие параметры:
</p><div class="example">
<pre class="example">Protocol 2
PermitRootLogin without-password
PubkeyAuthentication yes
ChallengeResponseAuthentication no
PasswordAuthentication no
UsePAM yes
</pre></div>
<p>Это устанавливает довольно строгий набор значений по умолчанию, которые должны
заставить большинство ботов сдаваться сразу после подключения. Варианты, которые
мы использовали:
</p><dl compact="compact">
<dt>Protocol</dt>
<dd><p>Убедитесь, что разрешена только версия протокола 2. Нет смысла поддерживать
    довольно устаревшую версию 1, и вы открываете себя только для старых ошибок.
    Если здесь установлено 1 или 1,2, измените его на 2.
</p></dd>
<dt>PermitRootLogin</dt>
<dd><p>Настройка без пароля немного ошибочна. То, что он делает, это разрешает вход в
    систему root, но только если механизм аутентификации не был паролем - то есть
    он включает входы root, но только для аутентификации с открытым ключом. Это
    хорошо. Никогда не устанавливайте это на no.
</p></dd>
<dt>PubkeyAuthentication</dt>
<dd><p>Убедитесь, что установлено значение «Да», иначе вы не сможете войти в систему
    после отключения паролей.
</p></dd>
<dt>ChallengeResponseAuthentication</dt>
<dd><p>Установите для этого параметра no, чтобы отключить не входящие в систему учетные
    записи, которые в противном случае могли бы обрабатываться через PAM.
</p></dd>
<dt>PasswordAuthentication</dt>
<dd><p>Это то, для чего мы были здесь: установите это в no, чтобы отключить туннельные
    пароли в виде открытого текста.
</p></dd>
<dt>UsePAM</dt>
<dd><p>Если в вашей системе настроен PAM, все равно будет полезно оставить этот параметр
    включенным, даже если вы отключили аутентификацию на основе пароля. Это связано с
    тем, что PAM также обеспечивает управление сеансами и учетными записями, поэтому
    установите для него значение yes.
</p></dd>
</dl>
<p>Все, что вам нужно сделать сейчас, это перезапустить сервер SSH, вот так:
</p><div class="example">
<pre class="example"># /etc/init.d/ssh restart
</pre></div>
<p>Обратите внимание, что перезапуск SSH не уничтожит ваш активный сеанс, поэтому вы
должны убедиться, что новые настройки действительно позволят вам войти в систему,
прежде чем закрывать текущий сеанс, - и снова вернуться и перезапустить SSH, если
этого не произойдет.
</p>
<p>Для достижения максимального эффекта убедитесь, что SSH является единственным способом
входа на ваш сервер. По крайней мере, убедитесь, что у вас не включен telnet! Теперь вы
готовы и можете быть уверены, что боты не смогут получить доступ к вашим машинам
через SSH. Но подождите, это еще не все!
</p>
<hr>
<a name="g_t_0421_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-SSH"></a>
<div class="header">
<p>
Next: <a href="#g_t_0421_043e_0437_0434_0430_043d_0438_0435-_043a_043e_0440_043d_0435_0432_043e_0433_043e-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_0430" accesskey="n" rel="next">Создание корневого сертификата</a>, Previous: <a href="#g_t_041e_0442_043a_043b_044e_0447_0435_043d_0438_0435-_0430_0443_0442_0435_043d_0442_0438_0444_0438_043a_0430_0446_0438_0438-_043d_0430-_043e_0441_043d_043e_0432_0435-_043f_0430_0440_043e_043b_044f" accesskey="p" rel="prev">Отключение аутентификации на основе пароля</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Sertifikaty-SSH"></a>
<h3 class="section">17.4 Сертификаты SSH</h3>

<p>Сертификаты SSH - это новейшее и лучшее усовершенствование аутентификации с
использованием открытого и закрытого ключей, которое может предложить SSH. Они
работают, внедряя новый центр сертификации, который подписывает ваш хост или
пользовательские ключи, что добавляет несколько существенных улучшений концепции,
таких как:
</p><dl compact="compact">
<dt>CA</dt>
<dd><p>Вероятно, у вас есть более одного сервера и более одной учетной записи пользователя -
    например, root и ваша любимая учетная запись без полномочий root для нормальной
    повседневной работы. Если вы генерируете новый ключ или пытаетесь предоставить
    новому пользователю доступ к вашим машинам, вам придется добавить этот ключ ко
    многим файлам authorized_keys, что является медленным и подверженным ошибкам
    раздражающим процессом. Используя сертификаты SSH, вы можете сократить это,
    просто один раз подписав разрешенные ключи, и тогда все готово.
</p></dd>
<dt>Срок действия ключа</dt>
<dd><p>Когда-нибудь создавали ключ PGP/GPG и впоследствии теряли закрытый ключ, пока
    люди все еще отправляли вам сообщения, используя ваш старый открытый ключ? Да,
    вот почему вы должны установить срок годности для ваших ключей. К сожалению,
    вы не можете сделать это с обычными парами открытого/закрытого ключей в SSH -
    но вы можете сделать это с подписанными ключами.
</p></dd>
<dt>Ключи подписанного хоста</dt>
<dd><p>Обратите внимание, как всякий раз, когда вы настраиваете новый компьютер и
    подключаетесь к нему в первый раз, SSH просит вас принять или отклонить его
    ключ хоста? Если вы были достаточно параноиком, на самом деле вы должны были
    распространять ключ хоста через какую-то физическую среду и очень-очень боялись
    принимать новые ключи хоста. Поскольку это нецелесообразно, сертификаты SSH также
    позволяют подписывать ключи хоста, поэтому вам нужно только доверять центру
    сертификации для домена, и тогда вы не увидите никаких предупреждений о неизвестных
    ключах хоста при подключении к новым машинам в этой сети. ,
</p></dd>
</dl>
<p>Сертификаты SSH являются относительно новой функцией. Как таковые они используются недостаточно. Теперь, когда вы знаете, почему они хороши, давайте настроим их, начиная с корневого сертификата.
</p>
<hr>
<a name="g_t_0421_043e_0437_0434_0430_043d_0438_0435-_043a_043e_0440_043d_0435_0432_043e_0433_043e-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_0430"></a>
<div class="header">
<p>
Next: <a href="#g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430" accesskey="n" rel="next">Подписание ключей хоста</a>, Previous: <a href="#g_t_0421_0435_0440_0442_0438_0444_0438_043a_0430_0442_044b-SSH" accesskey="p" rel="prev">Сертификаты SSH</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Sozdanie-kornevogo-sertifikata"></a>
<h3 class="section">17.5 Создание корневого сертификата</h3>


<p>Чтобы подписать что-либо, вам нужен центр сертификации. SSH не использует более
распространенные сертификаты X.509, используемые в SSL, поскольку они в основном
являются просто расширением концепции идентификации, уже существующей в SSH. Таким
образом, вам не нужно возиться с непонятными командами OpenSSL; как с личностями,
ssh-keygen твой друг! Чтобы создать новый корневой сертификат, сначала создайте
новую пару ключей:
</p><div class="example">
<pre class="example">$ ssh-keygen -b 4096 -t rsa -f example-com-ca -C &quot;CA key for example.com&quot;
</pre></div>
<p>Параметры, которые мы использовали, практически одинаковы, за исключением того, что
на этот раз мы не поместили сертификаты в вашу папку ~/.ssh/. Зачем? Потому что эти
ключи не предназначены для использования в качестве идентификаторов. Есть одна новая
опция, которую мы не использовали в прошлый раз:
</p><div class="example">
<pre class="example">-C &quot;CA key for example.com&quot;
</pre></div>
<p>Опция -C устанавливает комментарий в вашем файле ключей. По умолчанию используется
    user@host, но, поскольку теперь вы будете иметь дело с большим количеством ключей,
    может быть лучше дать ключи с описательными именами.
</p>
<p>О, и, пожалуйста, обратите внимание, что большинство других руководств скажут вам сделать
эти шаги как root. Нет необходимости генерировать ключи от имени пользователя root -
подойдет любой обычный пользователь. Так что, вероятно, лучше всего использовать обычную
учетную запись пользователя. Кроме того, не имеет значения, где вы генерируете пару
ключей - делайте это на своей рабочей станции, если можете, а не на своем сервере.
Просто не забудьте сохранить ключи подписи в безопасности - этот, вероятно, один из тех,
с которыми вам следует использовать пароль, потому что этот ключ действительно мощный,
и вам не нужно использовать его очень часто.
</p>
<hr>
<a name="g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430"></a>
<div class="header">
<p>
Next: <a href="#g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430" accesskey="n" rel="next">Использование сертификатов ключей хоста</a>, Previous: <a href="#g_t_0421_043e_0437_0434_0430_043d_0438_0435-_043a_043e_0440_043d_0435_0432_043e_0433_043e-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_0430" accesskey="p" rel="prev">Создание корневого сертификата</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Podpisanie-kliuchei-khosta"></a>
<h3 class="section">17.6 Подписание ключей хоста</h3>
<p>Подписание ключей хоста
</p>
<p>Самое простое использование вашего нового ключа подписи - это подпись ключей хоста.
В SSH нет реального различия между ключами пользователя и хоста, и, как обычно, мы
будем использовать для этого ssh-keygen. Команда выглядит следующим образом:
</p><div class="example">
<pre class="example">$ ssh-keygen -s example-com-ca -h -n host.example.com -V +52w -I host.example.com-key host-key.pub
</pre></div>
<p>Эта команда содержит довольно много новых флагов, поэтому давайте посмотрим на них:
</p><dl compact="compact">
<dt>-s example-com-ca</dt>
<dd><p>Говорит ssh-keygen подписать открытый ключ закрытым ключом example-com-ca.
    Замените example-com-ca тем ключом подписи, который вы хотите использовать.
</p></dd>
<dt>-h</dt>
<dd><p>Подпишите ключ хоста. Без этого флага вы бы подписывали сертификат пользователя.
    Мы вернемся к этому позже.
</p></dd>
<dt>-n host.example.com</dt>
<dd><p>Устанавливает имя хоста для этого нового подписанного ключа равным
    host.example.com. Замените на имя хоста любого компьютера, для которого
    предназначен ключ хоста. Вы можете указать несколько имен хостов, разделяя
    их запятыми, например, -n host.example.com,ssh.example.com.
</p></dd>
<dt>-V +52w</dt>
<dd><p>Как долго сертификат будет действителен. +52w означает, что срок действия
    сертификата истекает через 52 недели, то есть через год. Вы также можете
    указать диапазон, например, +2w,+52w для ключа, который вступит в силу через
    две недели и истекает через год. Применяется стандартный формат даты SSH,
    поэтому вы можете использовать дополнительные суффиксы, отличные от w, а
    также указывать явные даты. См. Раздел «Форматы времени» на справочной
    странице sshd_config для получения дополнительной информации об этом.
</p></dd>
<dt>-I host.example.com-key</dt>
<dd><p>Установите идентификатор для подписанного ключа, который используется при
    ведении журнала (и отзыв сертификата, описано ниже).
</p></dd>
</dl>
<p>Последний аргумент, host-key.pub, является открытым ключом для подписи. Вы
всегда подписываете открытые ключи, а не закрытые ключи! Сертификат будет помещен
в новый файл host-key-cert.pub. Например, если вы подпишете ключ хоста RSA компьютера,
на котором вы сейчас находитесь, вы можете сделать это следующим образом:
</p><div class="example">
<pre class="example"># ssh-keygen -s example-com-ca -h -n host.example.com -V +52w \
-I host.example.com-key /etc/ssh/ssh_host_rsa_key.pub
</pre></div>
<p>Обратите внимание, что вам нужно сделать это как root, так как команда попытается
записать новый файл /etc/ssh/ssh_host_rsa_key-cert.pub, и этот каталог, вероятно,
будет доступен для записи только root.
</p>
<hr>
<a name="g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430"></a>
<div class="header">
<p>
Next: <a href="#g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044f" accesskey="n" rel="next">Подписание ключей пользователя</a>, Previous: <a href="#g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430" accesskey="p" rel="prev">Подписание ключей хоста</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Ispolxzovanie-sertifikatov-kliuchei-khosta"></a>
<h3 class="section">17.7 Использование сертификатов ключей хоста</h3>
<p>Использование сертификатов ключей хоста
</p>
<p>Независимо от того, где вы подписали ключ, скопируйте сертификат в соответствующее
место на вашем хосте SSH; то есть скопируйте его в /etc/ssh/ssh_host_rsa_key-cert.pub,
если это ключ RSA, и замените часть rsa правильным алгоритмом, если вы подписали ключ
другим типом. Затем вы должны указать демону OpenSSH на вашем SSH-сервере использовать
новый сертификат, отредактировав /etc/ssh/sshd_config:
</p><div class="example">
<pre class="example">HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
</pre></div>
<p>Обратите внимание, что вам не нужно ничего рассказывать демону OpenSSH об CA - это не
нужно, поскольку клиентская сторона проверяет ключ хоста сервера, поэтому серверу
просто необходимо знать, где находится его подпись.
</p>
<p>Это все, что нужно сделать на стороне сервера. На стороне клиента вам нужно добавить
открытый ключ подписи в файл ~/.ssh/known_hosts вашего пользователя. Добавьте новую
строку, как показано ниже:
</p><div class="example">
<pre class="example">@cert-authority *.example.com contents-of-public-key-file
</pre></div>
<p>Все это должно быть в одной строке, как всегда в файле known_hosts. Отдельные
части линии следующие:
</p><dl compact="compact">
<dt>@cert-authority</dt>
<dd><p>Сообщает SSH, что следующий ключ не является ключом для одного хоста, а является
    ожидаемым ключом подписи для набора хостов.
</p></dd>
<dt>*.example.com</dt>
<dd><p>Разделенный запятыми набор шаблонов имен хостов, для которых этот ключ подписи
    является действительным. Это обычный формат шаблона, используемый SSH, где
    звездочки обозначают произвольные строки символов. IP-адреса также действительны.
</p></dd>
<dt>contents-of-public-key-file</dt>
<dd><p>Это буквально открытый ключ в вашей паре ключей подписи.
</p></dd>
</dl>
<p>Помните, что все это должно быть в одной строке. Например, в нижней части нашей
страницы открытых ключей перечислены строки, которые нужно добавить для сети
becquerel.org, где размещен этот сайт. Если бы вы добавили именно эту строку и
протестировали ее ...
</p><div class="display">
<pre class="display">$ ssh stinger.becquerel.org
Host key fingerprint is 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
+&ndash;[RSA-CERT 819&ndash;+
|                 |
|         . . .   |
|        + o E    |
|         * o     |
|      o S *      |
|   . = o + .     |
|  . * * + .      |
|   o *   +       |
|         .o      |
+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+

Permission denied (publickey).
</pre></div>
<p>Конечно, вы бы не увидели последнюю строку, если бы у вас был мой закрытый ключ.
Обратите внимание, что ssh не просит вас добавить новый ключ хоста - это потому,
что он проверен на соответствие подписи открытого ключа. Чтобы убедиться, что это
действительно так, флаг -v - это ваш код:
</p><div class="display">
<pre class="display">$ ssh -v stinger.becquerel.org
[...]
debug1: ssh_rsa_verify: signature correct
debug1: Server host key: RSA-CERT 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
debug1: Host &rsquo;stinger.becquerel.org&rsquo; is known and matches the RSA-CERT host certificate.
debug1: Found CA key in /Users/mdeininger/.ssh/known_hosts:11
[...]
</pre></div>
<p>Обратите внимание, что он говорит, что подпись верна и что он нашел ключ [the] CA в
[the known_hosts file]. Вот как вы проверяете, что он использовал сертификаты; если бы
он не знал о подписи открытого ключа, он вместо этого показал бы:
</p><div class="display">
<pre class="display">$ ssh -v stinger.becquerel.org
[...]
debug1: ssh_rsa_verify: signature correct
debug1: Server host key: RSA-CERT 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
debug1: No matching CA found. Retry with plain key
[...]
</pre></div>
<p>Вывод, подобный этому, означает, что вы не добавили правильный ключ CA в ваш
~/.ssh/known_hosts или что шаблон хоста был неверным.
</p>
<hr>
<a name="g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044f"></a>
<div class="header">
<p>
Next: <a href="#g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0445-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432" accesskey="n" rel="next">Использование пользовательских сертификатов</a>, Previous: <a href="#g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432-_043a_043b_044e_0447_0435_0439-_0445_043e_0441_0442_0430" accesskey="p" rel="prev">Использование сертификатов ключей хоста</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Podpisanie-kliuchei-polxzovatelya"></a>
<h3 class="section">17.8 Подписание ключей пользователя</h3>


<p>Этот последний шаг концептуально очень похож на сертификаты хоста: пользовательские
сертификаты. Мы снова используем ssh-keygen, вот так:
</p><div class="example">
<pre class="example">$ ssh-keygen -s example-com-ca -n user -V +52w -I example.com-user id_rsa.pub
</pre></div>
<p>Обратите внимание, что эта команда очень похожа на ту, которую мы использовали для
подписи ключей хоста. Единственное отличие состоит в том, что флаг -n теперь указывает
пользователей, а не имена хостов, и на этот раз вам нужно передать его открытым ключом
вашей идентификационной информации пользователя. Как и в прошлый раз, он создаст файл
с именем id_rsa-cert.pub. Если бы вы подписали свой собственный ключ пользователя,
команда была бы такой:
</p><div class="example">
<pre class="example">$ ssh-keygen -s example-com-ca -n user -V +52w -I example.com-user ~/.ssh/id_rsa.pub
</pre></div>
<p>И это все, что нужно для подписи ключей пользователя. Если бы ваш сервер был настроен
так, чтобы вы могли входить в систему с ключами, подписанными этим сертификатом, у вас
все было бы в порядке, если бы вам не пришлось вручную заполнять любые файлы
author_keys. Вот что вы будете делать дальше.
</p>
<hr>
<a name="g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0445-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432"></a>
<div class="header">
<p>
Next: <a href="#g_t_041e_0442_0434_0435_043b_044c_043d_044b_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0438-_0445_043e_0441_0442-_0421_0410" accesskey="n" rel="next">Отдельные пользовательские и хост СА</a>, Previous: <a href="#g_t_041f_043e_0434_043f_0438_0441_0430_043d_0438_0435-_043a_043b_044e_0447_0435_0439-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044f" accesskey="p" rel="prev">Подписание ключей пользователя</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Ispolxzovanie-polxzovatelxskikh-sertifikatov"></a>
<h3 class="section">17.9 Использование пользовательских сертификатов</h3>


<p>На стороне клиента все, что вам нужно сделать, это убедиться, что id_rsa-cert.pub
находится рядом с вашим файлом id_rsa.pub, поэтому мы закончили с этой частью.
Однако нам все же нужно сообщить серверу, чтобы он принимал ключи, подписанные вашим
CA. Для этого вам нужно скопировать ваш example-com-ca.pub на ваш сервер -
/etc/ssh будет хорошим местом, поэтому я предполагаю, что вы скопировали его туда.
Затем вам нужно снова отредактировать файл /etc/ssh/sshd_config и добавить опцию,
подобную этой:
</p><div class="example">
<pre class="example">TrustedUserCAKeys /etc/ssh/example-com-ca.pub
</pre></div>
<p>Вы можете поместить несколько открытых ключей в файл, на который ссылается
TrustedUserCAKeys - по одному на CA, которому разрешено подписывать доверенные
пользовательские ключи. Как обычно, перезапустите сервер SSH, чтобы эта опция вступила
в силу. И это все, что вам нужно было сделать, теперь вы можете войти в систему,
используя подписанный ключ, без необходимости обновлять файл authorized_keys для каждого
пользователя, для которого вы хотите войти в систему. Конечно, вы можете сделать это, в
дополнение к использованию CA.
</p>
<hr>
<a name="g_t_041e_0442_0434_0435_043b_044c_043d_044b_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0438-_0445_043e_0441_0442-_0421_0410"></a>
<div class="header">
<p>
Next: <a href="#g_t_041e_0442_0437_044b_0432-_043a_043b_044e_0447_0435_0439-_0438-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432" accesskey="n" rel="next">Отзыв ключей и сертификатов</a>, Previous: <a href="#g_t_0418_0441_043f_043e_043b_044c_0437_043e_0432_0430_043d_0438_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0445-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432" accesskey="p" rel="prev">Использование пользовательских сертификатов</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Otdelxnye-polxzovatelxskie-i-khost-SA"></a>
<h3 class="section">17.10 Отдельные пользовательские и хост СА</h3>


<p>Часто рекомендуется использовать отдельные центры сертификации пользователей и хостов.
Это не является строго необходимым, но это может повысить безопасность, если один из
секретных ключей будет скомпрометирован или если пользователи и хосты будут управляться
различными отделами. Не стесняйтесь просто сгенерировать второй CA для своих
пользователей, как вы это делали до создания ключей хоста, и при необходимости
заменить ключ подписи.
</p>
<hr>
<a name="g_t_041e_0442_0437_044b_0432-_043a_043b_044e_0447_0435_0439-_0438-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432"></a>
<div class="header">
<p>
Next: <a href="#g_t_0414_0430_043b_044c_043d_0435_0439_0448_0438_0435-_0443_043b_0443_0447_0448_0435_043d_0438_044f-_0431_0435_0437_043e_043f_0430_0441_043d_043e_0441_0442_0438" accesskey="n" rel="next">Дальнейшие улучшения безопасности</a>, Previous: <a href="#g_t_041e_0442_0434_0435_043b_044c_043d_044b_0435-_043f_043e_043b_044c_0437_043e_0432_0430_0442_0435_043b_044c_0441_043a_0438_0435-_0438-_0445_043e_0441_0442-_0421_0410" accesskey="p" rel="prev">Отдельные пользовательские и хост СА</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Otzyv-kliuchei-i-sertifikatov"></a>
<h3 class="section">17.11 Отзыв ключей и сертификатов</h3>


<p>Последнее, что нужно знать об использовании удостоверений и сертификатов, это то, что
вы можете отозвать их. Для этого вам снова нужно отредактировать ваш /etc/ssh/sshd_config
и добавить следующую опцию:
</p><div class="example">
<pre class="example">RevokedKeys /etc/ssh/revoked-keys
</pre></div>
<p>Убедитесь, что файл, указанный здесь, существует и доступен для чтения, иначе в
аутентификации с открытым ключом будет вообще отказано! В зависимости от того,
использовали ли вы прямые идентификаторы или сертификаты, вы можете либо заполнить этот
файл списком отозванных открытых ключей, либо использовать ssh-keygen, чтобы заполнить
этот файл списком отзыва ключей OpenSSH или, для краткости, KRL. Любым ключам, указанным
в этом файле, будет отказано в доступе при попытке аутентификации. Это как инвертированый
файл author_keys. Это не особенно полезно для принудительного оборота ключей, но полезно,
если у вас есть, который который был украден - или для блокировки ключей, которые,
как известно, страдают от старой ошибки RNG и по своей природе небезопасны.
</p>
<p>Если вы хотите использовать KRL вместо прямого списка отозванных открытых ключей,
швейцарский армейский нож OpenSSH ssh-keygen, как обычно, ваш друг. Чтобы создать или
обновить KRL, используйте следующую команду:
</p><div class="example">
<pre class="example">$ ssh-keygen -k -f revoked-keys -u -s example-com-ca public-key-or-file(s)
</pre></div>
<p>Это использование имеет несколько новых опций, поэтому давайте посмотрим на них:
</p><dl compact="compact">
<dt>-k</dt>
<dd><p>Этот флаг переводит ssh-keygen в режим KRL, сообщая ему о создании или
    обновлении Key Revocation List (Список Отзыва Ключей). Новый KRL помещается в
    файл, указанный флагом -f, поэтому в этом примере он будет помещен в файл
    revoked-keys.
</p></dd>
<dt>-u</dt>
<dd><p>Если вы укажете этот флаг, выходной KRL будет дописан вместо того, чтобы
    создать новый только с содержимым указанных файлов. Вы должны использовать
    это, если у вас уже есть KRL и вы просто хотите быстро отозвать другой открытый
    ключ. Обратите внимание, что если вы укажете этот флаг и выходной файл не
    существует, то ssh-keygen завершится с ошибкой, поэтому при первом запуске вы
    должны сбросить этот флаг.
</p>
</dd>
<dt>-s</dt>
<dd><p>Этот флаг является необязательным, и вам нужно использовать его, только если вы
    хотите отозвать сертификат по серийному номеру или идентификатору. Если вы хотите
    отозвать только открытые ключи, то вам не нужно указывать CA.
    public-key-or-file(s) - это список файлов, которые содержат открытые ключи
    (один ключ на строку) или спецификации отзыва. Итак, если вы хотите создать KRL
    со своим собственным открытым ключом, вы должны вызвать следующую команду:
</p></dd>
</dl>
<div class="example">
<pre class="example">$ ssh-keygen -k -f revoked-keys ~/.ssh/id_rsa.pub
</pre></div>
<p>... и теперь у вас есть новый файл revoked-keys в вашем текущем каталоге, который
содержит этот ключ. Если вы хотите отозвать сертификат OpenSSH с помощью ID, вы должны
создать новый файл ids-to-revoke со следующим содержимым:
</p><div class="example">
<pre class="example">id: example.com-user
</pre></div>
<p>И команда превратить это в KRL будет:
</p><div class="example">
<pre class="example">$ ssh-keygen -k -f revoked-keys -s example-com-ca ids-to-revoke
</pre></div>
<p>Такое использование позволяет вам использовать revoke-keys, фактически не имея
буквального сертификата или идентификационного файла под рукой. Вы можете указать
несколько строк в файле ids-to-revoke с несколькими id: commands. Вместо id:
вы также можете использовать serial:, key: или sha1: для указания серийного
номера ключа, простого открытого ключа или хэша SHA1 ключа.
</p>
<p>Не забудьте использовать флаг -u при обновлении KRL и фактически распространять KRL
на серверы. scp и rsync ваши друзья, как обычно.
</p>
<hr>
<a name="g_t_0414_0430_043b_044c_043d_0435_0439_0448_0438_0435-_0443_043b_0443_0447_0448_0435_043d_0438_044f-_0431_0435_0437_043e_043f_0430_0441_043d_043e_0441_0442_0438"></a>
<div class="header">
<p>
Next: <a href="#g_t_0423_043a_0440_0435_043f_0438_0442_044c-_043e_0441_0442_0430_0432_0448_0438_0435_0441_044f-_043a_043b_044e_0447_0438" accesskey="n" rel="next">Укрепить оставшиеся ключи</a>, Previous: <a href="#g_t_041e_0442_0437_044b_0432-_043a_043b_044e_0447_0435_0439-_0438-_0441_0435_0440_0442_0438_0444_0438_043a_0430_0442_043e_0432" accesskey="p" rel="prev">Отзыв ключей и сертификатов</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Dalxneishie-uluchsheniya-bezopasnosti"></a>
<h3 class="section">17.12 Дальнейшие улучшения безопасности</h3>


<p>Теперь, когда вы являетесь экспертом в области сертификатов, вы можете сделать еще
несколько вещей, чтобы повысить безопасность своих серверов. Начиная с их ключей хоста.
</p>
<p>Отключить неиспользуемые типы ключей хоста
</p>
<p>В файле /etc/ssh/sshd_config ваших серверов вы заметите несколько директив HostKey.
Вы должны отключить все ключи хоста с помощью алгоритмов, которые вы не используете
или которым вы не доверяете. Например, на моих серверах блок с ключами хоста
выглядит так:
</p><div class="display">
<pre class="display">HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_dsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
</pre></div>
<p>Как видите, ключи DSA и ECDSA закомментированы, то есть сервер SSH не будет их
использовать. Вы можете - и должны - также удалить эти другие закрытые ключи вместе
с их открытыми ключами из /etc/ssh, поскольку они не соответствуют задачи. Хотя
некоторые сценарии распространения могут перегенерировать их при перезапуске SSH.
</p>
<p>Помните: чем меньше функций вы включите, тем меньше функций можно будет использовать,
если окажется, что где-то скрывается ошибка.
</p>
<hr>
<a name="g_t_0423_043a_0440_0435_043f_0438_0442_044c-_043e_0441_0442_0430_0432_0448_0438_0435_0441_044f-_043a_043b_044e_0447_0438"></a>
<div class="header">
<p>
Next: <a href="#g_t_0427_0442_043e-_0435_0449_0435-_043f_043e_0447_0438_0442_0430_0442_044c" accesskey="n" rel="next">Что еще почитать</a>, Previous: <a href="#g_t_0414_0430_043b_044c_043d_0435_0439_0448_0438_0435-_0443_043b_0443_0447_0448_0435_043d_0438_044f-_0431_0435_0437_043e_043f_0430_0441_043d_043e_0441_0442_0438" accesskey="p" rel="prev">Дальнейшие улучшения безопасности</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Ukrepitx-ostavshiesya-kliuchi"></a>
<h3 class="section">17.13 Укрепить оставшиеся ключи</h3>


<p>Ключи хоста по умолчанию обычно составляют 1024 бита. Поэтому,
если вы параноик, вам следует создать новые ключи хоста, которые сильнее:
</p><div class="example">
<pre class="example"># ssh-keygen -b 8192 -t rsa /etc/ssh/ssh_host_rsa_key
</pre></div>
<p>Вам также следует сгенерировать ключи хоста, если вы подозреваете, что ключи хоста
были сгенерированы, когда действовала слабая ошибка RNG, или если вы подозреваете,
что закрытый ключ был взломан. Также не забудьте подписать открытый ключ заново и
загрузить сертификат при создании нового ключа, иначе все будет работать не так, как
задумано.
</p>
<p>Имейте в виду, что использование ключей со значением более 8192 битов с сертификатами
приведет к тому, что некоторые версии OpenSSH будут игнорировать ключи и давать сбой.
Некоторые старые версии могут быть ограничены до 4096 бит. Вы получите очень странные
сообщения об ошибках, в которых говорится, что ваш сертификат вообще не был
действительным. Так что пока лучше держаться за эти действительно сильные клавиши.
Также обратите внимание, что вам не следует назначать пароль этим ключам, так как вы
хотите, чтобы ваш сервер загружался автоматически с включенным и работающим SSH.
</p>
<p>Не храните копии сертификатов, которые вы подписали
</p>
<p>Некоторые руководства скажут вам сохранить копии сертификатов, которые вы подписали,
или даже сгенерировать пару открытых/закрытых ключей для вашего пользователя и передать
им закрытый ключ и сертификат по безопасному каналу и хранить файлы, чтобы вы могли
отозвать их позже.
</p>
<p>В этом нет необходимости, и на самом деле это проблема безопасности. Вам не нужно иметь
доступ к закрытым ключам ваших пользователей, и вам на самом деле не нужно этого делать,
так как это позволит вам имитировать их. Пусть ваши пользователи генерируют свои
собственные пары ключей и запрашивайте у них только открытый ключ - это единственное,
что вам нужно подписать. Также нет необходимости хранить копию сертификата; пока у вас
есть личный ключ CA и идентификатор назначенного вами ключа, вы можете отозвать ключ с
помощью KRL. Поскольку вам не нужна другая информация, лучше всего удалить файл открытого
ключа и сертификат после того, как вы их выпустили.
</p>
<hr>
<a name="g_t_0427_0442_043e-_0435_0449_0435-_043f_043e_0447_0438_0442_0430_0442_044c"></a>
<div class="header">
<p>
Previous: <a href="#g_t_0423_043a_0440_0435_043f_0438_0442_044c-_043e_0441_0442_0430_0432_0448_0438_0435_0441_044f-_043a_043b_044e_0447_0438" accesskey="p" rel="prev">Укрепить оставшиеся ключи</a>, Up: <a href="#g_t_0420_0443_043a_043e_0432_043e_0434_0441_0442_0432_043e-2" accesskey="u" rel="up">Руководство 2</a> &nbsp; </p>
</div>
<a name="Chto-eshche-pochitatx"></a>
<h3 class="section">17.14 Что еще почитать</h3>


<p>Поздравляем, теперь у вас настроен SSH-сервер на уровне так себе.
</p>
<p>Для получения дополнительной информации о том, что вы можете настроить в
OpenSSH, прочитайте следующие справочные страницы:
</p><div class="example">
<pre class="example">$ man 5 ssh_config
$ man 5 sshd_config
$ man 1 ssh-keygen
</pre></div>

<hr>



</body>
</html>
