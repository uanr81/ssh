
Chapter 12. OpenSSH
SSH (Secure Shell) is a protocol which facilitates secure communications between two systems using a client-server architecture and allows users to log in to server host systems remotely. Unlike other remote communication protocols, such as FTP or Telnet, SSH encrypts the login session, rendering the connection difficult for intruders to collect unencrypted passwords.
The ssh program is designed to replace older, less secure terminal applications used to log in to remote hosts, such as telnet or rsh. A related program called scp replaces older programs designed to copy files between hosts, such as rcp. Because these older applications do not encrypt passwords transmitted between the client and the server, avoid them whenever possible. Using secure methods to log in to remote systems decreases the risks for both the client system and the remote host.
Red Hat Enterprise Linux includes the general OpenSSH package, openssh, as well as the OpenSSH server, openssh-server, and client, openssh-clients, packages. Note, the OpenSSH packages require the OpenSSL package openssl-libs, which installs several important cryptographic libraries, enabling OpenSSH to provide encrypted communications.
12.1. The SSH Protocol
12.1.1. Why Use SSH?
Potential intruders have a variety of tools at their disposal enabling them to disrupt, intercept, and re-route network traffic in an effort to gain access to a system. In general terms, these threats can be categorized as follows:

Interception of communication between two systems
    The attacker can be somewhere on the network between the communicating parties, copying any information passed between them. He may intercept and keep the information, or alter the information and send it on to the intended recipient.
    This attack is usually performed using a packet sniffer, a rather common network utility that captures each packet flowing through the network, and analyzes its content. 
Impersonation of a particular host
    Attacker's system is configured to pose as the intended recipient of a transmission. If this strategy works, the user's system remains unaware that it is communicating with the wrong host.
    This attack can be performed using a technique known as DNS poisoning, or via so-called IP spoofing. In the first case, the intruder uses a cracked DNS server to point client systems to a maliciously duplicated host. In the second case, the intruder sends falsified network packets that appear to be from a trusted host. 

Both techniques intercept potentially sensitive information and, if the interception is made for hostile reasons, the results can be disastrous. If SSH is used for remote shell login and file copying, these security threats can be greatly diminished. This is because the SSH client and server use digital signatures to verify their identity. Additionally, all communication between the client and server systems is encrypted. Attempts to spoof the identity of either side of a communication does not work, since each packet is encrypted using a key known only by the local and remote systems.
12.1.2. Main Features
The SSH protocol provides the following safeguards:

No one can pose as the intended server
    After an initial connection, the client can verify that it is connecting to the same server it had connected to previously. 
No one can capture the authentication information
    The client transmits its authentication information to the server using strong, 128-bit encryption. 
No one can intercept the communication
    All data sent and received during a session is transferred using 128-bit encryption, making intercepted transmissions extremely difficult to decrypt and read. 

Additionally, it also offers the following options:

It provides secure means to use graphical applications over a network
    Using a technique called X11 forwarding, the client can forward X11 (X Window System) applications from the server. 
It provides a way to secure otherwise insecure protocols
    The SSH protocol encrypts everything it sends and receives. Using a technique called port forwarding, an SSH server can become a conduit to securing otherwise insecure protocols, like POP, and increasing overall system and data security. 
It can be used to create a secure channel
    The OpenSSH server and client can be configured to create a tunnel similar to a virtual private network for traffic between server and client machines. 
It supports the Kerberos authentication
    OpenSSH servers and clients can be configured to authenticate using the GSSAPI (Generic Security Services Application Program Interface) implementation of the Kerberos network authentication protocol. 

12.1.3. Protocol Versions
Two varieties of SSH currently exist: version 1, and newer version 2. The OpenSSH suite under Red Hat Enterprise Linux 7 uses SSH version 2, which has an enhanced key exchange algorithm not vulnerable to the known exploit in version 1. In Red Hat Enterprise Linux 7, the OpenSSH suite does not support version 1 connections.
12.1.4. Event Sequence of an SSH Connection
The following series of events help protect the integrity of SSH communication between two hosts.

    A cryptographic handshake is made so that the client can verify that it is communicating with the correct server.
    The transport layer of the connection between the client and remote host is encrypted using a symmetric cipher.
    The client authenticates itself to the server.
    The client interacts with the remote host over the encrypted connection. 

12.1.4.1. Transport Layer
The primary role of the transport layer is to facilitate safe and secure communication between the two hosts at the time of authentication and during subsequent communication. The transport layer accomplishes this by handling the encryption and decryption of data, and by providing integrity protection of data packets as they are sent and received. The transport layer also provides compression, speeding the transfer of information.
Once an SSH client contacts a server, key information is exchanged so that the two systems can correctly construct the transport layer. The following steps occur during this exchange:

    Keys are exchanged
    The public key encryption algorithm is determined
    The symmetric encryption algorithm is determined
    The message authentication algorithm is determined
    The hash algorithm is determined 

During the key exchange, the server identifies itself to the client with a unique host key. If the client has never communicated with this particular server before, the server's host key is unknown to the client and it does not connect. OpenSSH gets around this problem by accepting the server's host key. This is done after the user is notified and has both accepted and verified the new host key. In subsequent connections, the server's host key is checked against the saved version on the client, providing confidence that the client is indeed communicating with the intended server. If, in the future, the host key no longer matches, the user must remove the client's saved version before a connection can occur.

Warning
It is possible for an attacker to masquerade as an SSH server during the initial contact since the local system does not know the difference between the intended server and a false one set up by an attacker. To help prevent this, verify the integrity of a new SSH server by contacting the server administrator before connecting for the first time or in the event of a host key mismatch.
SSH is designed to work with almost any kind of public key algorithm or encoding format. After an initial key exchange creates a hash value used for exchanges and a shared secret value, the two systems immediately begin calculating new keys and algorithms to protect authentication and future data sent over the connection.
After a certain amount of data has been transmitted using a given key and algorithm (the exact amount depends on the SSH implementation), another key exchange occurs, generating another set of hash values and a new shared secret value. Even if an attacker is able to determine the hash and shared secret value, this information is only useful for a limited period of time.
12.1.4.2. Authentication
Once the transport layer has constructed a secure tunnel to pass information between the two systems, the server tells the client the different authentication methods supported, such as using a private key-encoded signature or typing a password. The client then tries to authenticate itself to the server using one of these supported methods.
SSH servers and clients can be configured to allow different types of authentication, which gives each side the optimal amount of control. The server can decide which encryption methods it supports based on its security model, and the client can choose the order of authentication methods to attempt from the available options.
12.1.4.3. Channels
After a successful authentication over the SSH transport layer, multiple channels are opened via a technique called multiplexing[1]. Each of these channels handles communication for different terminal sessions and for forwarded X11 sessions.
Both clients and servers can create a new channel. Each channel is then assigned a different number on each end of the connection. When the client attempts to open a new channel, the clients sends the channel number along with the request. This information is stored by the server and is used to direct communication to that channel. This is done so that different types of sessions do not affect one another and so that when a given session ends, its channel can be closed without disrupting the primary SSH connection.
Channels also support flow-control, which allows them to send and receive data in an orderly fashion. In this way, data is not sent over the channel until the client receives a message that the channel is open.
The client and server negotiate the characteristics of each channel automatically, depending on the type of service the client requests and the way the user is connected to the network. This allows great flexibility in handling different types of remote connections without having to change the basic infrastructure of the protocol.


 Глава 12. OpenSSH
SSH (Secure Shell) - это протокол, который обеспечивает безопасную связь между двумя системами, используя архитектуру клиент-сервер, и позволяет пользователям удаленно входить в хост-системы сервера. В отличие от других протоколов удаленной связи, таких как FTP или Telnet , SSH шифрует сеанс входа в систему, затрудняя злоумышленникам соединение для сбора незашифрованных паролей.
Программа ssh предназначена для замены старых, менее безопасных терминальных приложений, используемых для входа на удаленные хосты, таких как telnet или rsh . Родственная программа scp заменяет старые программы, предназначенные для копирования файлов между хостами, например, rcp . Поскольку эти старые приложения не шифруют пароли, передаваемые между клиентом и сервером, по возможности избегайте их. Использование безопасных методов для входа в удаленные системы снижает риски как для клиентской системы, так и для удаленного хоста.
Red Hat Enterprise Linux включает в себя общий пакет OpenSSH, openssh , а также сервер OpenSSH, openssh-сервер и клиентские, openssh-клиенты , пакеты. Обратите внимание, что для пакетов OpenSSH требуется пакет OpenSSL openssl-libs , который устанавливает несколько важных криптографических библиотек, позволяющих OpenSSH обеспечивать зашифрованные соединения.
12.1. Протокол SSH
12.1.1. Зачем использовать SSH?
Потенциальные злоумышленники имеют в своем распоряжении различные инструменты, позволяющие им прерывать, перехватывать и перенаправлять сетевой трафик, пытаясь получить доступ к системе. В общих чертах, эти угрозы могут быть классифицированы следующим образом:

Перехват связи между двумя системами
    Злоумышленник может находиться где-то в сети между взаимодействующими сторонами, копируя любую информацию, передаваемую между ними. Он может перехватывать и хранить информацию или изменять информацию и отправлять ее предполагаемому получателю.
    Эта атака обычно выполняется с использованием анализатора пакетов , довольно распространенной сетевой утилиты, которая захватывает каждый пакет, проходящий через сеть, и анализирует его содержимое. 
Олицетворение конкретного хоста
    Система злоумышленника настроена так, чтобы выдавать себя за предполагаемого получателя передачи. Если эта стратегия работает, система пользователя не знает, что она взаимодействует с неправильным хостом.
    Эта атака может быть выполнена с использованием метода, известного как DNS-отравление , или с помощью так называемого IP-спуфинга . В первом случае злоумышленник использует взломанный DNS-сервер для указания клиентских систем на злонамеренно дублированный хост. Во втором случае злоумышленник отправляет фальсифицированные сетевые пакеты, которые, по-видимому, поступают с доверенного хоста. 

Оба метода перехватывают потенциально конфиденциальную информацию, и, если перехват сделан по враждебным причинам, результаты могут быть катастрофическими. Если SSH используется для удаленного входа в систему и копирования файлов, эти угрозы безопасности могут быть значительно уменьшены. Это связано с тем, что клиент и сервер SSH используют цифровые подписи для проверки своей личности. Кроме того, вся связь между клиентской и серверной системами зашифрована. Попытки подделать идентификационные данные любой стороны сообщения не работают, поскольку каждый пакет шифруется с использованием ключа, известного только локальной и удаленной системам.
12.1.2. Основные характеристики
Протокол SSH обеспечивает следующие гарантии:

Никто не может выдавать себя за предполагаемый сервер
    После первоначального подключения клиент может проверить, что он подключается к тому же серверу, к которому он подключался ранее. 
Никто не может захватить информацию аутентификации
    Клиент передает свою аутентификационную информацию на сервер с использованием надежного 128-битного шифрования. 
Никто не может перехватить общение
    Все данные, отправленные и полученные во время сеанса, передаются с использованием 128-битного шифрования, что делает крайне затруднительным дешифрование и чтение перехваченных передач. 

Кроме того, он также предлагает следующие варианты:

Это обеспечивает безопасные средства для использования графических приложений по сети
    Используя технику, называемую пересылкой X11 , клиент может пересылать приложения X11 ( X Window System ) с сервера. 
Он обеспечивает способ защиты небезопасных протоколов
    Протокол SSH шифрует все, что отправляет и получает. Используя технику, называемую переадресацией портов , сервер SSH может стать каналом защиты небезопасных протоколов, таких как POP , и повышения общей безопасности системы и данных. 
Может использоваться для создания безопасного канала
    Сервер и клиент OpenSSH можно настроить для создания туннеля, аналогичного виртуальной частной сети, для трафика между сервером и клиентскими компьютерами. 
Поддерживает аутентификацию Kerberos
    Серверы и клиенты OpenSSH могут быть сконфигурированы для аутентификации с использованием реализации GSSAPI (интерфейса прикладных программ Generic Security Services) протокола сетевой аутентификации Kerberos. 

12.1.3. Версии протокола
В настоящее время существует две разновидности SSH: версия 1 и более новая версия 2. В пакете OpenSSH в Red Hat Enterprise Linux 7 используется версия 2 SSH, в которой реализован улучшенный алгоритм обмена ключами, который не уязвим к известной уязвимости в версии 1. В Red Hat Enterprise Linux 7, пакет OpenSSH не поддерживает соединения версии 1.
12.1.4. Последовательность событий соединения SSH
Следующая серия событий помогает защитить целостность связи SSH между двумя хостами.

    Криптографическое рукопожатие выполняется для того, чтобы клиент мог убедиться, что он обменивается данными с правильным сервером.
    Транспортный уровень соединения между клиентом и удаленным хостом шифруется с использованием симметричного шифра.
    Клиент аутентифицирует себя на сервере.
    Клиент взаимодействует с удаленным хостом через зашифрованное соединение. 

12.1.4.1. Транспортный уровень
Основная роль транспортного уровня заключается в обеспечении безопасной и надежной связи между двумя хостами во время аутентификации и во время последующей связи. Транспортный уровень выполняет это, обрабатывая шифрование и дешифрование данных и обеспечивая защиту целостности пакетов данных при их отправке и получении. Транспортный уровень также обеспечивает сжатие, ускоряя передачу информации.
Как только клиент SSH связывается с сервером, информация о ключах обменивается, так что две системы могут правильно построить транспортный уровень. Следующие шаги происходят во время этого обмена:

    Ключи обменены
    Определен алгоритм шифрования с открытым ключом
    Определен алгоритм симметричного шифрования
    Определен алгоритм аутентификации сообщения
    Алгоритм хеширования определен 

Во время обмена ключами сервер идентифицирует себя клиенту с помощью уникального ключа хоста . Если клиент никогда ранее не общался с этим конкретным сервером, ключ хоста сервера неизвестен клиенту и не подключается. OpenSSH решает эту проблему, принимая ключ хоста сервера. Это делается после того, как пользователь уведомлен и принял и подтвердил новый ключ хоста. При последующих подключениях ключ хоста сервера сверяется с сохраненной версией на клиенте, обеспечивая уверенность в том, что клиент действительно обменивается данными с намеченным сервером. Если в будущем ключ хоста больше не совпадает, пользователь должен удалить сохраненную версию клиента, прежде чем может произойти соединение.

Предупреждение
Злоумышленник может маскироваться под SSH-сервер во время первоначального контакта, поскольку локальная система не знает разницы между предполагаемым сервером и ложным, установленным злоумышленником. Чтобы предотвратить это, проверьте целостность нового сервера SSH, связавшись с администратором сервера перед первым подключением или в случае несоответствия ключа хоста.
SSH предназначен для работы практически с любым алгоритмом открытого ключа или форматом кодирования. После того, как начальный обмен ключами создает хеш-значение, используемое для обмена и общее секретное значение, две системы немедленно начинают вычислять новые ключи и алгоритмы для защиты аутентификации и будущих данных, отправляемых по соединению.
После того, как определенное количество данных было передано с использованием данного ключа и алгоритма (точное количество зависит от реализации SSH), происходит другой обмен ключами, генерирующий другой набор значений хеш-функции и новое общее секретное значение. Даже если злоумышленник может определить значение хэша и общего секретного ключа, эта информация полезна только в течение ограниченного периода времени.
12.1.4.2. Аутентификация
Как только транспортный уровень построил защищенный туннель для передачи информации между двумя системами, сервер сообщает клиенту различные поддерживаемые методы аутентификации, такие как использование подписи с шифрованием с закрытым ключом или ввод пароля. Затем клиент пытается аутентифицировать себя на сервере, используя один из этих поддерживаемых методов.
Серверы и клиенты SSH могут быть настроены так, чтобы разрешать разные типы аутентификации, что дает каждой стороне оптимальный уровень контроля. Сервер может решить, какие методы шифрования он поддерживает, основываясь на его модели безопасности, а клиент может выбрать порядок методов аутентификации, чтобы попытаться из доступных вариантов.
12.1.4.3. каналы
После успешной аутентификации на транспортном уровне SSH несколько каналов открываются с помощью метода, называемого мультиплексированием [1] . Каждый из этих каналов осуществляет связь для различных сеансов терминала и для переадресованных сеансов X11.
И клиенты, и серверы могут создавать новый канал. Каждому каналу присваивается другой номер на каждом конце соединения. Когда клиент пытается открыть новый канал, клиенты отправляют номер канала вместе с запросом. Эта информация хранится на сервере и используется для прямой связи с этим каналом. Это делается для того, чтобы различные типы сеансов не влияли друг на друга, и чтобы по окончании данного сеанса его канал мог быть закрыт без прерывания основного соединения SSH.
Каналы также поддерживают управление потоком , что позволяет им отправлять и получать данные упорядоченным образом. Таким образом, данные не отправляются по каналу, пока клиент не получит сообщение о том, что канал открыт.
Клиент и сервер автоматически согласовывают характеристики каждого канала в зависимости от типа услуги, запрашиваемой клиентом, и способа подключения пользователя к сети. Это обеспечивает большую гибкость при работе с различными типами удаленных соединений без необходимости изменения базовой инфраструктуры протокола. 
***********************************************************
12.2. Configuring OpenSSH
12.2.1. Configuration Files
There are two different sets of configuration files: those for client programs (that is, ssh, scp, and sftp), and those for the server (the sshd daemon).
System-wide SSH configuration information is stored in the /etc/ssh/ directory as described in Table 12.1, “System-wide configuration files”. User-specific SSH configuration information is stored in ~/.ssh/ within the user's home directory as described in Table 12.2, “User-specific configuration files”.

Table 12.1. System-wide configuration files
File	Description
/etc/ssh/moduli 	Contains Diffie-Hellman groups used for the Diffie-Hellman key exchange which is critical for constructing a secure transport layer. When keys are exchanged at the beginning of an SSH session, a shared, secret value is created which cannot be determined by either party alone. This value is then used to provide host authentication.
/etc/ssh/ssh_config 	The default SSH client configuration file. Note that it is overridden by ~/.ssh/config if it exists.
/etc/ssh/sshd_config 	The configuration file for the sshd daemon.
/etc/ssh/ssh_host_ecdsa_key 	The ECDSA private key used by the sshd daemon.
/etc/ssh/ssh_host_ecdsa_key.pub 	The ECDSA public key used by the sshd daemon.
/etc/ssh/ssh_host_rsa_key 	The RSA private key used by the sshd daemon for version 2 of the SSH protocol.
/etc/ssh/ssh_host_rsa_key.pub 	The RSA public key used by the sshd daemon for version 2 of the SSH protocol.
/etc/pam.d/sshd 	The PAM configuration file for the sshd daemon.
/etc/sysconfig/sshd 	Configuration file for the sshd service.

Table 12.2. User-specific configuration files
File	Description
~/.ssh/authorized_keys 	Holds a list of authorized public keys for servers. When the client connects to a server, the server authenticates the client by checking its signed public key stored within this file.
~/.ssh/id_ecdsa 	Contains the ECDSA private key of the user.
~/.ssh/id_ecdsa.pub 	The ECDSA public key of the user.
~/.ssh/id_rsa 	The RSA private key used by ssh for version 2 of the SSH protocol.
~/.ssh/id_rsa.pub 	The RSA public key used by ssh for version 2 of the SSH protocol.
~/.ssh/known_hosts 	Contains host keys of SSH servers accessed by the user. This file is very important for ensuring that the SSH client is connecting to the correct SSH server.

Warning
If setting up an SSH server, do not turn off the Privilege Separation feature by using the UsePrivilegeSeparation no directive in the /etc/ssh/sshd_config file. Turning off Privilege Separation disables many security features and exposes the server to potential security vulnerabilities and targeted attacks. For more information about UsePrivilegeSeparation, see the sshd_config(5) manual page or the What is the significance of UsePrivilegeSeparation directive in /etc/ssh/sshd_config file and how to test it ? Red Hat Knowledgebase article.
For information concerning various directives that can be used in the SSH configuration files, see the ssh_config(5) and sshd_config(5) manual pages.
12.2.2. Starting an OpenSSH Server
In order to run an OpenSSH server, you must have the openssh-server package installed. For more information on how to install new packages, see Section 9.2.4, “Installing Packages”.
To start the sshd daemon in the current session, type the following at a shell prompt as root:

~]# systemctl start sshd.service

To stop the running sshd daemon in the current session, use the following command as root:

~]# systemctl stop sshd.service

If you want the daemon to start automatically at boot time, type as root:

~]# systemctl enable sshd.service
Created symlink from /etc/systemd/system/multi-user.target.wants/sshd.service to /usr/lib/systemd/system/sshd.service.

The sshd daemon depends on the network.target target unit, which is sufficient for static configured network interfaces and for default ListenAddress 0.0.0.0 options. To specify different addresses in the ListenAddress directive and to use a slower dynamic network configuration, add dependency on the network-online.target target unit to the sshd.service unit file. To achieve this, create the /etc/systemd/system/sshd.service.d/local.conf file with the following options:

  [Unit]
  Wants=network-online.target
  After=network-online.target

After this, reload the systemd manager configuration using the following command:

~]# systemctl daemon-reload

For more information on how to manage system services in Red Hat Enterprise Linux, see Chapter 10, Managing Services with systemd.
Note that if you reinstall the system, a new set of identification keys will be created. As a result, clients who had connected to the system with any of the OpenSSH tools before the reinstall will see the following message:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.

To prevent this, you can backup the relevant files from the /etc/ssh/ directory. See Table 12.1, “System-wide configuration files” for a complete list, and restore the files whenever you reinstall the system.
12.2.3. Requiring SSH for Remote Connections
For SSH to be truly effective, using insecure connection protocols should be prohibited. Otherwise, a user's password may be protected using SSH for one session, only to be captured later while logging in using Telnet. Some services to disable include telnet, rsh, rlogin, and vsftpd.
For information on how to configure the vsftpd service, see Section 16.2, “FTP”. To learn how to manage system services in Red Hat Enterprise Linux 7, read Chapter 10, Managing Services with systemd.
12.2.4. Using Key-based Authentication
To improve the system security even further, generate SSH key pairs and then enforce key-based authentication by disabling password authentication. To do so, open the /etc/ssh/sshd_config configuration file in a text editor such as vi or nano, and change the PasswordAuthentication option as follows:

PasswordAuthentication no

If you are working on a system other than a new default installation, check that PubkeyAuthentication no has not been set. If connected remotely, not using console or out-of-band access, testing the key-based log in process before disabling password authentication is advised.
To be able to use ssh, scp, or sftp to connect to the server from a client machine, generate an authorization key pair by following the steps below. Note that keys must be generated for each user separately.
To use key-based authentication with NFS-mounted home directories, enable the use_nfs_home_dirs SELinux boolean first:

~]# setsebool -P use_nfs_home_dirs 1

Red Hat Enterprise Linux 7 uses SSH Protocol 2 and RSA keys by default (see Section 12.1.3, “Protocol Versions” for more information).

Important
If you complete the steps as root, only root will be able to use the keys.

Note
If you reinstall your system and want to keep previously generated key pairs, backup the ~/.ssh/ directory. After reinstalling, copy it back to your home directory. This process can be done for all users on your system, including root.
12.2.4.1. Generating Key Pairs
To generate an RSA key pair for version 2 of the SSH protocol, follow these steps:

    Generate an RSA key pair by typing the following at a shell prompt:

    ~]$ ssh-keygen -t rsa
    Generating public/private rsa key pair.
    Enter file in which to save the key (/home/USER/.ssh/id_rsa):

    Press Enter to confirm the default location, ~/.ssh/id_rsa, for the newly created key.
    Enter a passphrase, and confirm it by entering it again when prompted to do so. For security reasons, avoid using the same password as you use to log in to your account.
    After this, you will be presented with a message similar to this:

    Your identification has been saved in /home/USER/.ssh/id_rsa.
    Your public key has been saved in /home/USER/.ssh/id_rsa.pub.
    The key fingerprint is:
    SHA256:UNIgIT4wfhdQH/K7yqmjsbZnnyGDKiDviv492U5z78Y USER@penguin.example.com
    The key's randomart image is:
    +---[RSA 2048]----+
    |o ..==o+.        |
    |.+ . .=oo        |
    | .o. ..o         |
    |  ...  ..        |
    |       .S        |
    |o .     .        |
    |o+ o .o+ ..      |
    |+.++=o*.o .E     |
    |BBBo+Bo.  oo     |
    +----[SHA256]-----+

    Note
    To get an MD5 key fingerprint, which was the default fingerprint in previous versions, use the ssh-keygen command with the -E md5 option.
    By default, the permissions of the ~/.ssh/ directory are set to rwx------ or 700 expressed in octal notation. This is to ensure that only the USER can view the contents. If required, this can be confirmed with the following command:

    ~]$ ls -ld ~/.ssh
    drwx------. 2 USER USER 54 Nov 25 16:56 /home/USER/.ssh/

    To copy the public key to a remote machine, issue a command in the following format:

     ssh-copy-id user@hostname

    This will copy the most recently modified ~/.ssh/id*.pub public key if it is not yet installed. Alternatively, specify the public key's file name as follows:

    ssh-copy-id -i ~/.ssh/id_rsa.pub user@hostname

    This will copy the content of ~/.ssh/id_rsa.pub into the ~/.ssh/authorized_keys file on the machine to which you want to connect. If the file already exists, the keys are appended to its end. 

To generate an ECDSA key pair for version 2 of the SSH protocol, follow these steps:

    Generate an ECDSA key pair by typing the following at a shell prompt:

    ~]$ ssh-keygen -t ecdsa
    Generating public/private ecdsa key pair.
    Enter file in which to save the key (/home/USER/.ssh/id_ecdsa):

    Press Enter to confirm the default location, ~/.ssh/id_ecdsa, for the newly created key.
    Enter a passphrase, and confirm it by entering it again when prompted to do so. For security reasons, avoid using the same password as you use to log in to your account.
    After this, you will be presented with a message similar to this:

    Your identification has been saved in /home/USER/.ssh/id_ecdsa.
    Your public key has been saved in /home/USER/.ssh/id_ecdsa.pub.
    The key fingerprint is:
    SHA256:8BhZageKrLXM99z5f/AM9aPo/KAUd8ZZFPcPFWqK6+M USER@penguin.example.com
    The key's randomart image is:
    +---[ECDSA 256]---+
    |      . .      +=|
    | . . . =      o.o|
    |  + . * .    o...|
    | = . . *  . + +..|
    |. + . . So o * ..|
    |   . o . .+ =  ..|
    |      o oo ..=. .|
    |        ooo...+  |
    |        .E++oo   |
    +----[SHA256]-----+

    By default, the permissions of the ~/.ssh/ directory are set to rwx------ or 700 expressed in octal notation. This is to ensure that only the USER can view the contents. If required, this can be confirmed with the following command:

    ~]$ ls -ld ~/.ssh
                  ~]$ ls -ld ~/.ssh/
    drwx------. 2 USER USER 54 Nov 25 16:56 /home/USER/.ssh/

    To copy the public key to a remote machine, issue a command in the following format:

    ssh-copy-id USER@hostname

    This will copy the most recently modified ~/.ssh/id*.pub public key if it is not yet installed. Alternatively, specify the public key's file name as follows:

    ssh-copy-id -i ~/.ssh/id_ecdsa.pub USER@hostname

    This will copy the content of ~/.ssh/id_ecdsa.pub into the ~/.ssh/authorized_keys on the machine to which you want to connect. If the file already exists, the keys are appended to its end. 

See Section 12.2.4.2, “Configuring ssh-agent” for information on how to set up your system to remember the passphrase.

Important
The private key is for your personal use only, and it is important that you never give it to anyone.
12.2.4.2. Configuring ssh-agent
To store your passphrase so that you do not have to enter it each time you initiate a connection with a remote machine, you can use the ssh-agent authentication agent. If you are running GNOME, you can configure it to prompt you for your passphrase whenever you log in and remember it during the whole session. Otherwise you can store the passphrase for a certain shell prompt.
To save your passphrase during your GNOME session, follow these steps:

    Make sure you have the openssh-askpass package installed. If not, see Section 9.2.4, “Installing Packages” for more information on how to install new packages in Red Hat Enterprise Linux.
    Press the Super key to enter the Activities Overview, type Startup Applications and then press Enter. The Startup Applications Preferences tool appears. The tab containing a list of available startup programs will be shown by default. The Super key appears in a variety of guises, depending on the keyboard and other hardware, but often as either the Windows or Command key, and typically to the left of the Space bar.
    Startup Applications Preferences

    Figure 12.1. Startup Applications Preferences
    Click the Add button on the right, and enter /usr/bin/ssh-add in the Command field.
    Adding new application

    Figure 12.2. Adding new application
    Click Add and make sure the checkbox next to the newly added item is selected.
    Enabling the application

    Figure 12.3. Enabling the application
    Log out and then log back in. A dialog box will appear prompting you for your passphrase. From this point on, you should not be prompted for a password by ssh, scp, or sftp.
    Entering a passphrase

    Figure 12.4. Entering a passphrase

To save your passphrase for a certain shell prompt, use the following command:

~]$ ssh-add
Enter passphrase for /home/USER/.ssh/id_rsa:

Note that when you log out, your passphrase will be forgotten. You must execute the command each time you log in to a virtual console or a terminal window.
 12.2. Конфигурирование OpenSSH
12.2.1. Конфигурационные файлы
Существует два разных набора файлов конфигурации: файлы для клиентских программ (то есть ssh , scp и sftp ) и файлы для сервера (демон sshd ).
Общесистемная информация о конфигурации SSH хранится в каталоге /etc/ssh/ как описано в Таблице 12.1, «Общесистемные файлы конфигурации» . Информация о конфигурации конкретного пользователя SSH хранится в ~/.ssh/ в домашнем каталоге пользователя, как описано в Таблице 12.2, «Файлы конфигурации для конкретного пользователя» .

Таблица 12.1. Общесистемные файлы конфигурации
файл 	Описание
/etc/ssh/moduli 	Содержит группы Диффи-Хеллмана, используемые для обмена ключами Диффи-Хеллмана, что имеет решающее значение для построения безопасного транспортного уровня. При обмене ключами в начале сеанса SSH создается общее секретное значение, которое не может быть определено ни одной из сторон. Это значение затем используется для обеспечения аутентификации хоста.
/etc/ssh/ssh_config 	Файл конфигурации клиента SSH по умолчанию. Обратите внимание, что он переопределяется ~/.ssh/config если он существует.
/etc/ssh/sshd_config 	Файл конфигурации для демона sshd .
/etc/ssh/ssh_host_ecdsa_key 	Закрытый ключ ECDSA, используемый демоном sshd .
/etc/ssh/ssh_host_ecdsa_key.pub 	Открытый ключ ECDSA, используемый демоном sshd .
/etc/ssh/ssh_host_rsa_key 	Закрытый ключ RSA, используемый демоном sshd для версии 2 протокола SSH.
/etc/ssh/ssh_host_rsa_key.pub 	Открытый ключ RSA, используемый демоном sshd для версии 2 протокола SSH.
/etc/pam.d/sshd 	Файл конфигурации PAM для демона sshd .
/etc/sysconfig/sshd 	Файл конфигурации для службы sshd .

Таблица 12.2. Пользовательские файлы конфигурации
файл 	Описание
~/.ssh/authorized_keys 	Содержит список авторизованных открытых ключей для серверов. Когда клиент подключается к серверу, сервер аутентифицирует клиента, проверяя его подписанный открытый ключ, хранящийся в этом файле.
~/.ssh/id_ecdsa 	Содержит закрытый ключ ECDSA пользователя.
~/.ssh/id_ecdsa.pub 	Открытый ключ ECDSA пользователя.
~/.ssh/id_rsa 	Закрытый ключ RSA, используемый ssh для версии 2 протокола SSH.
~/.ssh/id_rsa.pub 	Открытый ключ RSA, используемый ssh для версии 2 протокола SSH.
~/.ssh/known_hosts 	Содержит ключи хоста серверов SSH, к которым обращается пользователь. Этот файл очень важен для обеспечения подключения клиента SSH к правильному серверу SSH.

Предупреждение
При настройке сервера SSH не отключайте функцию Privilege Separation с помощью директивы UsePrivilegeSeparation no в /etc/ssh/sshd_config . Отключение Privilege Separation отключает многие функции безопасности и подвергает сервер потенциальным уязвимостям безопасности и целевым атакам. Для получения дополнительной информации о UsePrivilegeSeparation см. Справочную страницу sshd_config (5) или Какова значимость директивы UsePrivilegeSeparation в файле / etc / ssh / sshd_config и как ее протестировать? Статья в базе знаний Red Hat.
Для получения информации о различных директивах, которые можно использовать в файлах конфигурации SSH, см. ssh_config (5) и sshd_config (5).
12.2.2. Запуск сервера OpenSSH
Чтобы запустить сервер OpenSSH, у вас должен быть установлен пакет openssh-server . Для получения дополнительной информации о том, как установить новые пакеты, см. Раздел 9.2.4, «Установка пакетов» .
Чтобы запустить демон sshd в текущем сеансе, введите в командной строке следующую команду как root :

  ~] # systemctl start sshd.service 

Чтобы остановить запущенный демон sshd в текущем сеансе, используйте в качестве пользователя root следующую команду:

  ~] # systemctl stop sshd.service 

Если вы хотите, чтобы демон запускался автоматически во время загрузки, введите от имени пользователя root :

  ~] # systemctl enable sshd.service
 Создана символическая ссылка от /etc/systemd/system/multi-user.target.wants/sshd.service на /usr/lib/systemd/system/sshd.service. 

Демон sshd зависит от целевого модуля network.target , которого достаточно для статически настроенных сетевых интерфейсов и параметров по умолчанию ListenAddress 0.0.0.0 . Чтобы указать разные адреса в директиве ListenAddress и использовать более медленную динамическую конфигурацию сети, добавьте зависимость от целевого модуля sshd.service файл модуля sshd.service . Для этого создайте /etc/systemd/system/sshd.service.d/local.conf со следующими параметрами:

   [Единица измерения]
   Wants = network-online.target
   После = network-online.target 

После этого перезагрузите конфигурацию systemd manager, используя следующую команду:

  ~] # systemctl daemon-reload 

Для получения дополнительной информации об управлении системными службами в Red Hat Enterprise Linux см. Глава 10, Управление службами с помощью systemd .
Обратите внимание, что если вы переустановите систему, будет создан новый набор ключей идентификации. В результате клиенты, которые подключились к системе с помощью любого из инструментов OpenSSH перед переустановкой, увидят следующее сообщение:

  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@
 @: УДАЛЕННАЯ ИДЕНТИФИКАЦИЯ ХОСТА ИЗМЕНИЛАСЬ!  @
 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@
 ВОЗМОЖНО, ЧТО-ТО ЧТО-ТО ДЕЛАЕТ!
 Кто-то может подслушивать вас прямо сейчас (атака «человек посередине»)!
 Также возможно, что ключ хоста RSA был только что изменен. 

Чтобы предотвратить это, вы можете сделать резервную копию соответствующих файлов из каталога /etc/ssh/ . См. Полный список в таблице 12.1 «Общесистемные файлы конфигурации» и восстанавливайте файлы при каждой переустановке системы.
12.2.3. Требование SSH для удаленных подключений
Чтобы SSH был действительно эффективным, использование небезопасных протоколов соединения должно быть запрещено. В противном случае пароль пользователя может быть защищен с использованием SSH для одного сеанса, но будет перехвачен позднее при входе в систему с использованием Telnet. Некоторые сервисы для отключения включают telnet , rsh , rlogin и vsftpd .
Для получения информации о том, как настроить службу vsftpd , см. Раздел 16.2, «FTP» . Чтобы узнать, как управлять системными службами в Red Hat Enterprise Linux 7, прочитайте Глава 10, Управление службами с помощью systemd .
12.2.4. Использование аутентификации на основе ключей
Чтобы еще больше повысить безопасность системы, сгенерируйте пары ключей SSH, а затем примените аутентификацию на основе ключей, отключив аутентификацию по паролю. Для этого откройте /etc/ssh/sshd_config конфигурации /etc/ssh/sshd_config в текстовом редакторе, например vi или nano , и измените параметр PasswordAuthentication следующим образом:

  PasswordAuthentication нет 

Если вы работаете в системе, отличной от новой установки по умолчанию, убедитесь, что PubkeyAuthentication no не было установлено. При удаленном подключении, не используя консольный или внеполосный доступ, рекомендуется проверить процесс входа в систему на основе ключей перед отключением аутентификации по паролю.
Чтобы использовать ssh , scp или sftp для подключения к серверу с клиентского компьютера, сгенерируйте пару ключей авторизации, выполнив следующие действия. Обратите внимание, что ключи должны генерироваться для каждого пользователя отдельно.
Чтобы использовать основанную на ключах аутентификацию с установленными NFS домашними каталогами, use_nfs_home_dirs логический use_nfs_home_dirs SELinux use_nfs_home_dirs :

  ~] # setsebool -P use_nfs_home_dirs 1 

Red Hat Enterprise Linux 7 по умолчанию использует SSH Protocol 2 и ключи RSA (см. Раздел 12.1.3, «Версии протокола» для получения дополнительной информации).

Важный
Если вы выполните шаги как root , только root сможет использовать ключи.

Заметка
Если вы переустанавливаете свою систему и хотите сохранить ранее сгенерированные пары ключей, сделайте резервную копию каталога ~/.ssh/ . После переустановки скопируйте его обратно в домашний каталог. Этот процесс может быть выполнен для всех пользователей вашей системы, включая root .
12.2.4.1. Генерация пар ключей
Чтобы сгенерировать пару ключей RSA для версии 2 протокола SSH, выполните следующие действия:

    Сгенерируйте пару ключей RSA, введя в командной строке следующую команду:

      ~] $ ssh-keygen -t rsa
     Генерация пары открытый / закрытый ключ RSA.
     Введите файл для сохранения ключа (/home/USER/.ssh/id_rsa): 

    Нажмите Enter, чтобы подтвердить местоположение по умолчанию, ~/.ssh/id_rsa , для вновь созданного ключа.
    Введите ключевую фразу и подтвердите ее, введя ее снова, когда будет предложено сделать это. В целях безопасности не используйте тот же пароль, который вы используете для входа в свою учетную запись.
    После этого вам будет представлено сообщение, похожее на это:

      Ваша идентификация была сохранена в /home/USER/.ssh/id_rsa.
     Ваш открытый ключ был сохранен в /home/USER/.ssh/id_rsa.pub.
     Ключевой отпечаток:
     SHA256: UNIgIT4wfhdQH / K7yqmjsbZnnyGDKiDviv492U5z78Y USER@penguin.example.com
     Изображение ключа randomart:
     + --- [RSA 2048] ---- +
     | o .. == o +.  |
     |. +.  . = oo |
     |  .о.  ..o |
     |  ... .. |
     |  .S |
     | о.  ,  |
     | o + o .o + .. |
     | +. ++ = o * .o .E |
     | BBBo + Бо.  оо |
     + ---- [SHA256] ----- + 

    Заметка
    Чтобы получить отпечаток ключа MD5, который был отпечатком по умолчанию в предыдущих версиях, используйте команду ssh-keygen с параметром -E md5 .
    По умолчанию права доступа к каталогу ~/.ssh/ установлены в rwx------ или 700 выраженные в восьмеричной записи. Это делается для того, чтобы только пользователь мог просматривать содержимое. При необходимости это можно подтвердить с помощью следующей команды:

      ~] $ ls -ld ~/.ssh
     drwx ------.  2 USER USER 54 25 ноября 16:56 /home/USER/.ssh/ 

    Чтобы скопировать открытый ключ на удаленный компьютер, введите команду в следующем формате:

     ssh-copy-id user@hostname 

    Это скопирует последний измененный открытый ключ ~/.ssh/id*.pub если он еще не установлен. В качестве альтернативы, укажите имя файла открытого ключа следующим образом:

     ssh-copy-id -i ~/.ssh/id_rsa.pub user@hostname 

    Это скопирует содержимое файла ~/.ssh/id_rsa.pub в ~/.ssh/id_rsa.pub ~/.ssh/authorized_keys на компьютере, к которому вы хотите подключиться. Если файл уже существует, ключи добавляются в его конец. 

Чтобы создать пару ключей ECDSA для версии 2 протокола SSH, выполните следующие действия:

    Сгенерируйте пару ключей ECDSA, введя в командной строке следующую команду:

      ~] $ ssh-keygen -t ecdsa
     Генерация пары открытый / закрытый ключ ecdsa.
     Введите файл для сохранения ключа (/home/USER/.ssh/id_ecdsa): 

    Нажмите Enter, чтобы подтвердить местоположение по умолчанию, ~/.ssh/id_ecdsa , для вновь созданного ключа.
    Введите ключевую фразу и подтвердите ее, введя ее снова, когда будет предложено сделать это. В целях безопасности не используйте тот же пароль, который вы используете для входа в свою учетную запись.
    После этого вам будет представлено сообщение, похожее на это:

      Ваша идентификация была сохранена в /home/USER/.ssh/id_ecdsa.
     Ваш открытый ключ был сохранен в /home/USER/.ssh/id_ecdsa.pub.
     Ключевой отпечаток:
     SHA256: 8BhZageKrLXM99z5f / AM9aPo / KAUd8ZZFPcPFWqK6 + M USER@penguin.example.com
     Изображение ключа randomart:
     + --- [ECDSA 256] --- +
     |  ,  ,  + = |
     |  ,  ,  ,  = оо |
     |  +  *  о ... |
     |  знак равно  ,  *  + + .. |
     |.  +  ,  Так о * .. |
     |  ,  о  . + = .. |
     |  о оо .. =.  . |
     |  ооо ... + |
     |  .E ++ oO |
     + ---- [SHA256] ----- + 

    По умолчанию права доступа к каталогу ~/.ssh/ установлены в rwx------ или 700 выраженные в восьмеричной записи. Это делается для того, чтобы только пользователь мог просматривать содержимое. При необходимости это можно подтвердить с помощью следующей команды:

      ~] $ ls -ld ~/.ssh
                   ~] $ ls -ld ~ / .ssh /
     drwx ------.  2 USER USER 54 25 ноября 16:56 /home/USER/.ssh/ 

    Чтобы скопировать открытый ключ на удаленный компьютер, введите команду в следующем формате:

     ssh-copy-id USER@hostname 

    Это скопирует последний измененный открытый ключ ~/.ssh/id*.pub если он еще не установлен. В качестве альтернативы, укажите имя файла открытого ключа следующим образом:

     ssh-copy-id -i ~/.ssh/id_ecdsa.pub USER@hostname 

    Это скопирует содержимое ~/.ssh/id_ecdsa.pub в ~/.ssh/authorized_keys на машине, к которой вы хотите подключиться. Если файл уже существует, ключи добавляются в его конец. 

См. Раздел 12.2.4.2, «Настройка ssh-agent» для получения информации о том, как настроить вашу систему для запоминания парольной фразы.

Важный
Закрытый ключ предназначен только для вашего личного использования, и важно, чтобы вы никогда никому его не передавали.
12.2.4.2. Настройка ssh-agent
Чтобы сохранить вашу фразу-пароль, чтобы вам не приходилось вводить ее каждый раз, когда вы устанавливаете соединение с удаленным компьютером, вы можете использовать ssh-agent аутентификации ssh-agent agent. Если вы используете GNOME, вы можете настроить его так, чтобы он запрашивал вашу пароль при каждом входе в систему и запоминал ее в течение всего сеанса. В противном случае вы можете сохранить фразу-пароль для определенного приглашения оболочки.
Чтобы сохранить вашу фразу-пароль во время сеанса GNOME, выполните следующие действия:

    Убедитесь, что у вас установлен пакет openssh-askpass . Если нет, см. Раздел 9.2.4, «Установка пакетов» для получения дополнительной информации о том, как устанавливать новые пакеты в Red Hat Enterprise Linux.
    Нажмите клавишу Super, чтобы войти в Обзор действий, введите Startup Applications и затем нажмите Enter . Появится инструмент « Параметры запуска приложений» . Вкладка со списком доступных программ запуска будет показана по умолчанию. Клавиша Super появляется в разных вариантах, в зависимости от клавиатуры и другого оборудования, но часто это клавиша Windows или Command, обычно слева от пробела.
    Настройки запуска приложений

    Рисунок 12.1. Настройки запуска приложений
    Нажмите кнопку Add справа и введите /usr/bin/ssh-add в поле Command .
    Добавление нового приложения

    Рисунок 12.2. Добавление нового приложения
    Нажмите « Добавить» и убедитесь, что установлен флажок рядом с вновь добавленным элементом.
    Включение приложения

    Рисунок 12.3. Включение приложения
    Выйдите из системы, а затем снова войдите в нее. Появится диалоговое окно с предложением ввести пароль.С этого момента, вы не должны быть предложено ввести пароль на ssh, scpили sftp.
    Ввод парольной фразы

    Рисунок 12.4. Ввод парольной фразы 

Чтобы сохранить вашу фразу-пароль для определенного приглашения оболочки, используйте следующую команду:

~] $ ssh-add
Введите кодовую фразу для /home/USER/.ssh/id_rsa:

Обратите внимание, что при выходе из системы ваш пароль будет забыт. Вы должны выполнять команду каждый раз, когда вы входите в виртуальную консоль или окно терминала.


12.3. OpenSSH Clients
To connect to an OpenSSH server from a client machine, you must have the openssh-clients package installed (see Section 9.2.4, “Installing Packages” for more information on how to install new packages in Red Hat Enterprise Linux).
12.3.1. Using the ssh Utility
The ssh utility allows you to log in to a remote machine and execute commands there. It is a secure replacement for the rlogin, rsh, and telnet programs.
Similarly to the telnet command, log in to a remote machine by using the following command:

ssh hostname

For example, to log in to a remote machine named penguin.example.com, type the following at a shell prompt:

~]$ ssh penguin.example.com

This will log you in with the same user name you are using on the local machine. If you want to specify a different user name, use a command in the following form:

ssh username@hostname

For example, to log in to penguin.example.com as USER, type:

~]$ ssh USER@penguin.example.com

The first time you initiate a connection, you will be presented with a message similar to this:

The authenticity of host 'penguin.example.com' can't be established.
ECDSA key fingerprint is SHA256:vuGKK9dsW34zrZzwjl5g+vOE6EZQvHRQ8zObKYO2mW4.
ECDSA key fingerprint is MD5:7e:15:c3:03:4d:e1:dd:ee:99:dc:3e:f4:b9:67:6b:62.
Are you sure you want to continue connecting (yes/no)?

Users should always check if the fingerprint is correct before answering the question in this dialog. The user can ask the administrator of the server to confirm the key is correct. This should be done in a secure and previously agreed way. If the user has access to the server's host keys, the fingerprint can be checked by using the ssh-keygen command as follows:

~]# ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
SHA256:vuGKK9dsW34zrZzwjl5g+vOE6EZQvHRQ8zObKYO2mW4

Note
To get an MD5 key fingerprint, which was the default fingerprint in previous versions, use the ssh-keygen command with the -E md5 option, for example:

~]# ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub -EM md5
MD5:7e:15:c3:03:4d:e1:dd:ee:99:dc:3e:f4:b9:67:6b:62

Type yes to accept the key and confirm the connection. You will see a notice that the server has been added to the list of known hosts, and a prompt asking for your password:

Warning: Permanently added 'penguin.example.com' (ECDSA) to the list of known hosts.
USER@penguin.example.com's password:

Important
If the SSH server's host key changes, the client notifies the user that the connection cannot proceed until the server's host key is deleted from the ~/.ssh/known_hosts file. Before doing this, however, contact the system administrator of the SSH server to verify the server is not compromised.
To remove a key from the ~/.ssh/known_hosts file, issue a command as follows:

~]# ssh-keygen -R penguin.example.com
# Host penguin.example.com found: line 15 type ECDSA
/home/USER/.ssh/known_hosts updated.
Original contents retained as /home/USER/.ssh/known_hosts.old

After entering the password, you will be provided with a shell prompt for the remote machine.
Alternatively, the ssh program can be used to execute a command on the remote machine without logging in to a shell prompt:

ssh [username@]hostname command

For example, the /etc/redhat-release file provides information about the Red Hat Enterprise Linux version. To view the contents of this file on penguin.example.com, type:

~]$ ssh USER@penguin.example.com cat /etc/redhat-release
USER@penguin.example.com's password:
Red Hat Enterprise Linux Server release 7.0 (Maipo)

After you enter the correct password, the user name will be displayed, and you will return to your local shell prompt.
12.3.2. Using the scp Utility
scp can be used to transfer files between machines over a secure, encrypted connection. In its design, it is very similar to rcp.
To transfer a local file to a remote system, use a command in the following form:

scp localfile username@hostname:remotefile

For example, if you want to transfer taglist.vim to a remote machine named penguin.example.com, type the following at a shell prompt:

~]$ scp taglist.vim USER@penguin.example.com:.vim/plugin/taglist.vim
USER@penguin.example.com's password:
taglist.vim                                   100%  144KB 144.5KB/s   00:00

Multiple files can be specified at once. To transfer the contents of .vim/plugin/ to the same directory on the remote machine penguin.example.com, type the following command:

~]$ scp .vim/plugin/* USER@penguin.example.com:.vim/plugin/
USER@penguin.example.com's password:
closetag.vim                                  100%   13KB  12.6KB/s   00:00
snippetsEmu.vim                               100%   33KB  33.1KB/s   00:00
taglist.vim                                   100%  144KB 144.5KB/s   00:00

To transfer a remote file to the local system, use the following syntax:

scp username@hostname:remotefile localfile

For instance, to download the .vimrc configuration file from the remote machine, type:

~]$ scp USER@penguin.example.com:.vimrc .vimrc
USER@penguin.example.com's password:
.vimrc                                        100% 2233     2.2KB/s   00:00

12.3.3. Using the sftp Utility
The sftp utility can be used to open a secure, interactive FTP session. In its design, it is similar to ftp except that it uses a secure, encrypted connection.
To connect to a remote system, use a command in the following form:

sftp username@hostname

For example, to log in to a remote machine named penguin.example.com with USER as a user name, type:

~]$ sftp USER@penguin.example.com
USER@penguin.example.com's password:
Connected to penguin.example.com.
sftp>

After you enter the correct password, you will be presented with a prompt. The sftp utility accepts a set of commands similar to those used by ftp (see Table 12.3, “A selection of available sftp commands”).

Table 12.3. A selection of available sftp commands
Command	Description
ls [directory] 	List the content of a remote directory. If none is supplied, a current working directory is used by default.
cd directory 	Change the remote working directory to directory.
mkdir directory 	Create a remote directory.
rmdir path 	Remove a remote directory.
put localfile [remotefile] 	Transfer localfile to a remote machine.
get remotefile [localfile] 	Transfer remotefile from a remote machine.
For a complete list of available commands, see the sftp(1) manual page.


12.3. OpenSSH Clients
To connect to an OpenSSH server from a client machine, you must have the openssh-clients package installed (see Section 9.2.4, “Installing Packages” for more information on how to install new packages in Red Hat Enterprise Linux).
12.3.1. Using the ssh Utility
The ssh utility allows you to log in to a remote machine and execute commands there. It is a secure replacement for the rlogin, rsh, and telnet programs.
Similarly to the telnet command, log in to a remote machine by using the following command:

ssh hostname

For example, to log in to a remote machine named penguin.example.com, type the following at a shell prompt:

~]$ ssh penguin.example.com

This will log you in with the same user name you are using on the local machine. If you want to specify a different user name, use a command in the following form:

ssh username@hostname

For example, to log in to penguin.example.com as USER, type:

~]$ ssh USER@penguin.example.com

The first time you initiate a connection, you will be presented with a message similar to this:

The authenticity of host 'penguin.example.com' can't be established.
ECDSA key fingerprint is SHA256:vuGKK9dsW34zrZzwjl5g+vOE6EZQvHRQ8zObKYO2mW4.
ECDSA key fingerprint is MD5:7e:15:c3:03:4d:e1:dd:ee:99:dc:3e:f4:b9:67:6b:62.
Are you sure you want to continue connecting (yes/no)?

Users should always check if the fingerprint is correct before answering the question in this dialog. The user can ask the administrator of the server to confirm the key is correct. This should be done in a secure and previously agreed way. If the user has access to the server's host keys, the fingerprint can be checked by using the ssh-keygen command as follows:

~]# ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
SHA256:vuGKK9dsW34zrZzwjl5g+vOE6EZQvHRQ8zObKYO2mW4

Note
To get an MD5 key fingerprint, which was the default fingerprint in previous versions, use the ssh-keygen command with the -E md5 option, for example:

~]# ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub -EM md5
MD5:7e:15:c3:03:4d:e1:dd:ee:99:dc:3e:f4:b9:67:6b:62

Type yes to accept the key and confirm the connection. You will see a notice that the server has been added to the list of known hosts, and a prompt asking for your password:

Warning: Permanently added 'penguin.example.com' (ECDSA) to the list of known hosts.
USER@penguin.example.com's password:

Important
If the SSH server's host key changes, the client notifies the user that the connection cannot proceed until the server's host key is deleted from the ~/.ssh/known_hosts file. Before doing this, however, contact the system administrator of the SSH server to verify the server is not compromised.
To remove a key from the ~/.ssh/known_hosts file, issue a command as follows:

~]# ssh-keygen -R penguin.example.com
# Host penguin.example.com found: line 15 type ECDSA
/home/USER/.ssh/known_hosts updated.
Original contents retained as /home/USER/.ssh/known_hosts.old

After entering the password, you will be provided with a shell prompt for the remote machine.
Alternatively, the ssh program can be used to execute a command on the remote machine without logging in to a shell prompt:

ssh [username@]hostname command

For example, the /etc/redhat-release file provides information about the Red Hat Enterprise Linux version. To view the contents of this file on penguin.example.com, type:

~]$ ssh USER@penguin.example.com cat /etc/redhat-release
USER@penguin.example.com's password:
Red Hat Enterprise Linux Server release 7.0 (Maipo)

After you enter the correct password, the user name will be displayed, and you will return to your local shell prompt.
12.3.2. Using the scp Utility
scp can be used to transfer files between machines over a secure, encrypted connection. In its design, it is very similar to rcp.
To transfer a local file to a remote system, use a command in the following form:

scp localfile username@hostname:remotefile

For example, if you want to transfer taglist.vim to a remote machine named penguin.example.com, type the following at a shell prompt:

~]$ scp taglist.vim USER@penguin.example.com:.vim/plugin/taglist.vim
USER@penguin.example.com's password:
taglist.vim                                   100%  144KB 144.5KB/s   00:00

Multiple files can be specified at once. To transfer the contents of .vim/plugin/ to the same directory on the remote machine penguin.example.com, type the following command:

~]$ scp .vim/plugin/* USER@penguin.example.com:.vim/plugin/
USER@penguin.example.com's password:
closetag.vim                                  100%   13KB  12.6KB/s   00:00
snippetsEmu.vim                               100%   33KB  33.1KB/s   00:00
taglist.vim                                   100%  144KB 144.5KB/s   00:00

To transfer a remote file to the local system, use the following syntax:

scp username@hostname:remotefile localfile

For instance, to download the .vimrc configuration file from the remote machine, type:

~]$ scp USER@penguin.example.com:.vimrc .vimrc
USER@penguin.example.com's password:
.vimrc                                        100% 2233     2.2KB/s   00:00

12.3.3. Using the sftp Utility
The sftp utility can be used to open a secure, interactive FTP session. In its design, it is similar to ftp except that it uses a secure, encrypted connection.
To connect to a remote system, use a command in the following form:

sftp username@hostname

For example, to log in to a remote machine named penguin.example.com with USER as a user name, type:

~]$ sftp USER@penguin.example.com
USER@penguin.example.com's password:
Connected to penguin.example.com.
sftp>

After you enter the correct password, you will be presented with a prompt. The sftp utility accepts a set of commands similar to those used by ftp (see Table 12.3, “A selection of available sftp commands”).

Table 12.3. A selection of available sftp commands
Command	Description
ls [directory] 	List the content of a remote directory. If none is supplied, a current working directory is used by default.
cd directory 	Change the remote working directory to directory.
mkdir directory 	Create a remote directory.
rmdir path 	Remove a remote directory.
put localfile [remotefile] 	Transfer localfile to a remote machine.
get remotefile [localfile] 	Transfer remotefile from a remote machine.
For a complete list of available commands, see the sftp(1) manual page.

 12.3. Клиенты OpenSSH
Чтобы подключиться к серверу OpenSSH с клиентского компьютера, у вас должен быть установлен пакет openssh-clients (см. Раздел 9.2.4, «Установка пакетов» для получения дополнительной информации об установке новых пакетов в Red Hat Enterprise Linux).
12.3.1. Использование утилиты ssh
Утилита ssh позволяет вам войти на удаленный компьютер и выполнять там команды. Это безопасная замена для программ rlogin , rsh и telnet .
Аналогично команде telnet войдите на удаленный компьютер с помощью следующей команды:

  имя хоста ssh 

Например, чтобы войти на удаленный компьютер с именем penguin.example.com , введите в командной строке следующую команду:

  ~] $ ssh penguin.example.com 

Это позволит вам войти под тем же именем пользователя, которое вы используете на локальном компьютере. Если вы хотите указать другое имя пользователя, используйте команду в следующей форме:

  ssh username @ hostname 

Например, чтобы войти на penguin.example.com от имени USER , введите:

  ~] $ ssh USER@penguin.example.com 

При первом подключении вам будет показано сообщение, подобное следующему:

  Подлинность хоста penguin.example.com не может быть установлена.
 Отпечаток ключа ECDSA - SHA256: vuGKK9dsW34zrZzwjl5g + vOE6EZQvHRQ8zObKYO2mW4.
 Отпечаток ключа ECDSA: MD5: 7e: 15: c3: 03: 4d: e1: dd: ee: 99: dc: 3e: f4: b9: 67: 6b: 62.
 Вы уверены, что хотите продолжить подключение (да / нет)? 

Пользователи должны всегда проверять правильность отпечатка пальца, прежде чем отвечать на вопрос в этом диалоговом окне. Пользователь может попросить администратора сервера подтвердить правильность ключа. Это должно быть сделано безопасным и предварительно согласованным способом. Если пользователь имеет доступ к ключам хоста сервера, отпечаток пальца можно проверить с помощью команды ssh-keygen следующим образом:

  ~] # ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
 SHA256: vuGKK9dsW34zrZzwjl5g + vOE6EZQvHRQ8zObKYO2mW4 

Заметка
Чтобы получить отпечаток ключа MD5, который был отпечатком по умолчанию в предыдущих версиях, используйте команду ssh-keygen с параметром -E md5 , например:

  ~] # ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub -EM md5
 MD5: 7e: 15: с3: 03: 4d: е1: дд: й: 99: DC: 3e: f4: b9: 67: 6b: 62 

Введите yes чтобы принять ключ и подтвердить соединение. Вы увидите уведомление о том, что сервер был добавлен в список известных хостов, и запрос на ввод пароля:

  Предупреждение: навсегда добавлен 'penguin.example.com' (ECDSA) в список известных хостов.
 USER@penguin.example.com пароль: 

Важный
Если ключ хоста сервера SSH изменяется, клиент уведомляет пользователя о том, что соединение не может быть установлено, пока ключ хоста сервера не будет удален из файла ~/.ssh/known_hosts . Однако перед этим обратитесь к системному администратору сервера SSH, чтобы убедиться, что сервер не скомпрометирован.
Чтобы удалить ключ из файла ~/.ssh/known_hosts , ~/.ssh/known_hosts команду:

  ~] # ssh-keygen -R penguin.example.com
 Найден # хост penguin.example.com: строка 15, тип ECDSA
 /home/USER/.ssh/known_hosts обновлен.
 Исходное содержимое сохраняется как /home/USER/.ssh/known_hosts.old 

После ввода пароля вам будет предоставлено приглашение оболочки для удаленного компьютера.
В качестве альтернативы, программа ssh может использоваться для выполнения команды на удаленном компьютере без входа в приглашение оболочки:

  ssh [ имя пользователя @ ] команда hostname 

Например, файл /etc/redhat-release содержит информацию о версии Red Hat Enterprise Linux. Чтобы просмотреть содержимое этого файла на penguin.example.com , введите:

  ~] $ ssh USER@penguin.example.com cat /etc/redhat-release
 USER@penguin.example.com пароль:
 Red Hat Enterprise Linux Server, версия 7.0 (Maipo) 

После того, как вы введете правильный пароль, появится имя пользователя, и вы вернетесь к приглашению локальной оболочки.
12.3.2. Использование утилиты scp
scp может использоваться для передачи файлов между компьютерами по безопасному зашифрованному соединению. По своему дизайну он очень похож на rcp .
Чтобы передать локальный файл в удаленную систему, используйте команду в следующей форме:

 scp localfile username @ hostname : remotefile 

Например, если вы хотите перенести taglist.vim на удаленный компьютер с именем penguin.example.com , введите в командной строке следующую команду:

  ~] $ scp taglist.vim USER@penguin.example.com:.vim/plugin/taglist.vim
 USER@penguin.example.com пароль:
 taglist.vim 100% 144KB 144,5KB / с 00:00 

Несколько файлов могут быть указаны одновременно. Чтобы перенести содержимое .vim/plugin/ в тот же каталог на удаленном компьютере penguin.example.com , введите следующую команду:

  ~] $ scp .vim/plugin/* USER@penguin.example.com:.vim/plugin/
 USER@penguin.example.com пароль:
 closetag.vim 100% 13KB 12,6KB / s 00:00
 snippetsEmu.vim 100% 33KB 33.1KB / s 00:00
 taglist.vim 100% 144KB 144,5KB / с 00:00 

Чтобы передать удаленный файл в локальную систему, используйте следующий синтаксис:

 scp username @ hostname : remotefile localfile 

Например, чтобы загрузить файл конфигурации .vimrc с удаленного компьютера, введите:

  ~] $ scp USER@penguin.example.com:.vimrc .vimrc
 USER@penguin.example.com пароль:
 .vimrc 100% 2233 2,2 КБ / с 00:00 

12.3.3. Использование утилиты sftp
Утилита sftp может использоваться для открытия безопасного интерактивного сеанса FTP. По своей конструкции он похож на ftp за исключением того, что использует безопасное зашифрованное соединение.
Чтобы подключиться к удаленной системе, используйте команду в следующей форме:

 sftp username @ hostname 

Например, чтобы войти на удаленный компьютер с именем penguin.example.com с именем пользователя USER , введите:

  ~] $ sftp USER@penguin.example.com
 USER@penguin.example.com пароль:
 Подключен к penguin.example.com.
 SFTP> 

После того, как вы введете правильный пароль, вы получите приглашение. Утилита sftp принимает набор команд, аналогичных тем, которые используются ftp (см. Таблицу 12.3, «Выбор доступных команд sftp» ).

Таблица 12.3. Выбор доступных команд sftp
команда 	Описание
ls [ каталог ] 	Список содержимого удаленного каталога . Если ничего не указано, по умолчанию используется текущий рабочий каталог.
каталог cd 	Измените удаленный рабочий каталог на каталог .
каталог mkdir 	Создайте удаленный каталог .
rmdir путь 	Удалить удаленный каталог .
put локальный файл [ удаленный файл ] 	Перенести локальный файл на удаленный компьютер.
get удаленный файл [ localfile ] 	Передача удаленного файла с удаленного компьютера.
Полный список доступных команд см. На странице руководства sftp (1).

************************************************************************


12.4. More Than a Secure Shell
A secure command-line interface is just the beginning of the many ways SSH can be used. Given the proper amount of bandwidth, X11 sessions can be directed over an SSH channel. Or, by using TCP/IP forwarding, previously insecure port connections between systems can be mapped to specific SSH channels.
12.4.1. X11 Forwarding
To open an X11 session over an SSH connection, use a command in the following form:

ssh -Y username@hostname

For example, to log in to a remote machine named penguin.example.com with USER as a user name, type:

~]$ ssh -Y USER@penguin.example.com
USER@penguin.example.com's password:

When an X program is run from the secure shell prompt, the SSH client and server create a new secure channel, and the X program data is sent over that channel to the client machine transparently.
Note that the X Window system must be installed on the remote system before X11 forwarding can take place. Enter the following command as root to install the X11 package group:

~]# yum group install "X Window System"

For more information on package groups, see Section 9.3, “Working with Package Groups”.
X11 forwarding can be very useful. For example, X11 forwarding can be used to create a secure, interactive session of the Print Settings utility. To do this, connect to the server using ssh and type:

~]$ system-config-printer &

The Print Settings tool will appear, allowing the remote user to safely configure printing on the remote system.
12.4.2. Port Forwarding
SSH can secure otherwise insecure TCP/IP protocols via port forwarding. When using this technique, the SSH server becomes an encrypted conduit to the SSH client.
Port forwarding works by mapping a local port on the client to a remote port on the server. SSH can map any port from the server to any port on the client. Port numbers do not need to match for this technique to work.

Note
Setting up port forwarding to listen on ports below 1024 requires root level access.
To create a TCP/IP port forwarding channel which listens for connections on the localhost, use a command in the following form:

ssh -L local-port:remote-hostname:remote-port username@hostname

For example, to check email on a server called mail.example.com using POP3 through an encrypted connection, use the following command:

~]$ ssh -L 1100:mail.example.com:110 mail.example.com

Once the port forwarding channel is in place between the client machine and the mail server, direct a POP3 mail client to use port 1100 on the localhost to check for new email. Any requests sent to port 1100 on the client system will be directed securely to the mail.example.com server.
If mail.example.com is not running an SSH server, but another machine on the same network is, SSH can still be used to secure part of the connection. However, a slightly different command is necessary:

~]$ ssh -L 1100:mail.example.com:110 other.example.com

In this example, POP3 requests from port 1100 on the client machine are forwarded through the SSH connection on port 22 to the SSH server, other.example.com. Then, other.example.com connects to port 110 on mail.example.com to check for new email. Note that when using this technique, only the connection between the client system and other.example.com SSH server is secure.
The OpenSSH suite also provides local and remote port forwarding of UNIX domain sockets. To forward UNIX domain sockets over the network to another machine, use the ssh -L local-socket:remote-socket username@hostname command, for example:

~]$ ssh -L /var/mysql/mysql.sock:/var/mysql/mysql.sock username@hostname

Port forwarding can also be used to get information securely through network firewalls. If the firewall is configured to allow SSH traffic via its standard port (that is, port 22) but blocks access to other ports, a connection between two hosts using the blocked ports is still possible by redirecting their communication over an established SSH connection.

Important
Using port forwarding to forward connections in this manner allows any user on the client system to connect to that service. If the client system becomes compromised, the attacker also has access to forwarded services.
System administrators concerned about port forwarding can disable this functionality on the server by specifying a No parameter for the AllowTcpForwarding line in /etc/ssh/sshd_config and restarting the sshd service.


12.4. Больше, чем безопасная оболочка
Безопасный интерфейс командной строки - это только начало многих способов использования SSH. При правильной пропускной способности сеансы X11 могут быть направлены по каналу SSH. Или с помощью переадресации TCP / IP ранее небезопасные портовые соединения между системами могут быть сопоставлены с конкретными каналами SSH.
12.4.1. X11 Переадресация
Чтобы открыть сеанс X11 через соединение SSH, используйте команду в следующей форме:

 ssh -Y username @ hostname 

Например, чтобы войти на удаленный компьютер с именем penguin.example.com с именем пользователя USER , введите:

  ~] $ ssh -Y USER@penguin.example.com
 USER@penguin.example.com пароль: 

Когда программа X запускается из приглашения безопасной оболочки, клиент и сервер SSH создают новый безопасный канал, и данные программы X прозрачно отправляются по этому каналу на клиентский компьютер.
Обратите внимание, что система X Window должна быть установлена ​​на удаленной системе до того, как будет выполнена пересылка X11. Введите следующую команду как root для установки группы пакетов X11:

  ~] # yum group install "X Window System" 

Для получения дополнительной информации о группах пакетов см. Раздел 9.3, «Работа с группами пакетов» .
Пересылка X11 может быть очень полезна. Например, пересылку X11 можно использовать для создания безопасного интерактивного сеанса утилиты « Параметры печати» . Для этого подключитесь к серверу с помощью ssh и введите:

  ~] $ system-config-printer & 

Появится инструмент « Параметры печати» , позволяющий удаленному пользователю безопасно настроить печать в удаленной системе.
12.4.2. Перенаправление порта
SSH может защитить небезопасные TCP/IP через переадресацию портов. При использовании этого метода сервер SSH становится зашифрованным каналом для клиента SSH.
Переадресация портов работает путем сопоставления локального порта на клиенте с удаленным портом на сервере. SSH может сопоставить любой порт с сервера любому порту на клиенте. Номера портов не должны совпадать, чтобы эта техника работала.

Заметка
Настройка переадресации портов для прослушивания портов ниже 1024 требует доступа на уровне root .
Чтобы создать канал пересылки портов TCP / IP, который прослушивает соединения на localhost , используйте команду в следующей форме:

 ssh -L local-port : remote-hostname : remote-port username @ hostname 

Например, чтобы проверить электронную почту на сервере mail.example.com с использованием POP3 через зашифрованное соединение, используйте следующую команду:

  ~] $ ssh -L 1100:mail.example.com:110 mail.example.com 

Как только канал переадресации портов будет установлен между клиентским компьютером и почтовым сервером, направьте почтовый клиент POP3 на использование порта 1100 на localhost для проверки новой электронной почты. Любые запросы, отправленные на порт 1100 в клиентской системе, будут надежно направлены на сервер mail.example.com .
Если mail.example.com не работает SSH-сервер, но другой компьютер в той же сети, SSH по-прежнему может использоваться для защиты части соединения. Однако, немного другая команда необходима:

  ~] $ ssh -L 1100:mail.example.com:110 other.example.com 

В этом примере запросы POP3 от порта 1100 на клиентском компьютере перенаправляются через соединение SSH через порт 22 на сервер SSH, other.example.com . Затем other.example.com подключается к порту 110 на mail.example.com для проверки новой электронной почты. Обратите внимание, что при использовании этого метода other.example.com только соединение между клиентской системой и SSH-сервером other.example.com .
Пакет OpenSSH также обеспечивает локальную и удаленную переадресацию портов для доменных сокетов UNIX. Чтобы переслать сокеты домена UNIX по сети на другой компьютер, используйте команду ssh -L local-socket:remote-socket username@hostname , например:

  ~] $ ssh -L /var/mysql/mysql.sock:/var/mysql/mysql.sock username@hostname 

Переадресация портов также может использоваться для безопасного получения информации через сетевые брандмауэры. Если брандмауэр настроен на пропуск трафика SSH через свой стандартный порт (то есть порт 22), но блокирует доступ к другим портам, соединение между двумя хостами, использующими заблокированные порты, все еще возможно, перенаправляя их связь через установленное соединение SSH.

Важный
Использование переадресации портов для переадресации соединений таким способом позволяет любому пользователю клиентской системы подключаться к этой услуге. Если клиентская система подвергается риску, злоумышленник также получает доступ к переадресованным сервисам.
Системные администраторы, обеспокоенные переадресацией портов, могут отключить эту функцию на сервере, указав параметр No для строки AllowTcpForwarding в /etc/ssh/sshd_config и перезапустив службу sshd .

***********************************************

12.5. Additional Resources
For more information on how to configure or connect to an OpenSSH server on Red Hat Enterprise Linux, see the resources listed below.
Installed Documentation

    sshd(8) — The manual page for the sshd daemon documents available command line options and provides a complete list of supported configuration files and directories.
    ssh(1) — The manual page for the ssh client application provides a complete list of available command line options and supported configuration files and directories.
    scp(1) — The manual page for the scp utility provides a more detailed description of this utility and its usage.
    sftp(1) — The manual page for the sftp utility.
    ssh-keygen(1) — The manual page for the ssh-keygen utility documents in detail how to use it to generate, manage, and convert authentication keys used by ssh.
    ssh_config(5) — The manual page named ssh_config documents available SSH client configuration options.
    sshd_config(5) — The manual page named sshd_config provides a full description of available SSH daemon configuration options. 

Online Documentation

    OpenSSH Home Page — The OpenSSH home page containing further documentation, frequently asked questions, links to the mailing lists, bug reports, and other useful resources.
    OpenSSL Home Page — The OpenSSL home page containing further documentation, frequently asked questions, links to the mailing lists, and other useful resources. 

See Also

    Chapter 6, Gaining Privileges documents how to gain administrative privileges by using the su and sudo commands.
    Chapter 10, Managing Services with systemd provides more information on systemd and documents how to use the systemctl command to manage system services. 

12,5. Дополнительные ресурсы
Для получения дополнительной информации о том, как настроить или подключиться к серверу OpenSSH в Red Hat Enterprise Linux, см. Ресурсы, перечисленные ниже.
Установленная документация

    sshd (8) - Страница руководства для демона sshd описывает доступные параметры командной строки и предоставляет полный список поддерживаемых файлов конфигурации и каталогов.
    ssh (1) - Страница справочника по клиентскому приложению ssh содержит полный список доступных параметров командной строки, а также поддерживаемых файлов конфигурации и каталогов.
    scp (1) - Страница руководства для утилиты scp содержит более подробное описание этой утилиты и ее использования.
    sftp (1) - страница руководства для утилиты sftp .
    ssh-keygen (1) - Страница руководства для утилиты ssh-keygen подробно описывает, как использовать ее для генерации, управления и преобразования ключей аутентификации, используемых ssh .
    ssh_config (5) - Страница справочника с именем ssh_config документирует доступные параметры конфигурации клиента SSH.
    sshd_config (5) - Страница справочника с именем sshd_config предоставляет полное описание доступных параметров конфигурации демона SSH. 

Онлайн документация

    Домашняя страница OpenSSH - Домашняя страница OpenSSH, содержащая дополнительную документацию, часто задаваемые вопросы, ссылки на списки рассылки, отчеты об ошибках и другие полезные ресурсы.
    Домашняя страница OpenSSL - домашняя страница OpenSSL, содержащая дополнительную документацию, часто задаваемые вопросы, ссылки на списки рассылки и другие полезные ресурсы. 

Смотрите также

    Глава 6 « Получение привилегий» описывает, как получить права администратора с помощью команд su и sudo .
    Глава 10, Управление службами с помощью systemd, предоставляет больше информации о systemd и документах о том, как использовать команду systemctl для управления системными службами. 