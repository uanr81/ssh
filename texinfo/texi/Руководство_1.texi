@node Руководство 1, Руководство 2, sshd_config_example 2, Top
@chapter Руководство по настройке SSH CA

@menu
* Вступление SSH - базовая настройка::
* Основы центра сертификации::
* Вступление использование СА SSH::
* SSH Продолжение - разработка CA пункт 2::
* Генерация списка отзыва ключей (KRL)::
* Аутентификация SSH через пользовательские сертификаты (сервер)::
* AuthorizedKeysCommand::
* Работа с распределением ключей::
* Работа с запаздывающими сетями::
* X11 Forwarding::
* Принудительные команды::
* параметры открытого ключа::
* туннелирование IP с устройством TUN::
* TCP Forwarding of STDIN/STDOUT::
* SSH туннелирование TCP::
* поток подключения::
* Клиент Config::
* защита закрытого ключа SSH::
* наши первые ключи SSH::
@end menu

@node Вступление SSH - базовая настройка
@section Вступление SSH - базовая настройка
@ifinfo
@heading Вступление SSH - базовая настройка
@end ifinfo

Когда-то давным-давно в месте, не слишком далеко, родился Интернет. В первые дни люди
использовали базовые протоколы для взаимодействия друг с другом и обмена информацией. Одна
партия этих протоколов позволяла людям удаленно подключаться к другому компьютеру и входить
в систему для интерактивной оболочки или передавать удаленные команды для обработки. Это
были telnet, rsh и rlogin. Были также rcp и ftp для передачи файлов. Все это было
замечательно, пока людям не нужно было запирать свои двери ночью, потому что соседи стали
слишком любопытными. Безопасность стала проблемой, и SSH родился.

Сегодня большинство людей считают OpenSSH де-факто программным обеспечением для служб
SSH. Он содержит как серверный компонент (sshd), так и подсистему sftp (для замены FTP) и
несколько клиентов для обработки удаленных входов в систему и передачи файлов (ssh и scp).
Правда в том, что существует множество пакетов на выбор, для обоих связь на стороне
сервера и на стороне клиента с этими новыми протоколами. Я могу рассказать о некоторых из
них, но эта серия будет начинаться с OpenSSH, потому что он наиболее популярен в настоящее
время. Мы начнем с базовой настройки, а затем перейдем к более сложным настройкам, чтобы
покрыть различные потребности в зависимости от масштаба операции, требующей такого типа
организации доступа.

Первоначальное объяснение того, как это работает, заключается в том, что пользователь на
рабочей станции A хочет иметь возможность удаленного входа на сервер B для выполнения
некоторой рабочей нагрузки. Помните, что каждый сеанс SSH состоит из фрагментов информации
на самом базовом уровне. Пользователь (User_A) на рабочей станции или сервере
(Workstation_A) хочет удаленно подключиться к серверу (Server_B) как некоторый пользователь
(User_B) для выполнения рабочей нагрузки. Мы будем использовать эти метки в дальнейшем,
чтобы описать, как настроить программное обеспечение для каждого типа сценария, который мы
хотим охватить. В конце концов будет задействована третья система (либо LDAP,
либо Certificate Authority, либо и то и другое), поэтому мы добавим метку _C, когда
дойдем до этого. На данный момент, просто помните, что “_A” будет представлять
“coming from” (приходящий из), а “_B” будет представлять “going to” (собирается в) для
направленности каждого потока сеанса.

Таким образом, прежде чем User_A сможет подключиться к Server_B с SSH, Server_B должен
иметь запущенную службу SSH. Программное обеспечение может быть установлено из исходного
кода или из любой системы управления пакетами, которую поддерживает ваш сервер OS.
RPM/yum и DPKG/apt-get являются общими для систем на базе RedHat и Debian, соответственно.
В AIX есть installp/RPM. HP-UX имеет Swinstall. Просто используйте соответствующее
программное обеспечение для системы, которую вы поддерживаете, но помните, что для
некоторых из более продвинутых функций потребуются более новые версии OpenSSH, поэтому,
если вы попробуете что-то, и это не сработает, проверьте версию вашего сервера.

Теперь, когда OpenSSH sshd был установлен с помощью любых средств, которые вы выбрали,
User_A требуется клиентское программное обеспечение. Здесь должно быть то же самое дело,
как раньше. Используйте любое программное обеспечение для управления пакетами, которое
вы выберете. Существует клиент OpenSSH через проект Cygwin для Windows для “follow along”,
когда ваша рабочая станция - Windows, но другие клиенты могут работать лучше для
большинства этих сценариев. PuTTy и его производные, WinSCP, MobaXTerm - отличные клиенты
для Windows. Однако когда мы добираемся до соединений на основе сертификатов, их может быть
недостаточно. Просто установите клиент OpenSSH сейчас на любой платформе, с которой вы
работаете, и давайте двигаться дальше.

Теперь у Workstation_A и Server_B есть программное обеспечение, необходимое для
установления соединения. Если User_A хочет подключиться к Server_B как User_B,
учетная запись “User_B” должна существовать на сервере или, по крайней мере, быть
пользователем, который может проходить аутентификацию (LDAP или аналогичный). Пока мы
будем предполагать, что используются локальные учетные записи. Таким образом, чтобы
установить соединение, User_A на Workstation_A необходимо знать пароль для User_B на
Server_B. Затем введите следующее, чтобы установить соединение (при условии, что
учетная запись активна и не заблокирована).

Как User_A из терминальной подсказки:
@display
ssh User_B@@Server_B
@end display
Это так просто. Это почти не стоит освещать, я знаю. Тем не менее, каждая публикация
в этой серии будет делать шаг к тому, чтобы все работало более гладко с точки зрения
эксплуатации и безопасности, так что оставайтесь со мной. Далее мы рассмотрим
настройку пар открытого и закрытого ключей для аутентификации без пароля.

@node Основы центра сертификации
@section Основы центра сертификации
@ifinfo
@heading Основы центра сертификации
@end ifinfo

Принцип работы OpenSSH Certificate Authority зависит от нескольких компонентов.
Во-первых, должен быть один доверенный подписывающий орган. Это может быть любая
система, и для этого необходимо, чтобы было ИСКЛЮЧЕНО активное подключение к сети,
этой системы и рукопожатие client/server происходило с использованием подписанных
ключей CA. Должен также быть Key Revocation List, а также средство для обновления
KRL. Правильная Identity и платформа Access Management (IAM) могли бы справиться
с этим. Быстродействие можно достигнуть с помощью подходящего инструментария
Configuration Management/Server Automation, таким как Puppet, Chef, Salt, или Ansible.
Мы не будем рассматривать использование любого из этих инструментов в этой серии,
но мы (скорее всего) рассмотрим альтернативное решение, когда ни одна из предыдущих
рекомендаций не доступна. Сейчас мы только представим основные понятия и основы
работы OpenSSH Certificate Authority.

Давайте настроим участников. Есть человек (User_A), которому нужно войти на целевую
машину (Server_A) под своим именем. Он делает вход со своего ноутбука (Workstation_A.)
Обычно User_A генерирует свою пару ключей, регистрируется в Server_A под своим именем
и помещает открытый ключ в файл author_keys в своей домашней директории. Вместо этого
мы собираемся привлечь нового участника, который действует как доверенная третья
сторона. Это будет Certificate Authority (CA). CA должен запускаться
непривилегированным пользователем на сервере, который либо не подключен напрямую к сети,
либо защищен. Практическая возможность подписи также должна быть ограничена небольшой
группой людей. Для нашего примера предположим, что он изолирован от сети.

Мы предполагаем, что CA уже настроен, но вот шаги, которые нужно было сделать для этого.
Создайте непривилегированного пользователя (и группу) для подписи. Переключитесь на
этого пользователя и создайте структуру каталогов подписи CA. Используйте ssh-keygen,
чтобы создать ключ(и) подписи сертификата.

Есть два типа сертификатов, которые могут быть подписаны. Сертификат пользователя
аутентифицирует пользователей на серверах. Сертификат хоста аутентифицирует хосты
для пользователей. Зачем нам оба?

Сертификат хоста дает нам возможность установить новый сервер в нашей среде, подписать
его ключи хоста центром сертификации, и тогда клиент узнает, что новый ключ в порядке,
не предлагая пользователю сначала доверять ключу. Это уменьшает некоторые проблемы с
управлением файлом known_hosts.

Пользовательский сертификат дает нам возможность сообщить серверу, что с нашим ключом
все в порядке, без необходимости сначала помещать ключ на сервер. Это устраняет некоторые
проблемы с управлением распределением ключей.

Подписанный сертификат пользователя может накладывать ограничения на подписанный открытый
ключ, включая все ограничения, которые мы обсуждали в разделе pre-amble для записей
authorized_keys.

Давайте посмотрим на общий обзор рабочего процесса сейчас. Далее мы рассмотрим команды,
необходимые для поддержки вышеупомянутой структуры центра сертификации, а также команды
для подписи сертификатов хоста и пользователя.

Сценарий рабочего процесса:
@display
   Используется новая машина.

   Ключи хоста регенерируются (если, например, это клонированная виртуальная машина)
   и подписываются Certificate Authority. Этот подписанный сертификат помещается
   обратно на новый компьютер, и это все, что нужно, если клиенты настроены правильно.

   Чтобы клиент мог воспользоваться этим, ему нужна специальная запись known_hosts,
   которая начинается с @@cert-authority и сопровождается открытым ключом для
   подписанных сертификатов хоста. Когда пользователь входит в систему на новом
   компьютере, поток подключения будет включать в себя сервер, представляющий
   сертификат хоста клиенту, который затем проверяет, что запись known_hosts
   “@@cert-authority” может расшифровать сертификат хоста, и затем соединение
   успешно принимается. Это помогает предотвратить путаницу в специально созданных
   системах, когда IP или имена хостов регулярно меняются.
@end display
Сценарий рабочего процесса: новому пользователю необходим доступ к системе. Пользователь
генерирует свой ключ, отправляет открытый ключ для подписи и, когда сертификат получен,
помещает его в свой каталог .ssh вместе с остальными файлами, связанными с ключом.
Хост-машины уже настроены на доверие к центру сертификации в файле sshd_config. Когда
пользователь подключается к ssh, клиент представляет подписанный сертификат целевому
компьютеру. Sshd целевой машины открывает запись TrustedUserCAKeys, чтобы открыть
соответствующий открытый ключ для декодирования сертификата. При удачном декодировании,
соединение определяется как доверенное, как если бы ключ был в authorized_keys для
этого пользователя. Это помогает снизить нагрузку на управление несколькими файлами
authorized_keys для каждого пользователя.

Конечно, в этом есть нечто большее, но мы рассмотрим более тонкие детали в течение
следующих разделов. В следующем разделе будет объяснение команд, необходимых для
настройки CA (включая списки отзыва и почему они важны).

@node Вступление использование СА SSH
@section Вступление использование СА SSH
@ifinfo
@heading Вступление использование СА SSH
@end ifinfo

Прежде чем мы перейдем к сути обсуждения, нам нужно установить некоторые
определения. На прошлой неделе мы упоминали, что центр сертификации может
создавать сертификаты как для хостов, так и для пользователей. Мы собираемся
охватить оба сегодня. Если кажется, что мы повторяемся, то на самом деле
это не так. Обратите внимание, в каком разделе вы находитесь, когда будете
следовать, так как флаги будут отличаться.
@display
    Определения:

    Certificate Authority (CA) – Доверенная третья сторона, которая подписывает
       ключи для производства сертификатов.
    User Key – Открытый ключ пользователя, который будет подписан CA для создания
       пользовательского сертификата.
    Host Key – Открытый ключ хоста, который будет подписан CA для создания
       сертификата хоста.
    User Certificate – Сертификат, сгенерированный CA из предоставленного ключа
       пользователя. Это уменьшает потребность в AuthorizedKeysFile или
       AuthorizedKeysCommand.
    Host Certificate – Сертификат, сгенерированный CA из предоставленного ключа
       хоста. Это упрощает управление known_hosts и делает этот процесс более
       безопасным.
    Principal – Средство ограничения действия сертификата определенным набором имен
       user/host. По умолчанию сгенерированные сертификаты действительны для всех
       пользователей или хостов.
    Trust – Для того чтобы выданный сертификат CA работал, серверу необходимо
       указать, чтобы он доверял CA, прежде чем он будет принимать пользовательские
       сертификаты, а клиенту нужно сказать, что он должен доверять CA, прежде
       чем он примет сертификаты хоста.
    Key Revocation List – Средство отзыва ключей и сертификатов, когда они больше
       не действительны.
    Validity Lifetime – Средство ограничения срока действия сертификата. Если
       сертификат становится недействительным после ограниченного периода времени,
       его необходимо будет повторно выдать с новым сроком действия. Это позволяет
       автоматически отзывать сертификаты в случае, если управление
       Key Revocation List упускает из виду предполагаемое удаление.
    Additional Limitations – Дополнительные ограничения могут быть применены к
       сертификатам в том же ключе, что и параметры префикса открытого ключа,
       описанные в предыдущем сообщении в блоге.
@end display
Первое, что нам нужно сделать после того, как вы настроете и защитите машину, на
которой будет установленн CA, - это добавить непривилегированного пользователя,
который будет использоваться для подписи ключей для выдачи сертификатов.
@example
sudo groupadd -g 3000 sshca
useradd -m -u 3000 -g sshca -G sshca -c "SSH Certificate Authority Signing User" \
-s /bin/bash -d /home/sshca sshca
@end example
Теперь нам нужно построить структуру каталогов.
@example
sudo -i -u sshca
mkdir -p @{hostca,userca@}
@end example
Далее нам нужно создать ключ, который будет использоваться для выдачи
сертификатов HOST.
@example
cd hostca
ssh-keygen -t rsa -b 4096 -f host_ca -C "Host Certificate Signing Key"
@end example
Нам также необходимо создать ключ, который будет использоваться для
выдачи сертификатов USER.
@example
cd ../userca
ssh-keygen -t rsa -b 4096 -f user_ca -C "User Certificate Signing Key"
@end example
На данный момент в каждом каталоге есть два файла. Файл закрытого ключа не
будет иметь расширения, а файл открытого ключа будет иметь расширение “.pub”.
Все сертификаты будут подписаны с использованием файла закрытого ключа, но
нам также нужен этот файл открытого ключа, поэтому не удаляйте его.

Чтобы создать TRUST, необходимый серверу для распознавания USER CERTIFICATES,
подписанного нашим CA, нам нужно отправить этот открытый ключ USER CA на каждый
хост и установить параметр конфигурации. Вы можете разместить его где угодно,
но я рекомендую создать подкаталог в каталоге /etc/ssh для хранения этих ключей.
@example
sudo mkdir -p /etc/ssh/sshca
@end example
Затем скопируйте файл pub из CA и вставьте его в этот каталог. Отредактируйте
файл /etc/ssh/sshd_config, чтобы включить эту директиву:
@example
TrustedUserCAKeys /etc/ssh/sshca/user_ca.pub
@end example
Перезапустите sshd (или заставьте его перезагрузить файл конфигурации), и это
доверие должно быть создано.

Чтобы воспользоваться этим доверием, для входа пользователя на сервер необходимо,
чтобы его открытый ключ был подписан USER CA. Это выдает сертификат, который
необходимо будет вернуть пользователю.

Синтаксис для подписи ключа выглядит следующим образом:
@example
ssh-keygen -s <ca_key> -I <certificate_identity> [-h] -n <principals> -O <options> \
-V <validity_interval> -z <serial_number> <public_key_to_be_signed>
@end example
@display 
“ca_key” - это закрытый ключ для USER CA при подписании открытых ключей пользователя
   или закрытый ключ для HOST CA при подписании открытых ключей хоста.

“certificate_identity” - это “key identifier”, который регистрируется сервером,
   когда сертификат используется для аутентификации. Рекомендуется использовать
   для этого уникальный идентификатор, который распознается вашей организацией,
   поскольку вы можете настроить доверие для нескольких CAs. Для нашего примера,
   certificate_identity будет “unixseclab”.
@end display
Если это подпись HOST KEY, убедитесь, что вы включили флаг “-h”.
@display
“principals” - это список пользователей, которые могут быть аутентифицированы с
   помощью этого USER CERTIFICATE. Кроме того, это список хостов, которые могут
   быть аутентифицированы с помощью этого HOST CERTIFICATE. Можно указать
   несколько принципалов, разделенных запятыми. Настоятельно рекомендуется
   установить в качестве субъекта имя пользователя или имя хоста сервера, для
   которого он выдан. Полная аутентификация может создать проблемы с
   криминалистикой.

“options” - это список ограничений, которые могут быть применены. Это как префиксы,
   которые мы упоминали ранее. Имейте в виду, что новейшие версии OpenSSH изменили
   одно поведение в отношении принудительных команд. Также обратите внимание, что
   “options” действительны только для USER CERTIFICATES. Вы должны были бы
   отключить “-O <options>” при выдаче HOST CERTIFICATES.
@end display
От неожиданностей:
@display
    Начиная с OpenSSH 7.4, когда принудительная команда появляется как в сертификате,
    так и в разрешении “command=” для авторизованных ключей/принципалов, sshd теперь
    откажется принимать сертификат, если они не идентичны. Предыдущее
    (задокументированное) поведение, связанное с принудительным изменением команды
    сертификата над другим, может быть немного запутанным и подверженным ошибкам.
@end display
@display
“validity_interval” используется для установки не только даты истечения срока действия
    выданного сертификата, но также для установки даты начала в случае, если он станет
    действительным только в будущем.

“serial_number” - это произвольное число, которое можно назначить, чтобы
    упростить KEY REVOCATION.
@end display
Выпускаемое HOST CERTIFICATE должно находиться в том же каталоге, что и HOST KEYS.
Файл sshd_config необходимо изменить, чтобы включить новый “HostCertificate” для
каждого нового выпущенного HOST CERTIFICATE. Ключ HOST также должен все еще
существовать и иметь собственную запись “HostKey” в файле sshd_config. Не удаляйте
их в обмен на записи сертификата.
@display
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
HostCertificate /etc/ssh//etc/ssh/ssh_host_ecdsa_key-cert.pub
@end display
Когда сервер настроен для предоставления HOST CERTIFICATE, клиентская сторона
также должна быть настроена для TRUST CA, который его подписал. Для этого нам
нужно добавить следующую запись в пользовательский файл “known_hosts”:
@example
@@cert-authority *.example.com <public key of the HOST CA that signed the host keys>
@end example
Может потребоваться удалить существующие записи ключей хоста в файле known_hosts
для этого хоста, если он был недавно перенесен для использования сертификатов.
Чистый способ справиться с этим - создать резервную копию ваших known_hosts,
обнулить файл и добавить только строки сертификата (вручную). Затем каждый раз,
когда вы сталкиваетесь с хостом без сертификата, вы можете сравнить предложенное
введите ваш заведомо исправный ключ в резервную копию и примите, если он подходит
для хостов, которые еще не используют сертификаты.

В следующем разделе мы рассмотрим Key Revocation Lists, проверку сертификатов и
запустим реальный пример генерации нашего исходного CA, подписи ключа хоста и
подписи ключа пользователя, а затем их использования, чтобы позволить клиенту
подключиться на сервер. 

@node SSH Продолжение - разработка CA пункт 2
@section SSH Продолжение - разработка CA пункт 2
@ifinfo
@heading SSH Продолжение - разработка CA пункт 2
@end ifinfo
SSH Продолжение - разработка CA пункт 2

На прошлой неделе мы рассмотрели большинство объяснений и команд для поддержки
SSH CA. На этой неделе мы рассмотрим Key Revocation List (KRL) и как проверить
сгенерированные сертификаты. Мы также включим демонстрацию asciinema процесса.
Давайте начнем.

Когда вы генерируете сертификат, один из флагов позволяет вам создать 'область' действия
сертификата. Это больше, чем срок действия, потому что он также включает в себя дату,
когда сертификат впервые становится действительным. Это отличный способ создания
определенных пользовательских сертификатов, поскольку вам может потребоваться
предоставить пользователю доступ только на четыре часа в выходные дни, и вы можете
выдать сертификат в течение рабочей недели, но он будет работать только тогда, когда
начальная дата/время достигнуто и перестает работать, когда достигнута дата/время
окончания.

Теперь давайте предположим, что вы выпускаете сертификаты на срок один год для
постоянных сотрудников. Сотруднику выдается свидетельство, которое вступает в силу
с первого февраля этого года, что означает, что его необходимо будет переиздать к
следующему февралю. Если сотрудник меняет рабочее место и больше не нуждается в
доступе к тем же наборам серверов, этот сертификат теперь является проблемой. У
них есть доступ к системам, которым они обладать  не должны, и необходимо отозвать
этот доступ. Для этого мы должны использовать Key Revocation List.

В нашем примере KRL создается USER CA и должен распространяться на каждый хост
при каждом обновлении. Это средство распространения очень похоже на управление
файлами authorized_keys, и означает, что оно может быть громоздким. Это, по
крайней мере, управление одним файлом, хотя это еще на один файл больше от
идеала.

Со страницы руководства sshd_config:
@display
    RevokedKeys
    Указывает отозванный файл открытых ключей или ни один, чтобы не использовать
    его. Ключи, перечисленные в этом файле, будут отклонены для аутентификации
    с открытым ключом. Обратите внимание, что если этот файл недоступен для чтения,
    аутентификация с открытым ключом будет отклонена для всех пользователей. Ключи
    могут быть указаны в виде текстового файла с указанием одного открытого ключа
    в строке или в виде OpenSSH Key Revocation List (KRL), сгенерированного
    ssh-keygen(1). Для получения дополнительной информации об KRLs см. Раздел
    KEY REVOCATION LISTS в ssh-keygen(1).
@end display
Хорошо.  Теперь, проверим справочную страницу ssh-keygen:
@display
    ssh-keygen умеет управлять OpenSSH format Key Revocation Lists (KRLs). В этих
       двоичных файлах указываются ключи или сертификаты, которые должны быть
       отозваны в компактном формате; для каждого сертификата требуется всего
       один бит, если они аннулируются по серийному номеру.

    serial: serial_number[–serial_number]
       Аннулирует сертификат с указанным серийным номером. Серийные числа являются
       64-битными значениями, не включая ноль, и могут быть выражены в десятичном,
       шестнадцатеричном или восьмеричном виде. Если заданы два серийных номера,
       разделенных дефисом, то анулируется весь диапазон серийных номеров, включая
       каждый из них. Ключ CA должен быть указан в командной строке ssh-keygen
       с использованием параметра -s.
@end display
Раньше мы говорили, что для KRL нужен серийный номер? Вот почему. Пользователь
генерирует свои ключи. Они посылают вам свой открытый ключ для подписи. Вы
подписываете ключ для генерации сертификата и отправляете ему сертификат. На этом
этапе нужно правильно удалить свою копию открытого ключа AND выданного сертификата.

Теперь когда у этого человек был взломана рабочая станция, ключу больше нельзя
доверять. Вы, естественно, не можете просто дождаться истечению срока действия
сертификата. У этого человека была привилегированная роль, и вы хотите, чтобы
SURE аутентификация была полностью отменена, но только для этого одного
сертификата, который был выпущен. Вам необходимо выполнить оператор KRL, но
у вас нет копии действующего сертификата или открытого ключа, который нужно
отозвать. В этом случае вам нужно отозвать по серийному номеру.

Предполагается, что серийный номер является уникальным, поэтому рекомендуется
создавать серийные номера по схеме. Вы могли бы рассмотреть что-то вроде
“a UID number + some base range” (номер UID + некоторый базовый диапазон).
Если UID пользователя равен 2352, и вы устанавливаете базовый диапазон из
четырех цифр, например, первый серийный номер будет 235320001. Этот номер будет
увеличиваться при каждой выдаче сертификата для этого пользователя. Либо
зарегистрируйте серийный номер в базе данных для каждого выданного сертификата,
чтобы его можно было быстро найти. Это, работает лучше всего.

Когда приходит время отозвать все сертификаты, которыми может обладать
пользователь (в случае нескольких действительных сертификатов), вы также
можете отозвать их с помощью ID.

Помните, что при создании сертификата флаг “-z” предназначен для установки
серийного номера, а флаг “-I” - для идентификатора. При отзыве сертификата
вы будете использовать флаг “-k”, как показано ниже:
@example
ssh-keygen -s <ca_key> -I <certificate_identity> -u -k
ssh-keygen -s <ca_key> -z <serial_number> -u -k
@end example
Причина, по которой мы указываем флаг “-u”, заключается в том, что он заставит
обновить KRL, а не заменить его новым. Это означает, что мы случайно не удалим
другие аннулирования, которые все еще должны присутствовать.

Каковы некоторые проблемы с этим решением?

Если мы укажем серверу использовать KRL, файл должен существовать, иначе sshd
не запустится. Это означает, что там должен быть пустой файл, если сервер настроен
для указания на файл KRL, и нет пока ключей для фактического отзыва. Если системный
администратор, незнакомый с этим, удаляет файл, потому что он пуст, при попытке
очистить файлы нулевой длины в системе, sshd при следующем перезапуске не запустится.

KRL должен управляться для каждого конечного сервера. Это очень похоже на проблему
обработки отдельных файлов author_keys для каждого сервера. Причина, по которой я
специально упомянул проблему с серийным номером, состоит в том, чтобы точно
определить сценарий, в котором мы не отменяем доступ для определенного пользователя,
поскольку его больше нет, но отозвали сертификат ONE для этого пользователя из-за
нарушения.

Есть несколько способов справиться с ситуацией KRL. Вы можете создать скрипт, который
извлекает KRL с одного сайта и вставляет его в задание cron. Вы можете использовать
процесс rsync, чтобы выдавать его нескольким конечным точкам каждый раз, когда файл
обновляется. Ни один из них не идеален, но я рекомендую NOT сделать что-то, что
кажется легким, но может вызвать кошмары в крошечные часы утра в один из выходных
для какого-нибудь неудачного инженера по вызову. Обязательно укажите конфигурацию
на общий сетевой ресурс с поддержкой сети. Если бы общий ресурс выпадал, файл больше
не был бы там в глазах sshd, и, если никто не заметил, при следующем перезапуске
службы (скажем, поздним ночным автоматическим обновлением ОС) sshd отказался бы
запускаться. Вы можете рассмотреть возможность использования общего сетевого ресурса,
но используйте сценарий, который регулярно проверяет наличие файла для обновления,
прежде чем копировать его на место локально. Что бы вы ни выбрали, решение не будет
красивым.

Еще одна заметка об KRLs. Вы можете проверить наличие сертификата или ключа в
списке отзыва с флагом “-Q” для ssh-keygen.
@example
ssh-keygen -Q -f <KRL_file> <key_or_certificate_file>
@end example
Пришло время для перехода к проверке сертификатов. Для проверки сертификата
используйте флаг ssh-keygen “-L”.
@example
ssh-keygen -L -f <key_or_certificate_file>
@end example
Вот как выглядит пример файла:
@display
$ ssh-keygen -Lf ./.ssh/id_rsa-cert.pub
./.ssh/id_rsa-cert.pub:
Type: ssh-rsa-cert-v01@@openssh.com user certificate
Public key: RSA-CERT 04:29:a8:fd:55:04:db:8f:1e:0d:45:18:a7:8e:a7:a6
Signing CA: RSA 27:cc:19:a3:67:1b:5e:2e:6a:48:a9:25:25:6d:64:6c
Key ID: "root"
Serial: 1234
Valid: forever
Principals:
root
Critical Options: (none)
Extensions:
permit-X11-forwarding
permit-agent-forwarding
permit-port-forwarding
permit-pty
permit-user-rc
@end display
@node Генерация списка отзыва ключей (KRL)
@section Генерация списка отзыва ключей (KRL)
@ifinfo
@heading Генерация списка отзыва ключей (KRL)
@end ifinfo

KRL - это компактный двоичный формат, который позволяет отзывать подписанные
          сертификаты SSH.

    Создать пустой список отзыва:
@example
❯ touch /etc/ssh/revoked_keys
@end example
    Обновите /etc/ssh/sshd_config, чтобы включить новый список отзыва ключей:
@example
❯ RevokedKeys /etc/ssh/revoked_keys
@end example
    При необходимости отозвать первый подписанный сертификат:
@example
❯ ssh-keygen -k -f revoked_keys -s sshuser.root.ca.pub foo-cert.pub
@end example
    При необходимости добавьте больше отозванных сертификатов (используя -u):
@example
❯ ssh-keygen -k -f revoked_keys -s sshuser.root.ca.pub -u bar-cert.pub
@end example
    Проверка, что отзыв сработал:
@example
❯ ssh-keygen -Qf revoked_keys foo-cert.pub
@end example
    Распространите обновленный revoked_keys на каждый хост (/etc/ssh/revoked_keys)
          с помощью rsync, scp  или другой утилиты.

ПРИМЕЧАНИЕ: ssh-keygen не должен требовать подписанный публичный сертификат для
его отзыва. Вместо этого следует использовать только серийный номер. Тем не менее,
в настоящее время это не работает на OpenSSH 7.2p2 (Ubuntu).

@node Аутентификация SSH через пользовательские сертификаты (сервер)
@section Аутентификация SSH через пользовательские сертификаты (сервер)
@ifinfo
@heading Аутентификация SSH через пользовательские сертификаты (сервер)
@end ifinfo

Сложным аспектом безопасности является надежность и гарантия согласованности всех
мер безопасности. Вместо того чтобы полагаться на центральный орган аутентификации,
такой как LDAP или Kerberos, мы можем использовать преимущества SSH или, в частности,
OpenSSH, для обеспечения обоих составляющих.

В дополнение к аутентификации доступа клиента SSH с помощью PIV и PKCS # 11, можно
повысить безопасность удаленной аутентификации SSH. Facebook и Yahoo перешли на
SSH User Certificates, чтобы избежать блокировки, если центральная система
аутентификации выходит из строя. Это также помогает поддерживать файл author_keys,
так как это плохо масштабируется (требуется соответствие 1:1).

Центр сертификации пользователей SSH может подписывать и, таким образом, безопасно
проверять подлинность каждого клиента, подключающегося к серверу.

Подписанный сертификат также обозначает участников (учетные данные), которые можно
использовать с этим сертификатом. Для каждого пользователя принципы могут быть
описаны в файле:
@display
❯ mkdir /etc/ssh/auth_principals
❯ echo -e 'access-root' > /etc/ssh/auth_principals/root
❯ echo -e 'access-databases' > /etc/ssh/auth_principals/foobar
@end display
В этом примере любой подписанный сертификат с принципалом 'access-root' будет разрешен
SSH вход на этот хост под именем корневого пользователя, и любой подписанный сертификат
с субъектом 'access-databases'сможет войти в систему под именем пользователя foobar.

Теперь давайте создадим центр сертификации пользователей SSH.

    Используя компьютер ,без доступа к сети, создайте центр сертификации пользователя:
@example
❯ ssh-keygen -C "SSH User Certificate Authority" -f sshuser.root.ca
@end example
    Распространите открытый ключ (sshuser.root.ca.pub) на /etc/ssh/ на каждом хосте.
    Убедитесь, что файл chmod 644.

    Обновите /etc/ssh/sshd_config, чтобы включить новый файл CA и принципалов:
@example
TrustedUserCAKeys /etc/ssh/sshuser.root.ca.pub
AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u
@end example
    Попросите пользователя/клиента извлечь открытый ключ из своего Yubikey, чтобы он мог
    быть подписан новым ЦС на компьютере отключенном от сети:
@example
ssh-keygen -D /usr/local/opt/opensc/lib/pkcs11/opensc-pkcs11.so -e
@end example
    Подпишите сертификат пользователя на отключеном от сети компьютере, уделяя особое
    внимание имени пользователя (<user>), принципалам, на которые этот сертификат сможет
    претендовать (<principals>,, разделенных запятыми), сроку действия сертификата
    (+52w) и серийному номеру (<serial>,, целому числу, которое следует отслеживать):
@example
❯ ssh-keygen -s sshuser.root.ca -I <user> -n <principals> -V +52w -z <serial> <user>.pub
@end example
Подписанный ключ пользователя foobar-cert.pub: id "foobar" serial 1928121 для access-root
действует с 2016-12-10T00:10:00 по 2017-12-09T00:10:10

    Проверим, что сертификат пользователя выглядит хорошо:
@display
❯ ssh-keygen -Lf <user>-cert.pub

user-cert.pub:
    Type: ssh-rsa-cert-v01@@openssh.com user certificate
    Public key: RSA-CERT SHA256:NWmw3siRlxn3bsIhzaFrCsh66KKIWapFuZsNiDXhRLw
    Signing CA: RSA SHA256:HLD1Eb4XiCoyXew23skyisJt+3P02MOsrHHbK/DmlgY
    Key ID: "foobar"
    Serial: 1928121
    Valid: from 2016-12-10T00:10:00 to 2017-12-09T00:10:10
    Principals:
            access-root
    Critical Options: (none)
    Extensions:
            permit-X11-forwarding
            permit-agent-forwarding
            permit-port-forwarding
            permit-pty
            permit-user-rc

    Скопируйте <user>-cert.pub в каталог клиента ~/.ssh и назовите его
    id_rsa-cert.pub. Название довольно специфично, так как кажется, что
    opensc-pkcs11 имеет ограничение для обнаружения сертификата,
    отличного от id_rsa-cert.pub.
@end display
@c****************************************
@node AuthorizedKeysCommand
@section AuthorizedKeysCommand
@ifinfo
@heading AuthorizedKeysCommand
@end ifinfo

Раннее мы кратко остановились на этом, но в этом разработан сценарий
для углубления в детали.
@display
Итак, чтобы установить это, в настоящее время задействованы три системы.
1) Ноутбук Windows 10 с опцией “ubuntu on windows 10 on crack”. Используя оболочку
   bash, я создал пару ключей ssh ​​и остановился там, пока все остальное не было готово.
2) Система “target” для входа в систему. Это сервер OpenBSD, на котором я поиграл с
   asciinema ранее в эти выходные и решил использовать его для этой конкретной лаборатории.
   Это машина, которая будет настроена на использование AuthorizedKeysCommand и
   AuthorizedKeysCommandUser вместо AuthorizedKeysFile. На этом сервере я создал две
   новые группы и двух новых пользователей:
@end display
@display
groupadd testgrp
groupadd sshpub
useradd -m -g testgrp -G testgrp -c “Test User” -s /bin/ksh -d /home/testuser testuser
useradd -m -g sshpub -G sshpub -c “SSH Public Key Provider” \
-s /bin/ksh -d /home/sshpub sshpub

Я также создал новый скрипт: /usr/local/bin/query_ssh_pub.ksh с разрешениями 750 и
принадлежащий root:sshpub.
##############################################################################
#!/bin/ksh

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
HOSTNAME=$(hostname -s)
USER=$@{1@}
ssh -i ~sshpub/.ssh/id_rsa sshpub@@192.168.0.89 “/usr/local/bin/query_ssh_pub_keys.ksh \
$@{USER@} $@{HOSTNAME@}”
##############################################################################

3) Система “query server” будет центральным хранилищем ключей ssh ​​для системных
учетных записей и/или пользователей (гипотетически). Я создал того же пользователя
и группу sshpub в этой системе, но добавил новый скрипт:
/usr/local/bin/query_ssh_pub_keys.ksh с разрешениями 750 и также принадлежащий
root:sshpub.
##############################################################################
#!/bin/ksh
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

if [ $# -ne 2 ]; then
exit 255
fi

USER=$@{1@}
TARGET=$@{2@}

echo $@{USER@} | grep -q -E -e ‘^[a-zA-Z0-9]+$’ || exit 255
echo $@{TARGET@} | grep -q -E -e ‘^[a-zA-Z0-9]+$’ || exit 255

ls /home/sshpub/key-store/ | grep -q “^$@{TARGET@}\.$@{USER@}\.pub\$” || exit 255
cat /home/sshpub/key-store/$@{TARGET@}.$@{USER@}.pub
##############################################################################
@end display
Я сгенерировал пару ключей ssh ​​из sshpub на сервере “TARGET”, а затем скопировал
файл открытого ключа на сервер “QUERY”, чтобы он мог выполнять удаленный вызов ssh. Если
бы я собирался использовать систему, подобную этой, в производстве, я бы применил еще
несколько проверок работоспособности ко всем входам, а также рассмотрел бы принудительную
команду для этого пользователя либо с помощью sshd_config, либо путем изменения файла
открытого ключа, но это ни тут ни там не используется. Это не идеальный способ получения
ключей, но он демонстрирует, как это работает простым способом.

Когда все было готово, я поместил копию открытого ключа с ноутбука “CLIENT” в файл
/home/sshpub/key-store/asciicast.testuser.pub на сервере “QUERY”, а затем проверил, что
все команды работают должным образом.

Наконец, я обновил sshd_config, чтобы использовать следующие записи на сервере “TARGET”,
и перезапустил sshd:
@display
AuthorizedKeysCommand /usr/local/bin/query_ssh_pub.ksh
AuthorizedKeysCommandUser sshpub
@end display
После того, как все это было сделано, я смог проверить, могу ли я войти в систему как
“testuser” на машину “TARGET”, и он успешно получил открытый ключ с машины “QUERY”,
разрешив вход в систему, как и ожидалось.

Сценарий запроса может вызвать любую службу, правда. Вы можете вызывать ключи,
хранящиеся в LDAP, SQL или любой другой базе данных. Окончательный результат,
возвращаемый скриптом, должен содержать ноль или более открытых ключей, и ничего
более. Чаще всего это делается для запроса к LDAP, и есть примеры файла LDIF для
OpenLDAP, свободно распространяющегося в Интернете, если вы решите пойти по этому пути.
Просто убедитесь, что ваш LDIF работает для вашей конкретной службы LDAP, и что вы
можете санировать вывод, чтобы только представить ключи в конце, когда вы запрашиваете.

@node Работа с распределением ключей
@section Работа с распределением ключей
@ifinfo
@heading Работа с распределением ключей
@end ifinfo

Это будет краткий пост с не таким большим содержанием, но он объяснит,
куда мы идем отсюда.

Одним из самых больших преимуществ SSH является дополнительный уровень шифрования,
который он обеспечивает. Вторым важным преимуществом является отсутствие необходимости
в пароле. Пароли могут быть заменены парольными фразами, что помогает сделать его еще
более безопасным. Однако существует риск, связанный с типом файлов vanilla
authorized_keys.

Открытые ключи должны быть управляемыми. Что это значит? Открытый ключ должен быть
предоставлен соответствующим файлам authorized_keys вручную для каждого пользователя,
который использует преимущества этой системы. Когда пользователю требуется отозвать
доступ, файлы authorized_keys также должны быть проанализированы, чтобы убедиться,
в отсутствии записи ключа, к которому у этого пользователя больше нет доступа. Когда
вы удаляете пользователя из рабочей среды, его собственные файлы учетной записи
пользователя authorized_keys удаляются вместе с домашним каталогом, если вы используете
стандартную команду “userdel -r ”. Однако, если у них есть ключи для доступа к общей
учетной записи службы, такой как www, apache или аналогичная, необходимо выполнить
дополнительные шаги для проверки каждой системы, где может существовать этот ключ.

Это может быть выполнено с помощью чего-то вроде puppet, chef или одного из других
распространенных инструментов управления типами обеспечения и конфигурации, или это
может быть сделано с помощью чего-то такого же простого, как распределенная проверка
ssh (dsh), но наличие нескольких файлов является кошмаром обеспечения , Предположим,
что система отключена, когда пользователь отключен. Без решения по управлению
конфигурацией/управлению доступом к учетным записям ваши ручные проверки могут
пропустить единственный ключ, всплывающий в файле author_keys.

Так как мы справимся с этим? Есть несколько способов, и они не все включают инструменты
управления конфигурацией. Один из способов справиться с этим - использовать опцию
“AuthorizedKeysCommand” в sshd_config. Для его использования требуется второй параметр
(“AuthorizedKeysCommandUser”). Они позволяют вам установить скрипт, вызываемый
(мы надеемся) непривилегированным пользователем, который может запросить некоторую
службу для получения ключа для данного пользователя. Это может быть LDAP, SQL, плоский
файл на удаленной машине ... все, что возвращает ожидаемые результаты. Мы рассмотрим
это более подробно в следующем разделе.

Другой вариант - настроить Certificate Authority для OpenSSH и подписать открытые
ключи вашего пользователя. Для обеспечения, это не требует инструмента управления
конфигурацией/управления доступом, но для отмены подготовки, это может произойти.
Тем не менее, вы можете автоматизировать это удаление по расписанию, чтобы избежать
решения CF/IAM, и мы рассмотрим такие настройки, когда перейдем к обзору
Certificate Authority через несколько разделов.

В идеале вы могли бы рассмотреть возможность объединения этих методов в конце,
но мы сначала представим их как отдельные принципы и методы управления ключами.


@node Работа с запаздывающими сетями
@section Работа с запаздывающими сетями
@ifinfo
@heading Работа с запаздывающими сетями
@end ifinfo

Один из аспектов серверов и клиентов, которые общаются друг с другом по сети, которая
иногда требует обработки, - как сохранить соединение открытым. Иногда сеть ненадежна
из-за отсутствия лучшего термина, и это означает, что пакеты могут быть отброшены.
OpenSSH не является исключением, и у него есть несколько опций, которые можно установить
в файлах sshd_config, ssh_config, и локальных ~/.ssh/config, чтобы помочь определить,
как обрабатывать такие случаи.

И сервер, и клиент совместно используют опцию “TCPKeepAlive”. Этот параметр определяет,
следует ли отправлять сообщения поддержки активности TCP. Это помогает завершить
соединение в случае сбоя клиента или сервера, но может быть проблематичным в сети,
которая имеет значительную задержку. Однако, если он не установлен, это может означать,
что в пуле подключений к серверу может быть много пользователей-призраков, поэтому
рекомендуется включить его, если сеть не очень плохая. Возможные варианты: “yes” или
“no”, в зависимости от того, включен он или нет.

Есть также “ClientAliveCountMax” (sshd_config) и “ServerAliveCountMax”
(ssh_config and ~/.ssh/config). Они устанавливают количество живых сообщений,
которые могут быть отправлены без получения клиентом или сервером ответа от
кореспондента. Эти сообщения отличаются от сообщений TCPKeepAlive. Живые сообщения
отправляются через зашифрованный канал и, следовательно, не могут быть подделаны. С
другой стороны, сообщения поддержки активности TCP могут быть подделаны, так что это
может быть лучшим вариантом в более (потенциально) враждебной среде. Этот параметр
является числом, и по умолчанию используется значение “3”. Помните, что это COUNT,
который считает количество раз, когда сообщение будет отправлено до завершения
сеанса из-за отсутствия ответа на другом конце.

Другая переменная, необходимая для работы вышеупомянутого, - это
@display
“ClientAliveInterval” (sshd_config) и
“ServerAliveInterval” (ssh_config and ~/.ssh/config)
@end display
Они определяют количество
секунд между отправляемыми сообщениями. По умолчанию используется “0”, что означает,
что ничего не отправлено, поэтому вы должны задать для этого значение больше 0,
чтобы включить эту опцию. Если для этого значения установлено значение “5” на
обоих концах, а для максимального числа активных пользователей по умолчанию
установлено значение “3,”, то соединение будет прервано через 15 секунд, если
сообщения не получат ответ.

Помимо параметров TCPKeepAlive и *AliveCountMax и *AliveInterval, есть также
параметр, определяющий, как долго ждать успешного входа пользователя. Чтобы люди
не могли выполнить первоначальное рукопожатие по ssh-запросу, но не входить и не
связывать сокет. , это может быть установлено, и этот пользователь будет удален
через указанное количество времени. Значение по умолчанию составляет 120 секунд,
но если вам это вообще не нужно, вы можете изменить его на 0, чтобы отключить его,
как и параметры *AliveInterval.

@node X11 Forwarding
@section X11 Forwarding
@ifinfo
@heading X11 Forwarding
@end ifinfo

X11 - это протокол client/server, который означает, что вы можете запускать программное
обеспечение на одном компьютере и отображать его графический вывод на другом. Он также
имеет некоторые риски для безопасности, поэтому распространенным способом снижения
некоторых из этих рисков является предоставление SSH возможности пересылать клиентское
соединение X11 на локальный сервер X11 при запуске клиента в удаленной системе.

Для некоторых это кажется обратным, но вы запускаете сервер на своей рабочей станции
и запускаете удаленную графическую команду как клиент, который обращается к вашему
серверу. Сервер генерирует графику от имени клиента. Если вы работаете на рабочей
станции с Linux, производной BSD или чем-то вроде одной из вилок OpenSolaris, вы,
вероятно, уже используете X11 для своих настольных ПК. Мы сделаем предположение,
что вы используете этот процесс.

Чтобы выполнить пересылку X11, необходимо настроить удаленный сервер, чтобы разрешить
такую ​​пересылку. Имеют значение следующие параметры: “X11Forwarding yes” для включения
пересылки, “X11DisplayOffset 10” (default) для определения смещения для дисплея, который
будет использоваться, “X11UseLocalhost loopback” (default) для указания sshd связать
сервер пересылки с устройством обратной связи и
“XAuthLocation /usr/X11R6/bin/xauth” (default), если необходимо указать путь к
программе xauth, потому что она не находится по умолчанию в вашей системе.

Может случиться так, что единственной настройкой, которую вам нужно настроить,
является “X11Forwarding” от “no” до “yes” в вашей целевой системе.

После этого вы можете подключиться к целевой системе, передав флаги -X или -Y
клиенту ssh. Флаг -X применяет параметры ForwardX11Trusted для клиента ssh, которые
устанавливают более строгие ограничения на использование пересылки X11, а также
устанавливает 20-минутный таймер истечения срока действия для токена xauth. Флаг -Y
не устанавливает эти ограничения. Вам решать, какой флаг вы хотите использовать.

После подключения вы можете проверить, правильно ли настроена ваша среда. У вас должен
быть файл “.Xauthority” в вашем домашнем каталоге, и у вас должна быть уже установлена 
переменная окружения под названием $@{DISPLAY@}, которая, вероятно, должна отображать
“localhost:10.0”, когда вы выводите его.
@display
ls -ld .Xauthority
echo $@{DISPLAY@}
@end display
После того как вы подтвердите это, вы можете проверить свою переадресацию с помощью
чего-то простого, например, xeyes или xclock, если они установлены на целевой машине.
Если нет, попробуйте любую программу X11, которую вы намеревались запустить. Вы должны
увидеть, как программа появится на вашем рабочем столе, как только вы это сделаете.

Наконец, если вам нужно запустить программу X11 от имени другого пользователя, вы
можете использовать команду xauth, чтобы объединить ваши токены .Xauthority с
окружением другого пользователя, а затем переключиться на этого пользователя для
запуска вашей команды. Вам нужно будет извлечь токен xauth для вашего DISPLAY и
объединить его для среды другого пользователя. Стандартный способ сделать это с
помощью “xauth extract”, переданного по каналу «xauth merge», как показано в полном
примере сеанса ниже.
@display
ssh -Y User_A@@Server_B
ls -ld .Xauthority
echo $@{DISPLAY@}
xclock
xauth extract – $@{DISPLAY@} | sudo -i -u User_B xauth merge –
#OR xauth extract – $@{DISPLAY@} | sudo su – User_B xauth merge –
sudo -i -u User_B #(или sudo su – User_B)
echo $@{DISPLAY@} #(Может потребоваться вручную установить это на то, что вы дали при входе в систему)
xclock
@end display
Конфигурация клиента имеет несколько настроек, чтобы всегда или никогда не устанавливать
это для вас. Вероятно, они должны быть установлены в блоках Match только для серверов,
на которых вам нужно регулярно запускать программы X, и не устанавливаться вообще.
@display
ForwardX11 yes/no
ForwardX11Trusted yes/no
ForwardX11Timeout
XAuthLocation #как sshd_config
@end display
Формат времени будет числом, за которым следует блок модификатора. “S” или “s” для секунд.
“M” или “m” для минут и так далее вплоть до недель. По умолчанию если не указана ни одна
единица подразумевает секунды.

Вы можете использовать команды xauth, чтобы удалить свои токены вручную, когда вы
закончите, выполнив “xauth remove $@{DISPLAY@}”, если пожелаете.

Надеюсь, это помогло пролить некоторый свет на то, как заставить X11 Forwarding работать
от простого к сложному сценарию. Это один из наиболее часто задаваемых вопросов, которые
у меня были в прошлом, и я сожалею, что он не был рассмотрен раньше.

@node Принудительные команды
@section Принудительные команды
@ifinfo
@heading Принудительные команды
@end ifinfo

В прошлых разделах мы рассмотрели параметры ключа SSH, которые могут ограничивать
использование закрытого ключа для подключения к серверу. Одной из этих опций была
опция “command=”, которая позволяет ограничить ключ вызовом только одной команды,
независимо от команды, выданной как часть попытки соединения ssh. Есть несколько
способов обеспечить это.

Вы можете использовать опцию открытого ключа “command=”, которую мы уже рассмотрели.
Вы также можете использовать настройки sshd_config для применения опции ForceCommand.
Это наиболее полезно для применения того же сценария принудительной команды, который мы
описали в прошлом разделе с помощью директивы “Match User”. Это также полезно для
применения ситуации только с sftp к данному пользователю, так что единственное, что может
сделать пользователь, - это передать файлы. Опция будет выглядеть так, если это ваша цель:
@display
ForceCommand internal-sftp
@end display
Оболочка пользователя должна быть действительной, чтобы это работало, поскольку
принудительная команда вызывается через “ -c”. Это означает, что оболочка
/bin/false или /bin/nologin не нужна. Поскольку вы заставляете команду, это
должно быть меньшей проблемой.

Наконец, есть также способ заставить эту команду с помощью параметров ssh-keygen при
подписании ключа через систему центра сертификации для OpenSSH, но мы более подробно
расскажем об этом, когда перейдем к материалу CA.

Параметры принудительной команды не позволяют запускать пользовательский ~/.ssh/rc, так
что это не будет обходной путь, который пользователь может использовать для взлома этой
системы. ControlMaster переопределяет команду принудительного использования открытого
ключа, если опция установлена ​​после того, как основной сеанс уже установлен, поэтому вам
может потребоваться прервать все соединения ssh для этого пользователя после внесения
изменений, которые вводят ограничения, и двигаться вперед.

Многие люди ворчат о параметрах принудительных команд, потому что считают, что для
каждой передаваемой команды необходим один ключ, но на самом деле есть средства для
обработки этого. Существует переменная окружения, которая устанавливается, когда сеанс
ssh, который хочет вызвать удаленную команду, используется для подключения, пока для
пользователя используется принудительная команда. Эта переменная окружения -
SSH_ORIGINAL_COMMAND, и она сохраняет запрошенную команду. Это означает, что у вас
может быть скрипт-обертка, который является вашей принудительной командой, он должен
проверить эту переменную среды на предмет работоспособности (все ли команды в списке
представлены в нашем белом списке или нет? Если нет, запишите отклонение и прекратите
работу. Если так , зарегистрируйте вызов и выполните.) Переменная сбрасывается, если
пользователь просто пытается войти в ssh, не вызывая удаленную команду, поэтому
обязательно проверьте это, если вы идете по этому пути. Предположим, что переменная
unset/empty (не установлена ​​/ пуста), что они пытались войти в систему для интерактивного
сеанса, и обработать, как вы считаете, лучше. Я бы предположил, что
“log a rejection and terminate” (зарегистрируйте отклонение и завершение) лучше,
хотя, поскольку интерактивный сеанс не может быть должным образом ограничен без
ограниченной оболочки, который все равно может быть поврежден из-за джейла в случае
неправильной настройки. Ваши собственные потребности могут отличаться. Просто будьте
очень тщательны в своем дизайне и убедитесь, что все входные данные очищены перед
выполнением, и все будет в порядке.

@node параметры открытого ключа
@section параметры открытого ключа
@ifinfo
@heading параметры открытого ключа
@end ifinfo

Поскольку мы представили несколько способов туннелирования, я подумал, что сейчас
самое время рассказать о некоторых способах ограничения действий пользователя в случае,
если у него есть доступ к закрытому ключу, которого быть не должно.

Мы уже говорили об установке парольной фразы на стороне закрытого ключа, но все еще
существует вероятность того, что пользователь смог это сделать грубо, поэтому предположим,
что у него есть доступ к этому секретному ключу. Какие у нас есть варианты для обеспечения
безопасности?

Для начала, мы можем ограничить, из каких исходных имен IP/DNS может прийти пользователь,
используя этот ключ. Если мы изменим запись открытого ключа в файле author_keys для
включения директивы “from” до запуска ключа, мы можем предоставить список
IP addresses/hostnames, от которого мы ожидаем. Это предотвращает атаку с рабочей
станции пользователя, например. Одним из предостережений этого является то, что вы не
можете использовать источник NAT, так как это снизит эффективность этого ограничения.
Каждый, кто входит в коробку из источника NAT VLAN или подсети, выглядит так, как будто
он пришел из одного места.

Чтобы установить эту директиву, нам нужно изменить открытый ключ вручную. Лучше
изменить открытый ключ перед добавлением его в файл authorized_keys, но вы можете
изменить запись файла authorized_keys для этого ключа, если хотите.

Чтобы использовать эту директиву, нам нужно поставить опцию “from” со всеми ее значениями,
разделенными запятыми, BEFORE - ключ запускается. Вот пример того, как это может выглядеть:
@display
   from=”172.16.84.1,lanturtle,lanturtle.mydomain” ssh-rsa AAAA User_A@@lanturtle
@end display
Теперь предположим, что вы также хотите запретить проксирование с помощью этого ключа.
Чтобы ограничить это, нам нужно установить несколько параметров:
@display
no-X11-forwarding – Предотвращает пересылку сеансов X11 обратно на X-сервер через
   туннель SSH.
no-port-forwarding – Предотвращает переадресацию портов через устройства TCP, TUN и
   прямое проксирование через stdin.
no-agent-forwarding – Предотвращает “forwarding” ssh-агента для обработки закрытого ключа.
@end display
Чтобы добавить их в приведенный выше пример, мы будем использовать список параметров,
разделенных запятыми:
@display
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding, \
    no-port-forwarding,no-agent-forwarding ssh-rsa AAAA User_A@@lanturtle
@end display
Мы можем дополнительно ограничить это только разрешением использования этого конкретного
ключа для выполнения определенной команды. Это игнорирует любые команды, переданные
пользователем при подключении, и не дает пользователю получить полную оболочку входа
(если это не принудительная команда).
@display
command=”/usr/local/bin/ssh-restricted-command.sh” (где
   “/usr/local/bin/ssh-restricted-command.sh” это команда, которую вы хотите запустить.
   Введите фактическую команду, которую вы хотите использовать, здесь.)
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding,no-port-forwarding, \
   no-agent-forwarding,command=”/usr/local/bin/ssh-restricted-command.sh” ssh-rsa  \
   AAAA User_A@@lanturtle
@end display
Наконец, если мы хотим быть уверены, что в файле .ssh/rc пользователя нет наземной
мины, мы можем запретить ее чтение, используя следующую опцию:
@display
no-user-rc
from=”172.16.84.1,lanturtle,lanturtle.mydomain”,no-X11-forwarding,no-port-forwarding, \
   no-agent-forwarding,no-user-rc,command=”/usr/local/bin/ssh-restricted-command.sh” \
   ssh-rsa AAAA User_A@@lanturtle
@end display
Когда мы перейдем к управлению центром сертификации, вы обнаружите, что ssh-keygen может
установить эти параметры для ключей, связанных с сертификатами, но имена параметров
немного отличаются. К сожалению, использование ssh-keygen для генерации начального
открытого/закрытого ключа с этими параметрами не работает. Работает только на
сертификатах. Однако изменение записи открытого ключа вручную ограничивает это.

@node туннелирование IP с устройством TUN
@section туннелирование IP с устройством TUN
@ifinfo
@heading туннелирование IP с устройством TUN
@end ifinfo

Мы рассмотрели различные  tunneling/proxy  (туннелирование/прокси) возможности OpenSSH
для туннелирования TCP и настройки прокси портов, но флаг “-w” может позволить вам
пересылать IP-трафик. Это происходит путем создания временного устройства “tun” при
подключении по SSH, которое можно настроить как любой сетевой интерфейс с помощью
стандартных инструментов, таких как “ifconfig”. Должно произойти некоторое последующее
установление соединения, включая изменение информации таблицы маршрутов, поэтому
относитесь к этому как к нормальному и правильному решению VPN. Вот что это значит.
Решение VPN, встроенное в клиентское и серверное программное обеспечение SSH. Я сделаю
правильную запись с лабораторией и примерами позже. А пока знайте, что на сервере
должна быть установлена ​​опция “PermitTunnel”, и для нее должно быть установлено
значение, отличное от “no”, которое является значением по умолчанию.
@display
Варианты:
point-to-point – Это позволяет настраивать туннельное устройство уровня 3.
ethernet – Это позволяет настроить туннельное устройство уровня 2.
yes – Это позволяет настроить любой тип устройства.
@end display
При подключении к серверу необходимо передать флаг “-w” и указать идентификатор
устройства tun. Вы также можете указать идентификатор устройства удаленной настройки.
Если вы не предоставляете удаленный идентификатор, по умолчанию используется “any”,
который предоставляет следующий доступный. Вы также можете указать “any” для
идентификатора локального устройства настройки.

В следующем примере настраивается определенный “tun0” как на локальной, так и на
удаленной стороне.
@display
ssh -w 0:0 User_B@@Server_B
@end display
Далее будет настроено устройство “tun” с использованием следующего доступного ID как
на локальной, так и на удаленной сторонах.
@display
ssh -w any:any User_B@@Server_B
@end display
Следующие действия сделают то же, что и в примере выше, но сохранят значение,
необходимое для ввода 4 символов.
@display
ssh -w any User_B@@Server_B
@end display
Просто настроить их будет недостаточно. Разумеется, вам также потребуется настроить
информацию routes/interface (маршруты/интерфейс). Вам также нужно будет настроить
все правила трафика для бастионного хоста (локального брандмауэра), если вы его
используете. Лучшее объяснение этому я нашел здесь:
Daemon Forums

@node TCP Forwarding of STDIN/STDOUT
@section TCP Forwarding of STDIN/STDOUT
@ifinfo
@heading TCP Forwarding of STDIN/STDOUT
@end ifinfo

В предыдущем разделе мы рассмотрели стандартные флаги перенаправления TCP: -L, -R, и -D.

Я явно воздержался от показа -W и -w, потому что чувствовал, что они заслуживают
отдельного освещения.

Мы рассмотрим -w (работа с туннельными устройствами) в следующем разделе. Сейчас все о -W.
Прежде чем мы продолжим, вы должны заметить, что одна из моих публикаций в среду была
кратким обзором семейства инструментов netcat. Если вы думаете о “-W :” как о встроенном
netcat для ssh, вы довольно быстро поймете силу этого флага. Наиболее распространенный
пример использования этого флага - использование опции ProxyCommand для вызова SSH с
использованием Jumphost и передачи этого флага этому хосту. Старый способ использования
ProxyCommand таким способом заключался в том, чтобы фактически вызывать netcat в качестве
команды удаленного прокси-сервера, например так:
@display
ssh -o ProxyCommand=’ssh jumphost netcat target_server 22′ target_server
@end display
Или, если “Server_B” является нашим прыжковым хостом, и мы действительно хотим
использовать “Server_A”, используя “Server_B” в качестве прокси, мы сделаем это
следующим образом:
@display
ssh -o ProxyCommand=’ssh Server_B netcat Server_A 22′ Server_A
@end display
Это было все хорошо, если netcat был фактически установлен, но иногда это не так. К
счастью, SSH имеет свой собственный встроенный тип netcat через флаг -W. Чтобы сделать
то же самое, что и выше, мы бы сделали это вместо этого:
ssh -o ProxyCommand=”ssh -W %h:%p Server_B” Server_A

Это короче, чище и не зависит от netcat в прокси-сервере перехода. Теперь давайте
сделаем еще один шаг вперед. Предположим, вы хотите перетащить страницу вниз с помощью
командной строки и хотите прокси через Server_B, чтобы получить эту страницу из Server_A.
@display
echo “GET /some/page.html” | ssh -W Server_A:80 Server_B >page.html
@end display
Почему вы можете захотеть сделать это? Если у вас нет прямого маршрута к Server_A на
этом порту, но вы можете получить доступ к Server_B через SSH, и ИТ-отдел имеет доступ к
Server_A на этом порту, у вас есть быстрый и грязный временный прокси.

Давайте на минуту отложим этот мыслительный процесс и подумаем о том, сколько людей
пытаются заблокировать локальные учетные записи (хранящиеся в /etc/passwd.) Многие люди
будут предоставлять учетную запись процесса “/bin/false” как “shell”, чтобы предотвратить
вход в оболочку. Однако, если вы никогда не пытаетесь получить оболочку с этой учетной
записью, вы можете использовать эту учетную запись для прокси в течение всего дня с
настройками по умолчанию sshd_config. Если вы хотите отключить эту функцию (и вы должны
учитывать ее по причинам, указанным выше), вы должны установить для AllowTCPForwarding
значение “no” в файле sshd_config и перезапустить sshd.

Сейчас в социальных сетях витает разговор о ботнете Internet of Things, который недавно
снял блог Кребса. Один из поставщиков безопасности предположил, что атака, которую они
называют “SSHowDowN”, и этот вид функциональности - именно то, на что они ссылаются.

Подобные вещи действительно хороши, когда используются правильно, но они также опасны
для того, чтобы пробить дыры в списках контроля доступа маршрутизатора и
межсетевого экрана.

@node SSH туннелирование TCP
@section SSH туннелирование TCP
@ifinfo
@heading SSH туннелирование TCP
@end ifinfo

Одним из значительных преимуществ SSH является возможность создания перенаправлений
переадресации портов для временного доступа к системе, которая в противном случае не
смогла бы получить доступ к машине. Это действительно легко настроить, и он работает
довольно хорошо для многих сценариев, но недостатком этого является то, что… это
действительно легко настроить и работает довольно хорошо для многих сценариев, для
которых вы можете не использовать его. Это можно использовать, чтобы пробить дыры в
правилах брандмауэра, и это может привести вас к горячим отношениям с не теми людьми,
поэтому убедитесь, что вы понимаете свою корпоративную политику, прежде чем пытаться
использовать что-то подобное на работе.

SSH обеспечивает несколько видов переадресации портов TCP, поэтому мы рассмотрим их
по одному. На этот раз мы НЕ будем рассматривать туннелирование устройств “TUN” через
флаг -w. Это будет рассмотрено позже.
В этот раз мы также НЕ будем рассматривать стандартную переадресацию ввода/вывода через
флаг -W. Это будет только охватывать пересылку TCP.

Первый тип пересылки TCP, который мы рассмотрим, это Dynamic Port Forwarding
(используя SOCKS4/SOCKS5 протокол). Флаг для этого - -D и принимает необязательный
“bind_address” и требуемый “port”, который будет передан ему.
@display
-D [bind_address:]port
@end display
Это создает прослушивающий сокет локально на предоставленном порту и, необязательно,
заданный адрес bind_address, который будет действовать как прокси-сервер уровня
приложения SOCKS4 / SOCKS5. Лучше всего настроить это на привязку к localhost, а затем
использовать один из других параметров туннелирования, чтобы указать на него, чтобы
защитить прокси от пользователей, которым вы не хотите его использовать. Конечно, любой,
кто может получить доступ к машине через ssh, сможет использовать это, так что будьте
внимательны с тем, где вы его настроили. Любое приложение, поддерживающее SOCKS, может
воспользоваться этим, если оно может подключаться к порту прослушивания.

Следующие два параметра на самом деле одно и то же, но один настраивает порт прослушивания
на локальном (клиентском) компьютере, а другой настраивает порт прослушивания на удаленном
(серверном) компьютере. Флаги -L и -R соответственно.
@display
-L [bind_address:]port:host:hostport
-R [bind_address:]port:host:hostport
@end display
Если вы хотите перенаправить локальный (клиентский) прослушивающий порт на удаленный
компьютер, используйте “L” для “local”.
Если вы хотите перенаправить удаленный (серверный) прослушивающий порт на клиентский
компьютер, используйте “R” для “remote”.

Другими словами, этот “listening port” связан локально или удаленно и является одним
концом туннеля. “host” и “hostport” не обязательно совпадают с целевым сервером, к
которому вы подключаетесь через SSH. Они просто должны быть хостом и портом, к
которому удаленная система может фактически добраться.

“-L 8080:example.com:80” связывает локальный порт 8080 с клиентом, когда он устанавливает
соединение с удаленным ssh-сервером. Затем удаленный ssh-сервер связывает соединение с
портом 80 на example.com на его конце. Оттуда вы сможете локально подключиться к порту
8080 на своей клиентской машине и подключиться к этому удаленному серверу example.com
через его порт 80, все через туннель через ssh на сервер ssh.

“-R 2222:localhost:22” создаст прослушивающую привязку “localhost” к порту 2222 на
удаленном сервере, который указывает на порт 22 на локальном клиенте. Если вы
подключитесь к этому вне вашей сети, это позволит людям вне сети подключаться по ssh с
этой удаленной машины, если они имеют правильные учетные данные.

Все эти опции, как указано, создают оболочку при входе в систему. Вы можете установить
JUST туннель, используя опции “-N” “-T” и “-f”.
@display
“-N” говорит не вызывать удаленную команду, просто установить туннели.
“-T” говорит не устанавливать псевдо-TTY (PTY) терминал, что подходит, так как вы
     не передаете никаких команд.
“-f” говорит SSH работать в фоне, так как вы, вероятно, хотите сделать больше работы
     после установления сеанса.

ssh -fNT -L localhost:8080:google.com:80 User_B@@jumphost
@end display
Это говорит фоновому SSH после установки туннеля и не выделяет PTY. Установите
туннель с локально связанным портом 8080, и пусть удаленный ssh-сервер “jumphost”
установит туннель к “google.com” на порту 80. Подключитесь как User_B к ssh-серверу.

Вы можете проверить с помощью “netstat -an | grep LISTEN”, есть ли у вас прослушивающий
порт 8080 после установки этого. Вы можете протестировать туннель с помощью netcat или
telnet к localhost через порт 8080 и ввести “GET /”, а затем нажать Enter. Возможно, вам
придется нажать Enter дважды, в некоторых случаях. Вам придется заменить “User_B” и
“jumphost” на реальную систему, к которой у вас есть доступ, которая также имеет доступ
к Интернету, конечно.

@node поток подключения
@section поток подключения
@ifinfo
@heading поток подключения
@end ifinfo

Прежде чем мы перейдем к более сложным вещам с настройкой SSH, я подумал, что нам
следует взглянуть на то, что на самом деле происходит, когда клиент подключается к
серверу OpenSSH, и что такое дерево решений для предоставления или не предоставления
доступа.

Со страниц руководства sshd:
@display
Когда пользователь успешно входит в систему, sshd делает следующее:
1. Если для входа используется tty, а команда не указана, печатается время последнего
   входа и /etc/motd (если это не запрещено в файле конфигурации или с помощью
   ~/.hushlogin; см. Раздел FILES).
~/.hushlogin
   Этот файл используется для подавления печати времени последнего входа в систему и
   /etc/motd, если PrintLastLog и PrintMotd, соответственно, включены. Он не подавляет
   печать баннера, указанного в Banner.
2. Если логин на tty, записывает время входа.
3. Проверяет /etc/nologin; если он существует, печатает содержимое и выходит (если не root).
4. Изменения для запуска с правами обычного пользователя.
5. Устанавливает основную среду.
6. Читает файл ~/.ssh/environment, если он существует, и пользователям разрешено
   изменять свою среду. Смотрите опцию PermitUserEnvironment в sshd_config(5).
~/.ssh/environment
   Этот файл считывается в среду при входе в систему (если он существует). Он может
   содержать только пустые строки, строки комментариев (начинающиеся с ‘#’) и строки
   присваивания в форме name=value (name = value). Файл должен быть доступен для записи
   только пользователю; это не должно быть доступно для чтения кем-либо еще. Обработка
   среды по умолчанию отключена и управляется с помощью опции PermitUserEnvironment.
7. Изменения в домашнем каталоге пользователя.
8. Если ~/.ssh/rc существует, запускает его; иначе, если /etc/ssh/sshrc существует,
   запускает его; в противном случае работает Xauth. Файлы “rc” получают протокол
   аутентификации X11 и cookie при стандартном вводе. Смотрите SSHRC ниже.
~/.ssh/rc
   Содержит процедуры инициализации, которые должны быть выполнены до того, как домашний
   каталог пользователя станет доступным. Этот файл должен быть доступен для записи только
   пользователю, и не должен быть доступен для чтения кем-либо еще.
9. Запускает пользовательскую оболочку или команду.
@end display
Итак, из вышесказанного мы можем увидеть еще несколько способов управления нашим
клиентским подключением и что он выводит при подключении. Раньше мы рассмотрели
“LogLevel QUIET” в файле ~/.ssh/config, но мы также можем воспользоваться файлом
“.hushlogin” для подавления некоторой информации.

Мы также видим, что логин регистрируется, только если есть связанный TTY. Это важно
помнить для судебно-медицинской экспертизы.

Мы можем временно отключить вход в систему с SSH (отличным от root), создав файл
/etc/nologin, и содержимое этого файла будет отображаться при отклонении попытки
подключения. Это опасно, если у вас нет доступа к консоли, поэтому будьте осторожны с этим.

Служба отбрасывает привилегии и устанавливает базовую среду, затем настраивает ее из
файла ~/.ssh/environment, если он существует, и пользователям разрешается изменять свою
среду. Поведение по умолчанию запрещает это, но это нужно проверить при блокировке ваших
систем. Наконец, он переходит в домашний каталог пользователя, чтобы завершить подготовку
среды.

Затем он читает и автоматически запускает файл ~/.ssh/rc, если он существует. Это также
важно знать для судебной экспертизы и для блокировки вашей системы. Это отличное место
для того, чтобы отказаться от постоянного недостоверного сценария, поэтому его стоит
поискать и просмотреть.

Наконец, он запускает оболочку или любую команду, которая была запрошена. Кажется
довольно просто, верно? Ну, man-страницы на этом заканчиваются.

Таким образом, с точки зрения защиты, мы хотим рассмотреть больше, чем просто файлы
~/.ssh/@{config,authorized_keys,authorized_keys2,known_hosts@}. Мы также хотим посмотреть
на любые файлы rc и environment в этом каталоге. Это особенно верно для пользователя root.

@node Клиент Config
@section Клиент Config
@ifinfo
@heading Клиент Config
@end ifinfo


На этой неделе мы сосредоточимся на файлах конфигурации на стороне клиента и на том, как
их использовать, чтобы сделать ssh более приятным. В конфигурационных файлах много опций,
поэтому мы собираемся разбить это на разные части. Мы рассмотрим некоторые общие настройки,
с которыми люди могут захотеть поиграть, чтобы сделать обработку сессий более эффективной,
а затем, после того, как мы обсудим некоторые более сложные темы в течение следующих
нескольких разделов, мы выполним вторую часть, чтобы рассмотреть некоторые из более
продвинутых параметров конфигурации, связанные с этими ранее затронутыми темами Это
означает, что вторая часть не будет в следующем разделе.

Есть два файла по умолчанию, которые обрабатывают конфигурацию ssh на стороне клиента
в OpenSSH. Глобальный файл обычно находится по адресу /etc/ssh/ssh_config и содержит
все настройки по умолчанию для всех пользователей системы. Пользователь также может
написать параметры конфигурации, которые переопределяют глобальный файл конфигурации,
включив файл “config” в каталог .ssh этого пользователя. Когда вызывается ssh-клиент,
порядок приоритета при разборе параметров покрывается следующим образом:
@display
1. опции командной строки
2. пользовательский конфигурационный файл (~/.ssh/config)
3. общесистемный конфигурационный файл (/etc/ssh/ssh_config)
@end display
Все, что указано в командной строке, превосходит все остальное. Конфигурация пользователя
превосходит общесистемную конфигурацию. Общесистемный конфиг охватывает все, что не было
явно переопределено двумя другими. Это имеет смысл, но важно знать, каков приоритет
синтаксического анализа при устранении неполадок.

Сейчас акцент будет сделан на файле ~/.ssh/config, который должен содержать
пользовательские настройки.

Одним из первых параметров, которые я установил в своем собственном конфиге, является
настройка “LogLevel”. Я предпочитаю подавлять постороннюю информацию (например, баннеры),
потому что мне нравится обрабатывать отчеты с нескольких серверов, и я хочу получать
информацию только из команд, которые я запускаю, а не что-нибудь еще. Для подавления этих
сообщений я использую:
@display
LogLevel QUIET
@end display
Вы можете настроить его на любой уровень шума, который вы предпочитаете, вплоть до
DEBUG3, что эквивалентно “ssh -vvv” для “verbose debugging”. Однако я не рекомендую
использовать для этого конфигурацию пользователя. Просто используйте флаги для
переопределения и используйте конфигурацию для подавления, как указано выше.

Следующий набор опций, которые люди часто используют, - это настройки “Match,” “User,”
“Host,” и “HostName”.
Параметр “User” используется для установки того, какое целевое имя пользователя должно
использоваться при входе в в систему. Это похоже на переход от сценария
User_A@@Workstation_A к сценарию User_B@@Server_B, который мы создали ранее. В этом
случае установка “User User_B” будет означать, что вы можете набрать “ssh Server_B”,
и он будет знать, что в качестве цели будет использоваться “User_B” вместо значения
по умолчанию “User_A”.

Опция “Host” устанавливает блок для опций, которые применяются к данному имени хоста до
следующего блока “Host” или “Match”. Имя может соответствовать шаблону с подстановочными
знаками и может включать отрицание начинающееся с “!”, если это необходимо.
@display
“Host !*.web.com”

    сказал бы, что “the following settings up to and not including the next Match or Host
    block apply to all systems that are NOT like *.web.com” (следующие настройки вплоть
    до следующего блока Match или Host и без него применяются ко всем системам, которые
    НЕ являются *.web.com).
@end display
Предыдущий пример плохой, но в нем есть смысл. Чтобы установить глобальное содержимое
внизу, используйте параметр “Host *”, чтобы соответствовать всему, и более ранние блоки
Match/Host будут переопределять это по мере необходимости, так как они уже установили
значения, если что-то соответствует им.

Опция “Match” используется для точной настройки соответствия различных объектов. Она
может сопоставить имя пользователя с “Match user” или адрес с “Match address” и так
далее. Вы можете сделать “Match host”, но использование “Host” в качестве опции блока,
вероятно, лучше для почти всех случаев.

Опция “HostName” позволяет вам устанавливать псевдонимы в вашей конфигурации. Обычно это
устанавливается как опция после совпадения “Host”. Вы можете использовать “%h”, чтобы
указать имя хоста, которое было передано ssh в командной строке, прежде чем изменять его
с помощью “HostName”, так что “HostName” добавляется к нему по мере необходимости. Вы
также можете установить для этого адреса переопределение, например, всего, что
возвратил бы DNS.

Используя то, что мы узнали, давайте предположим, что User_A хочет войти в систему как
User_B почти во всех случаях. Однако User_A является системным администратором AIX,
поэтому для виртуальной установки IO может потребоваться войти на сервер VIO, что
означает, что целевой пользователь, скорее всего, является “padmin”, а не User_A или
User_B. Кроме того, AIX управляется Hardware Management Console (HMC) (аппаратные
средства консоли управления), который часто использует пользователя “hscroot”, а не
локальные учетные записи. Конечно, каждый набор отличается, но это стандартная практика,
поэтому мы пойдем этим путем. Организация использует стандартную схему именования,
согласно которой все серверы VIO имеют имя, которое начинается с “vio”, за которым
следует некоторый уникальный идентификатор. Объект HMCs аналогичным образом называется
“hmc”, за которым следует некоторый уникальный идентификатор. Серверы VIO также находятся
в другом домене, отличном от стандартного, который называется ‘internal.net’. Мы также
знаем, что если пользователь входит в систему как root, ключ никогда не будет
использоваться, поэтому мы хотим пропустить обмен ключами и вместо этого ввести пароль для
root. Вооружившись этими знаниями, мы можем упростить жизнь в User_A’s, если создадим
конфигурацию, которая выглядит следующим образом:
@display
LogLevel QUIET
Host vio*
   HostName “%h.internal.net”
   User padmin
Host hmc*
   User hscroot
Match user root
   PubkeyAuthentication no
   PasswordAuthentication yes
   PreferredAuthentications password
Match user User_B
   PreferredAuthentications publickey,password
Host *
   User User_B
@end display
Параметры, которые мы установили для блока “Match user root”, должны быть достаточно
понятными на данный момент. Вариантов намного больше, чем это, и мы рассмотрим их в конце
концов, но это неплохой общий обзор того, как со временем создать конфигурацию. Не
забудьте поставить свои глобальные элементы внизу, так как они читаются сверху вниз
до первого совпадения, которое и используется для установки.

@node защита закрытого ключа SSH
@section защита закрытого ключа SSH
@ifinfo
@heading защита закрытого ключа SSH
@end ifinfo

В нашем предыдущем посте было показано, как сгенерировать пару ключей public/private без
использования пароля. Иногда это желаемая конфигурация, но лучше заблокировать закрытый
ключ с помощью ключевой фразы. Когда вы генерируете пару ключей, вы можете добавить
фразу-пароль в ответ на приглашение, также вы можете изменить существующую фразу-пароль
или добавить фразу-пароль для ключа, у которого её еще нет. Средства для этого показаны
ниже:
@example
ssh-keygen -f ~/.ssh/id_rsa -p
@end example
Если существующая фраза пуста, это сразу же попросит вас ввести новую фразу-пароль. Если
существует фраза-пароль, она сначала запросит ввести её, прежде чем запрашивать новую.
Установка пароля на закрытый ключ является важным шагом для защиты этого ключа. Если
кому-то, не имеющему права использовать этот ключ, каким-либо образом удалось получить
его копию, он не сможет использовать ключ, пока не выяснит для него ключевую фразу. Хотя
можно грубо взломать ключ, если вы используете прилично длинную фразу, которая не является
чем-то обычно произносимым или написанным, шансы ее взлома снижаются. Также обратите
внимание, что ключевые фразы SSH допускают пробелы, так что вы можете буквально писать
бессмысленные предложения, пробелы и все остальное. Существует еще многое, что можно
сделать, чтобы снизить риск того, что кто-то использует украденный закрытый ключ для
причинения вреда, но это на стороне клиента, и есть предостережения.

Теперь, когда у нас есть парольная фраза, защищающая наш закрытый ключ, что изменилось в
том, как работает ssh? Для начала, если вы не используете Агента для загрузки ваших ключей,
каждый раз, когда вы заходите на сервер, используя этот ключ, вам будет предложено ввести
пароль. Это делает удобство хуже, а не лучше. Чтобы использовать агент, запустите ssh-add.
Если вы используете стандартное имя ключа, такое как id_rsa, id_dsa, или id_ecdsa, он
автоматически найдет и загрузит этот ключ для вас. Для каждого ключа со стандартным именем,
которое он находит, он запросит пароль. Вы даете ему фразу, а остальное он обрабатывает.
Он действует от вашего имени до тех пор, пока не получит указание выгрузить ключ или не
будет остановлен. Когда вы войдете в систему, клиент SSH увидит, что агент работает, и
когда сервер запросит ключ, он передаст этот запрос агенту, который предоставит
подтверждение того, что он знает ключ, и, таким образом, вам не будет предложено ввести
пароль. Это похоже на быстрый SSH, но сначала требуется дополнительный шаг загрузки агента.

Если вы получаете сообщение об ошибке при запуске ssh-add, есть вероятность, что
ssh-agent еще не запущен. Если это так, вы можете сначала запустить ssh-agent, взять
полученный вывод и экспортировать эти переменные. Например:
@example
ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-w8iG9Aq6KWLR/agent.1070; export SSH_AUTH_SOCK;
SSH_AGENT_PID=1071; export SSH_AGENT_PID;
@end example
Если у вас есть ключ с пользовательским именем, например id_rsa_2016, вы можете загрузить
его, передав его имя, например, так:
@example
ssh-add /home/User_A/.ssh/id_rsa_2016
@end example
Использование агента опасно в общей среде, где другие люди имеют повышенные привилегии.
Любой пользователь с правами root может извлечь приватный ключ из памяти, пока агент
работает от вашего имени. Вы можете выгрузить ключи перед блокировкой вашей рабочей
станции, если вы параноик, используя -D или -d, как показано ниже:
@example
ssh-add -D #Delete all identities
ssh-add -d /home/User_A/.ssh/id_rsa_2016 #Удаляет только ключ id_rsa из списка агента
@end example
Вы также можете заблокировать и разблокировать свой агент, используя флаги “-x” и “-X”
соответственно, если вы не хотите полностью выгружать из соображений безопасности. Они
предложат вам ввести пароль для блокировки и разблокировки агента, если вы решите
использовать их.

Если вы хотите увидеть, какие ключи загружены, вы можете перечислить их с помощью
“ssh-add -l”. И если вам необходимо убедиться, какой открытый ключ соответствует
загруженному закрытому ключу, вы можете использовать “ssh-add -L”.

Наконец, если вы хотите установить ограничение по времени для загружаемого ключа, вы
можете использовать флаг -t, чтобы сделать его временным. Требуется число указывающее
(в секундах), как долго ключ должен оставаться загруженным агентом.

Остальные флаги предназначены для более продвинутых вещей, о которых я расскажу отдельно,
поэтому это все, что мы расскажем на сегодня. Если вы до сих пор не отставали, то на
данный момент вы в значительной степени находитесь на уровне среднего пользователя SSH.
(И это еще не все.) Далее мы рассмотрим некоторые параметры конфигурации клиента,
чтобы упростить управление сеансами.

@node наши первые ключи SSH
@section наши первые ключи SSH
@ifinfo
@heading наши первые ключи SSH
@end ifinfo


Раннее мы подготовили почву для установки и настройки SSH для входа в систему с паролем.
Это работает для многих людей, но не очень гибко. Что если пользователю необходимо
удаленно запустить рабочую нагрузку из сценария? Сценарию будет предложено ввести пароль,
и он не будет корректно обрабатываться без какого-либо помощника, такого как оболочка
Expect. Вызов perl для Expect.pm, или необработанное ожидание, основанное на TCL, или
одного из множества других языков с модулем Expect, добавит раздувание к тому, что
потенциально может быть скудным и средним сценарием оболочки, в итоге. Кроме того,
пароли часто легко взламываются, если целевая система (Server_B) плохо настроена для
обработки повторных попыток ввода пароля. Попытки грубой силы все время случаются на
машинах, обращенных к интернету. Так как же нам избавиться от необходимости пароля?
Мы будем использовать пару открытый/закрытый ключ для обработки аутентификации для нас.

Помните, что лучшее место для генерации вашей пары открытых/закрытых ключей - это
пользователь на машине, к которой вы подключаетесь FROM. В нашем примере сценария это
будет User_A на Workstation_A. Генерация ключа может быть сложной, но сейчас мы просто
сгенерируем ключ без ключевой фразы. Далее мы расскажем об использовании ключевой фразы
на ключе, почему это важно сделать и как справиться с возможностью использовать сценарии
без запроса.

Для генерации нашего начального набора ключей мы будем использовать утилиту ssh-keygen,
поставляемую OpenSSH.
@example
ssh-keygen -t rsa -b 4096 -C “User_A@@Workstation_A initial key”
@end example
Это должно запросить путь и имя (обычно home_directory/.ssh/id_rsa), где будет
сгенерирован ключ.
Она также должна запрашивать парольную фразу, но мы пока оставляем это поле пустым,
поэтому просто нажимайте “Enter”, чтобы двигаться дальше.
Наконец, она выполнит некоторые вычисления, выведет вывод “bubble babble” и завершит
работу. Как только это будет сделано, вы должны увидеть два новых ключа в каталоге,
созданные ей. Сделайте “ls -l ~/.ssh” и посмотрите, есть ли у вас файлы “id_rsa” и
“id_rsa.pub”, сейчас (при условии, что вы не меняли путь или имя при появлении запроса).

Хорошо, с этой командой происходит несколько вещей. Во-первых, флаг “-t rsa” указывает
команде на создание ключей с использованием алгоритма шифрования RSA. “-b 4096” говорит,
чтобы сделать это алгоритм 4096 бит RSA. Флаг “-C” помещает в файл комментарий, который
помогает определить назначение ключа и того, кому он принадлежит. Этот комментарий
появляется в открытом ключе из пары. Если вы отследите этот файл, вы должны увидеть тег
комментария в конце ключа.

Получив пару ключей, поймите, что файл “id_rsa” - это ваш закрытый ключ. Это должно быть
заблокировано (обычно с 600 разрешениями) и не должно копироваться ни в какие другие
системы (за исключением некоторых очень редких исключений.) Открытый ключ - “id_rsa.pub” и
это то, что вам нужно отправить для User_B на Server_B. Содержимое этого файла открытого
ключа фактически помещается в другой файл для этого пользователя. Они должны быть помещены
в файл ~User_B/.ssh/authorized_keys. Есть несколько способов избавиться от этого. Многие
люди предпочитают использовать команду “ssh-copy-id”, чтобы вытолкнуть это, но мне не
нравится, как она обычно обрабатывает файл authorized_keys. Она просто слепо добавляет
к нему. Я предпочитаю написать функцию, которая обрабатывает передачу содержимого на
удаленный сервер, а также выводит файл author_keys удаленного сервера, выводит выходные
данные и записывает их обратно в файл authorized_keys. Эта процедура гарантирует, что
только одна копия открытого ключа когда-либо будет отправлена, независимо от того, сколько
раз вы делаете это. Детали функции находятся в моем продукте
“DSH – Distributed/Dancer’s Shell”. Если вы еще не видите ссылку для этого, это потому,
что продукт проходит тестирование Alpha и скоро будет запущен как Beta. Я опубликую
ссылку, когда она выйдет в эфир, для тех, кто заинтересован.

Как только открытый ключ окажется на удаленном сервере, убедитесь, что права доступа к
файлу авторизованному файлу также равны 600. Каталог .ssh должен быть 700. Домашний
каталог не должен быть доступен для чтения всем. Затем проверьте подключение от
User_A@@Workstation_A к User_B@@Server_B. Он должен “just work” и вывести вас в
командной строке. Если это не так, вы можете проверить журналы на удаленном сервере
(обычно /var/log/secure.log или /var/log/sshd.log или аналогичные) на наличие подсказок,
и вы можете повторить попытку соединения с “ssh -vvv”, чтобы получить подробный вывод для
других подсказок. Часто это ошибка прав доступа, поэтому дважды проверьте права доступа
к файлам.

Теперь это позволит User_A на рабочей станции_A писать сценарии, которые могут вызывать
“ssh User_B@@Server_B ” для запуска удаленных рабочих нагрузок, без запроса пароля.

Однако это не самый лучший способ справиться с этим, поэтому мы рассмотрим, как защитить
личный ключ с помощью ключевой фразы в следующем разделе, и все же сможем сделать это,
не запрашивая при каждом соединении.

@display

How to Harden SSH with Identities and Certificates

    The Source Fantastic
    Blog Archive
    About

    2014-August-07
    Dublin Maker 2014
    New column: The Source Fantastic!
@end display


