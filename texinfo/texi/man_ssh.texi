@node SSH, SSHD, Top, Top
@chapter SSH
@table @asis
@item NAME
     ssh — OpenSSH SSH клиент (программа удаленного входа)

@item SYNOPSIS
     ssh [-@ref{man_ssh_ssh 1,, 1}@ref{man_ssh_ssh 2,, 2}@ref{man_ssh_ssh 4,, 4}@ref{man_ssh_ssh 6,, 6}@ref{man_ssh_ssh A,, A}@ref{man_ssh_ssh a,, a}@ref{man_ssh_ssh -C,, -C}@ref{man_ssh_ssh f,, f}@ref{man_ssh_ssh G,, G}@ref{man_ssh_ssh g,, g}@ref{man_ssh_ssh K,, K}@ref{man_ssh_ssh k,, k}@ref{man_ssh_ssh M,, M}@ref{man_ssh_ssh N,, N}@ref{man_ssh_ssh n,, n}@ref{man_ssh_ssh q,, q}@ref{man_ssh_ssh s,, s}@ref{man_ssh_ssh T,, T}@ref{man_ssh_ssh t,, t}@ref{man_ssh_ssh V,, V}@ref{man_ssh_ssh v,, v}@ref{man_ssh_ssh X,, X}@ref{man_ssh_ssh x,, x}@ref{man_ssh_ssh Y,, Y}@ref{man_ssh_ssh y,, y}] [@ref{man_ssh_ssh -b bind_address,, -b bind_address}] [@ref{man_ssh_ssh -c cipher_spec,, -c cipher_spec}]
         [@ref{man_ssh_ssh -D [bind_address:]port,, -D [bind_address:]port}] [@ref{man_ssh_ssh -E log_file,, -E log_file}] [@ref{man_ssh_ssh -e escape_char,, -e escape_char}]
         [@ref{man_ssh_ssh -F configfile,, -F configfile}] [@ref{man_ssh_ssh -I pkcs11,, -I pkcs11}] [@ref{man_ssh_ssh -i identity_file,, -i identity_file}] [@ref{man_ssh_ssh Перенаправление локального соединения,, -L address}]
         [@ref{man_ssh_ssh -l login_name,, -l login_name}] [@ref{man_ssh_ssh -m mac_spec,, -m mac_spec}] [@ref{man_ssh_ssh -O ctl_cmd,, -O ctl_cmd}] [@ref{man_ssh_ssh -o option,, -o option}] [@ref{man_ssh_ssh -p port,, -p port}]
         [@ref{man_ssh_ssh -Q query_option,, -Q query_option}] [@ref{man_ssh_ssh Перенаправление удаленного соединения,, -R address}] [@ref{man_ssh_ssh -S ctl_path,, -S ctl_path}] [@ref{man_ssh_ssh -W host:port,, -W host:port}]
         [@ref{man_ssh_ssh -w local_tun[:remote_tun],, -w local_tun[:remote_tun]}] [user@@]hostname [command]
@item Переменные окружения ssh
@display
     @ref{man_ssh_peremen_okruj DISPLAY,, DISPLAY}
     @ref{man_ssh_peremen_okruj HOME,, HOME}
     @ref{man_ssh_peremen_okruj LOGNAME,, LOGNAME}
     @ref{man_ssh_peremen_okruj MAIL,, MAIL}
     @ref{man_ssh_peremen_okruj PATH,, PATH}
     @ref{man_ssh_peremen_okruj SSH_ASKPASS,, SSH_ASKPASS}
     @ref{man_ssh_peremen_okruj SSH_AUTH_SOCK,, SSH_AUTH_SOCK}
     @ref{man_ssh_peremen_okruj SSH_CONNECTION,, SSH_CONNECTION}
     @ref{man_ssh_peremen_okruj SSH_ORIGINAL_COMMAND,, SSH_ORIGINAL_COMMAND}
     @ref{man_ssh_peremen_okruj SSH_TTY,, SSH_TTY}
     @ref{man_ssh_peremen_okruj TZ,, TZ}
     @ref{man_ssh_peremen_okruj USER,, USER}
@end display
@item Список файлов
@display
     @ref{man_ssh_peremen_okruj ~/.rhosts,, ~/.rhosts}
     @ref{man_ssh_peremen_okruj ~/.shosts,, ~/.shosts}
     @ref{man_ssh_peremen_okruj ~/.ssh/,, ~/.ssh/}
     @ref{man_ssh_peremen_okruj ~/.ssh/authorized_keys,, ~/.ssh/authorized_keys}
     @ref{man_ssh_peremen_okruj ~/.ssh/config,, ~/.ssh/config}
     @ref{man_ssh_peremen_okruj ~/.ssh/environment,, ~/.ssh/environment}
     @ref{man_ssh_peremen_okruj Файлы закрытых частей ключа аунтификации,, Файлы закрытых частей ключа аунтификации}
     @ref{man_ssh_peremen_okruj Файлы открытой части ключа аунтификации,, Файлы открытой части ключа аунтификации}
     @ref{man_ssh_peremen_okruj ~/.ssh/known_hosts,, ~/.ssh/known_hosts}
     @ref{man_ssh_peremen_okruj ~/.ssh/rc,, ~/.ssh/rc}
     @ref{man_ssh_peremen_okruj /etc/hosts.equiv,, /etc/hosts.equiv}
     @ref{man_ssh_peremen_okruj /etc/ssh/shosts.equiv,, /etc/ssh/shosts.equiv}
     @ref{man_ssh_peremen_okruj /etc/ssh/ssh_config,, /etc/ssh/ssh_config}
     @ref{man_ssh_peremen_okruj Файлы закрытой части ключей аунтификации на основании хоста,, Файлы закрытой части ключей аунтификации на основании хоста}
     @ref{man_ssh_peremen_okruj /etc/ssh/ssh_known_hosts,, /etc/ssh/ssh_known_hosts}
     @ref{man_ssh_peremen_okruj /etc/ssh/sshrc,, /etc/ssh/sshrc}
     
@end display
@item DESCRIPTION
     ssh (SSH-клиент) - это программа для входа на удаленный компьютер и выполнения
     команд на удаленном компьютере. Она предназначена для обеспечения безопасной
     зашифрованной связи между двумя ненадежными узлами через небезопасную сеть.
     Соединения X11, произвольные TCP-порты и сокеты UNIX-домена также могут быть
     перенаправлены по защищенному каналу.

     SSH подключается и входит в указанное имя хоста (с необязательным именем
     пользователя). Пользователь должен подтвердить свою личность на удаленном компьютере
     одним из нескольких способов (см. Ниже).

     Если указана команда, она выполняется на удаленном хосте вместо оболочки входа
     в систему.

     Варианты следующие:
@table @asis
@item     -1 @anchor{man_ssh_ssh 1}
             Заставляет ssh использовать только протокол версии 1.

@item     -2 @anchor{man_ssh_ssh 2}
             Заставляет ssh использовать только протокол версии 2.

@item     -4 @anchor{man_ssh_ssh 4}
             Заставляет ssh использовать только адреса IPv4.

@item     -6 @anchor{man_ssh_ssh 6}
             Заставляет ssh использовать только адреса IPv6.

@item     -A @anchor{man_ssh_ssh A}
             Включает переадресацию соединения с агентом аутентификации. Это также
             может быть указано для каждого хоста в файле конфигурации.

             Переадресация агента должна быть включена с осторожностью. Пользователи с
             возможностью обхода прав доступа к файлам на удаленном хосте (для сокета
             UNIX-домена агента) могут получить доступ к локальному агенту через
             переадресованное соединение. Злоумышленник не может получить материал ключа
             от агента, однако он может выполнять операции с ключами, которые позволяют
             им проходить проверку подлинности с использованием идентификаторов,
             загруженных в агент.

@item     -a @anchor{man_ssh_ssh a}
             Отключает переадресацию соединения агента аутентификации.

@item     -b bind_address @anchor{man_ssh_ssh -b bind_address}
             Используйте bind_address на локальной машине в качестве адреса
             источника соединения. Полезно только в системах с более чем
             одним адресом.

@item     -C @anchor{man_ssh_ssh -C}
             Запрашивает сжатие всех данных (включая stdin, stdout, stderr, и
             данные для переадресованных соединений X11, TCP и UNIX-доменов). Алгоритм
             сжатия тот же, что и в gzip(1), и “level” можно контролировать с помощью
             параметра CompressionLevel для версии протокола 1. Сжатие желательно на
             модемных линиях и других медленных соединениях, но только в быстрых сетях
             замедлит работу. Значение по умолчанию может быть установлено для каждого
             хоста отдельно в файлах конфигурации; см. вариант Compression.

@item     -c cipher_spec @anchor{man_ssh_ssh -c cipher_spec}
             Выбирает спецификацию шифра для шифрования сеанса.

             Протокол версии 1 позволяет указывать один шифр. Поддерживаемые значения:
             “3des”, “blowfish”, и “des”. Для протокола версии 2, cipher_spec - это
             список шифров, разделенных запятыми, в порядке предпочтения. См.
             Ключевое слово Ciphers в ssh_config(5) для получения дополнительной
             информации.

@item     -D [bind_address:]port @anchor{man_ssh_ssh -D [bind_address:]port}
             Определяет локальную переадресацию портов на уровне приложения “dynamic”.
             Это работает путем выделения сокета для прослушивания порта на локальной
             стороне, необязательно привязанного к указанному bind_address. Всякий раз,
             когда устанавливается соединение с этим портом, оно перенаправляется по
             безопасному каналу, а затем протокол приложения используется для определения
             того, к чему подключаться с удаленного компьютера. В настоящее время
             поддерживаются протоколы SOCKS4 и SOCKS5, и ssh будет действовать как сервер
             SOCKS. Только root может пересылать привилегированные порты. Переадресация
             динамических портов также может быть указана в файле конфигурации.

             Адреса IPv6 можно указать, заключив адрес в квадратные скобки. Только
             суперпользователь может пересылать привилегированные порты. По умолчанию
             локальный порт привязан в соответствии с настройкой GatewayPorts. Однако
             явный bind_address может использоваться для привязки соединения к
             определенному адресу. bind_address из “localhost” указывает, что
             прослушивающий порт должен быть привязан только для локального использования,
             в то время как пустой адрес или ‘*’ указывает, что порт должен быть доступен
             со всех интерфейсов.

@item     -E log_file @anchor{man_ssh_ssh -E log_file}
             Добавлять журналы отладки в log_file вместо стандартной ошибки.

@item     -e escape_char @anchor{man_ssh_ssh -e escape_char}
             Устанавливает escape-символ для сеансов с pty (по умолчанию: ‘~’).
             Экранирующий символ распознается только в начале строки. Экранирующий
             символ, за которым следует точка (‘.’), закрывает соединение; затем
             control-Z приостанавливает соединение; а затем сам отправляет escape-символ
             один раз. Установка символа в “none” отключает любые экранирования и делает
             сеанс полностью прозрачным.

@item     -F configfile @anchor{man_ssh_ssh -F configfile}
             Определяет альтернативный файл конфигурации для каждого пользователя. Если
             файл конфигурации указан в командной строке, системный файл конфигурации
             (/etc/ssh/ssh_config) будет проигнорирован. По умолчанию для файла
             конфигурации для каждого пользователя используется ~/.ssh/config.

@item     -f @anchor{man_ssh_ssh f}
             Просит ssh перейти в фоновый режим непосредственно перед выполнением команды.
             Это полезно, если пользователь хочет сделать это в фоновом режиме. Это
             подразумевает -n. Рекомендуемый способ запуска программ X11 на удаленном
             сайте - это что-то вроде ssh -f host xterm.

             Если при конфигурирования конфигурации ExitOnForwardFailure задано
             значение“yes”, клиент, запущенный с -f, будет ожидать успешной установки
             всех удаленных портов, прежде чем перейти в фоновый режим.

@item     -G @anchor{man_ssh_ssh G}
             Заставляет ssh распечатать свою конфигурацию после оценки блоков Host и
             Match и выйти.

@item     -g @anchor{man_ssh_ssh g}
             Позволяет удаленным хостам подключаться к локальным перенаправленным портам.
             Если используется мультиплексное соединение, то эта опция должна быть
             указана в главном процессе.

@item     -I pkcs11 @anchor{man_ssh_ssh -I pkcs11}
             Укажите общую библиотеку PKCS#11, которую ssh должен использовать для связи
             с маркером PKCS#11, предоставляющим личный ключ RSA пользователя.

@item     -i identity_file @anchor{man_ssh_ssh -i identity_file}
             Выбирает файл, из которого читается идентификатор (закрытый ключ) для
             аутентификации с открытым ключом. По умолчанию используется
@display
             ~/.ssh/identity для версии протокола 1 и
             ~/.ssh/id_dsa,
             ~/.ssh/id_ecdsa,
             ~/.ssh/id_ed25519 и
             ~/.ssh/id_rsa
@end display
             для версии протокола 2. Файлы идентификации также могут быть
             указаны для каждого хоста в файле конфигурации. Можно иметь несколько
             параметров -i (и несколько идентификаторов, указанных в файлах конфигурации).
             Если в директиве CertificateFile явно не указаны сертификаты, ssh также
             попытается загрузить информацию о сертификате из имени файла, полученного
             путем добавления -cert.pub к именам идентификаторов.

@item     -K @anchor{man_ssh_ssh K}
             Включает аутентификацию на основе GSSAPI и пересылку (делегирование) учетных
             данных GSSAPI на сервер.

@item     -k @anchor{man_ssh_ssh k}
             Отключает пересылку (делегирование) учетных данных GSSAPI на сервер.
@item  Перенаправление локального соединения @anchor{man_ssh_ssh Перенаправление локального соединения}
@display
     -L [bind_address:]port:host:hostport
     -L [bind_address:]port:remote_socket
     -L local_socket:host:hostport
     -L local_socket:remote_socket
@end display
             Указывает, что соединения с данным портом TCP или сокетом Unix на локальном
             (клиентском) хосте должны быть перенаправлены на данный хост и порт или
             сокет Unix на удаленной стороне. Это работает путем выделения сокета для
             прослушивания либо порта TCP на локальной стороне, необязательно привязанного
             к указанному bind_address, либо к сокету Unix. Всякий раз, когда
             устанавливается соединение с локальным портом или сокетом, соединение
             перенаправляется по защищенному каналу, и соединение устанавливается либо
             с хост-порта хост-порта, либо с Unix-сокетом remote_socket с
             удаленной машины.

             Переадресация портов также может быть указана в файле конфигурации. Только
             суперпользователь может пересылать привилегированные порты. Адреса IPv6 можно
             указать, заключив адрес в квадратные скобки.

             По умолчанию локальный порт привязан в соответствии с настройкой GatewayPorts.
             Однако явный bind_address может использоваться для привязки соединения к
             определенному адресу. bind_address из “localhost” указывает, что
             прослушивающий порт должен быть привязан только для локального использования,
             в то время как пустой адрес или ‘*’ указывает, что порт должен быть доступен
             со всех интерфейсов.

@item     -l login_name @anchor{man_ssh_ssh -l login_name}
             Указывает пользователя для входа в систему как на удаленном компьютере.
             Это также может быть указано для каждого хоста в файле конфигурации.

@item     -M @anchor{man_ssh_ssh M}
             Помещает ssh-клиент в режим “master” для совместного использования соединения.
             Несколько опций -M переводят ssh в режим “master” с подтверждением,
             необходимым перед тем, как будут приняты подчиненные соединения. Обратитесь
             к описанию ControlMaster в ssh_config(5) для деталей.

@item     -m mac_spec @anchor{man_ssh_ssh -m mac_spec}
             Разделенный запятыми список алгоритмов MAC (код аутентификации сообщения),
             указанный в порядке предпочтения. Смотрите ключевое слово MACs для получения
             дополнительной информации.

@item     -N @anchor{man_ssh_ssh N}
             Не выполняйте удаленную команду. Это полезно только для переадресации портов.

@item     -n @anchor{man_ssh_ssh n}
             Перенаправляет stdin из /dev/null (фактически, предотвращает чтение
             из stdin). Это необходимо использовать, когда ssh запускается в фоновом
             режиме. Обычная хитрость заключается в том, чтобы использовать это для
             запуска программ X11 на удаленной машине. Например,
             ssh -n shadows.cs.hut.fi emacs & запустит emacs на
             shadows.cs.hut.fi, и соединение X11 будет автоматически перенаправлено
             по зашифрованному каналу. Программа ssh будет помещена в фоновый режим.
             (Это не работает, если ssh нужно запросить пароль или фразу-пароль;
             см. Также параметр -f.)

@item     -O ctl_cmd @anchor{man_ssh_ssh -O ctl_cmd}
             Управлять активным ведущим процессом мультиплексирования соединений. Когда
             указана опция -O, аргумент ctl_cmd интерпретируется и передается ведущему
             процессу. Допустимые команды:
@display
             “check” (проверьте, что основной процесс запущен),
             “forward” (переадресация запросов без выполнения команд),
             “cancel” (отмена переадресаций),
             “exit” (запрос на выход мастера) и
             “stop” (запрос мастера на прекращение приема дальнейшие
             запросы мультиплексирования).
@end display
@item     -o option @anchor{man_ssh_ssh -o option}
             Может использоваться для задания параметров в формате, используемом в файле
             конфигурации. Это полезно для указания параметров, для которых нет отдельного
             флага командной строки. Для получения полной информации о параметрах,
             перечисленных ниже, и их возможных значений, смотри ssh_config(5).
@display
      @ref{man_ssh_ssh_config AddKeysToAgent,, AddKeysToAgent}
      @ref{man_ssh_ssh_config AddressFamily,, AddressFamily}
      @ref{man_ssh_ssh_config BatchMode,, BatchMode}
      @ref{man_ssh_ssh_config BindAddress,, BindAddress}
      @ref{man_ssh_ssh_config CanonicalDomains,, CanonicalDomains}
      @ref{man_ssh_ssh_config CanonicalizeFallbackLocal,, CanonicalizeFallbackLocal}
      @ref{man_ssh_ssh_config CanonicalizeHostname,, CanonicalizeHostname}
      @ref{man_ssh_ssh_config CanonicalizeMaxDots,, CanonicalizeMaxDots}
      @ref{man_ssh_ssh_config CanonicalizePermittedCNAMEs,, CanonicalizePermittedCNAMEs}
      @ref{man_ssh_ssh_config CertificateFile,, CertificateFile}
      @ref{man_ssh_ssh_config ChallengeResponseAuthentication,, ChallengeResponseAuthentication}
      @ref{man_ssh_ssh_config CheckHostIP,, CheckHostIP}
      @ref{man_ssh_ssh_config Cipher,, Cipher}
      @ref{man_ssh_ssh_config Ciphers,, Ciphers}
      @ref{man_ssh_ssh_config ClearAllForwardings,, ClearAllForwardings}
      @ref{man_ssh_ssh_config Compression,, Compression}
      @ref{man_ssh_ssh_config CompressionLevel,, CompressionLevel}
      @ref{man_ssh_ssh_config ConnectionAttempts,, ConnectionAttempts}
      @ref{man_ssh_ssh_config ConnectTimeout,, ConnectTimeout}
      @ref{man_ssh_ssh_config ControlMaster,, ControlMaster}
      @ref{man_ssh_ssh_config ControlPath,, ControlPath}
      @ref{man_ssh_ssh_config ControlPersist,, ControlPersist}
      @ref{man_ssh_ssh_config DynamicForward,, DynamicForward}
      @ref{man_ssh_ssh_config EscapeChar,, EscapeChar}
      @ref{man_ssh_ssh_config ExitOnForwardFailure,, ExitOnForwardFailure}
      @ref{man_ssh_ssh_config FingerprintHash,, FingerprintHash}
      @ref{man_ssh_ssh_config ForwardAgent,, ForwardAgent}
      @ref{man_ssh_ssh_config ForwardX11,, ForwardX11}
      @ref{man_ssh_ssh_config ForwardX11Timeout,, ForwardX11Timeout}
      @ref{man_ssh_ssh_config ForwardX11Trusted,, ForwardX11Trusted}
      @ref{man_ssh_ssh_config GatewayPorts,, GatewayPorts}
      @ref{man_ssh_ssh_config GlobalKnownHostsFile,, GlobalKnownHostsFile}
      @ref{man_ssh_ssh_config GSSAPIAuthentication,, GSSAPIAuthentication}
      @ref{man_ssh_ssh_config GSSAPIDelegateCredentials,, GSSAPIDelegateCredentials}
      @ref{man_ssh_ssh_config HashKnownHosts,, HashKnownHosts}
      @ref{man_ssh_ssh_config Host,, Host}
      @ref{man_ssh_ssh_config HostbasedAuthentication,, HostbasedAuthentication}
      @ref{man_ssh_ssh_config HostbasedKeyTypes,, HostbasedKeyTypes}
      @ref{man_ssh_ssh_config HostKeyAlgorithms,, HostKeyAlgorithms}
      @ref{man_ssh_ssh_config HostKeyAlias,, HostKeyAlias}
      @ref{man_ssh_ssh_config HostName,, HostName}
      @ref{man_ssh_ssh_config IdentityFile,, IdentityFile}
      @ref{man_ssh_ssh_config IdentitiesOnly,, IdentitiesOnly}
      @ref{man_ssh_ssh_config IPQoS,, IPQoS}
      @ref{man_ssh_ssh_config KbdInteractiveAuthentication,, KbdInteractiveAuthentication}
      @ref{man_ssh_ssh_config KbdInteractiveDevices,, KbdInteractiveDevices}
      @ref{man_ssh_ssh_config KexAlgorithms,, KexAlgorithms}
      @ref{man_ssh_ssh_config LocalCommand,, LocalCommand}
      @ref{man_ssh_ssh_config LocalForward,, LocalForward}
      @ref{man_ssh_ssh_config LogLevel,, LogLevel}
      @ref{man_ssh_ssh_config MACs,, MACs}
      @ref{man_ssh_ssh_config Match,, Match}
      @ref{man_ssh_ssh_config NoHostAuthenticationForLocalhost,, NoHostAuthenticationForLocalhost}
      @ref{man_ssh_ssh_config NumberOfPasswordPrompts,, NumberOfPasswordPrompts}
      @ref{man_ssh_ssh_config PasswordAuthentication,, PasswordAuthentication}
      @ref{man_ssh_ssh_config PermitLocalCommand,, PermitLocalCommand}
      @ref{man_ssh_ssh_config PKCS11Provider,, PKCS11Provider}
      @ref{man_ssh_ssh_config Port,, Port}
      @ref{man_ssh_ssh_config PreferredAuthentications,, PreferredAuthentications}
      @ref{man_ssh_ssh_config Protocol,, Protocol}
      @ref{man_ssh_ssh_config ProxyCommand,, ProxyCommand}
      @ref{man_ssh_ssh_config ProxyUseFdpass,, ProxyUseFdpass}
      @ref{man_ssh_ssh_config PubkeyAcceptedKeyTypes,, PubkeyAcceptedKeyTypes}
      @ref{man_ssh_ssh_config PubkeyAuthentication,, PubkeyAuthentication}
      @ref{man_ssh_ssh_config RekeyLimit,, RekeyLimit}
      @ref{man_ssh_ssh_config RemoteForward,, RemoteForward}
      @ref{man_ssh_ssh_config RequestTTY,, RequestTTY}
      @ref{man_ssh_ssh_config RhostsRSAAuthentication,, RhostsRSAAuthentication}
      @ref{man_ssh_ssh_config RSAAuthentication,, RSAAuthentication}
      @ref{man_ssh_ssh_config SendEnv,, SendEnv}
      @ref{man_ssh_ssh_config ServerAliveInterval,, ServerAliveInterval}
      @ref{man_ssh_ssh_config ServerAliveCountMax,, ServerAliveCountMax}
      @ref{man_ssh_ssh_config StreamLocalBindMask,, StreamLocalBindMask}
      @ref{man_ssh_ssh_config StreamLocalBindUnlink,, StreamLocalBindUnlink}
      @ref{man_ssh_ssh_config StrictHostKeyChecking,, StrictHostKeyChecking}
      @ref{man_ssh_ssh_config TCPKeepAlive,, TCPKeepAlive}
      @ref{man_ssh_ssh_config Tunnel,, Tunnel}
      @ref{man_ssh_ssh_config TunnelDevice,, TunnelDevice}
      @ref{man_ssh_ssh_config UpdateHostKeys,, UpdateHostKeys}
      @ref{man_ssh_ssh_config UsePrivilegedPort,, UsePrivilegedPort}
      @ref{man_ssh_ssh_config User,, User}
      @ref{man_ssh_ssh_config UserKnownHostsFile,, UserKnownHostsFile}
      @ref{man_ssh_ssh_config VerifyHostKeyDNS,, VerifyHostKeyDNS}
      @ref{man_ssh_ssh_config VisualHostKey,, VisualHostKey}
      @ref{man_ssh_ssh_config XAuthLocation,, XAuthLocation}

@end display
@item     -p port @anchor{man_ssh_ssh -p port}
             Порт для подключения на удаленном хосте. Это может быть указано для
             каждого хоста в файле конфигурации.

@item     -Q query_option @anchor{man_ssh_ssh -Q query_option}
             Запрашивает ssh для алгоритмов, поддерживаемых для указанной версии 2.
             Доступные функции:
@display
             cipher (поддерживаемые симметричные шифры),
             cipher-auth (поддерживаемые симметричные шифры, которые поддерживают
             аутентифицированное шифрование),
             mac (поддерживаемые коды целостности сообщений),
             kex (алгоритмы обмена ключами) ),
             key (типы ключей),
             key-cert (типы ключей сертификатов),
             key-plain (типы ключей без сертификатов) и
             protocol-version (поддерживаемые версии протокола SSH).
@end display
@item     -q @anchor{man_ssh_ssh q}
             Бесшумный режим. Вызывает подавление большинства предупреждений и
             диагностических сообщений.
@item Перенаправление удаленного соединения @anchor{man_ssh_ssh Перенаправление удаленного соединения}
@display
     -R [bind_address:]port:host:hostport
     -R [bind_address:]port:local_socket
     -R remote_socket:host:hostport
     -R remote_socket:local_socket
@end display
             Указывает, что соединения с указанным портом TCP или сокетом Unix на
             удаленном (серверном) хосте должны перенаправляться на данный хост и порт
             или сокет Unix на локальной стороне. Это работает путем выделения сокета
             для прослушивания либо порта TCP, либо сокета Unix на удаленной стороне.
             Всякий раз, когда устанавливается соединение с этим портом или сокетом Unix,
             соединение перенаправляется по безопасному каналу, и соединение
             устанавливается либо с хост-портом хоста, либо с local_socket с
             локальной машины.

             Переадресация портов также может быть указана в файле конфигурации.
             Привилегированные порты могут быть перенаправлены только при входе в систему
             как root на удаленной машине. Адреса IPv6 можно указать, заключив адрес
             в квадратные скобки.

             По умолчанию прослушивающие сокеты TCP на сервере будут привязаны только
             к интерфейсу обратной связи. Это может быть отменено указанием bind_address.
             Пустой bind_address или адрес ‘*’ указывает, что удаленный сокет должен
             прослушивать все интерфейсы. Задание удаленного bind_address будет успешным,
             только если включена опция GatewayPorts на сервере(смотри sshd_config(5)).

             Если аргумент порта - ‘0’, порт прослушивания будет динамически выделяться
             на сервере и сообщаться клиенту во время выполнения. При использовании
             вместе с -O forward выделенный порт будет выведен на стандартный вывод.

@item     -S ctl_path @anchor{man_ssh_ssh -S ctl_path}
             Определяет расположение управляющего сокета для разделения соединений или
             строку “none” для отключения совместного использования соединений.
             Обратитесь к описанию ControlPath и ControlMaster в
             ssh_config(5) для деталей.

@item     -s @anchor{man_ssh_ssh s}
             Может использоваться для запроса вызова подсистемы в удаленной системе.
             Подсистемы облегчают использование SSH в качестве безопасного транспорта
             для других приложений (например, sftp(1)). Подсистема указана как
             удаленная команда.

@item     -T @anchor{man_ssh_ssh T}
             Отключить выделение псевдо-терминала.

@item     -t @anchor{man_ssh_ssh t}
             Принудительное псевдо-терминальное размещение. Это может использоваться
             для выполнения произвольных программ на экране на удаленном компьютере,
             что может быть очень полезным, например, при реализации сервисов меню.
             Несколько опций -t вызывают распределение tty, даже если ssh не имеет
             локального tty.

@item     -V @anchor{man_ssh_ssh V}
             Показать номер версии и выйти.

@item     -v @anchor{man_ssh_ssh v}
             Детальный режим. Заставляет ssh печатать отладочные сообщения о его
             ходе. Это полезно при отладке проблем с подключением, аутентификацией
             и настройкой. Несколько опций -v увеличивают многословие. Максимум 3.

@item     -W host:port @anchor{man_ssh_ssh -W host:port}
             Просит, чтобы стандартный ввод и вывод на клиенте был перенаправлен на хост
             через порт по безопасному каналу. Подразумевает -N, -T, ExitOnForwardFailure
             и ClearAllForwardings.

@item     -w local_tun[:remote_tun] @anchor{man_ssh_ssh -w local_tun[:remote_tun]}
             Запрашивает переадресацию туннельных устройств с указанными устройствами
             tun(4) между клиентом (local_tun) и сервером (remote_tun).

             Устройства могут быть указаны с помощью числового идентификатора или
             ключевого слова “any”, которое использует следующее доступное туннельное
             устройство. Если remote_tun не указан, по умолчанию используется “any”.
             См. Также директивы Tunnel и TunnelDevice в ssh_config(5). Если директива
             Tunnel не установлена, она устанавливается в режим туннеля по умолчанию,
             то есть “point-to-point”.

@item     -X @anchor{man_ssh_ssh X}
             Включает пересылку X11. Это также может быть указано для каждого хоста
             в файле конфигурации.

             Пересылка X11 должна быть включена с осторожностью. Пользователи с
             возможностью обхода прав доступа к файлам на удаленном хосте (для базы
             данных авторизации X пользователя) могут получить доступ к локальному
             дисплею X11 через переадресованное соединение. Затем злоумышленник сможет
             выполнять такие действия, как мониторинг нажатия клавиш.

             По этой причине пересылка X11 по умолчанию ограничена расширением
             X11 SECURITY. Пожалуйста, обратитесь к опции ssh -Y и директиве
             ForwardX11Trusted в ssh_config(5) для получения
             дополнительной информации.

             (Специфично для Debian: на пересылку X11 по умолчанию не распространяются
             ограничения расширения X11 SECURITY, поскольку в этом режиме в настоящий
             момент происходит сбой слишком многих программ. Установите для параметра
             ForwardX11Trusted значение “no”, чтобы восстановить поведение восходящего
             потока. Это может измениться в будущем в зависимости от клиента. побочные
             улучшения.)

@item     -x @anchor{man_ssh_ssh x}
             Отключает пересылку X11.

@item     -Y @anchor{man_ssh_ssh Y}
             Включает доверенную пересылку X11. Переадресация доверенных X11 не
             контролируется расширением X11 SECURITY.

             (Специфично для Debian: эта опция ничего не делает в конфигурации по
             умолчанию: она эквивалентна “ForwardX11Trusted yes”, который является
             значением по умолчанию, как описано выше. Установите параметр
             ForwardX11Trusted в “no”, чтобы восстановить поведение восходящего потока.
             Это может измениться в будущем в зависимости от клиента усовершенствования.)

@item     -y @anchor{man_ssh_ssh y}
             Отправьте информацию журнала с помощью системного модуля syslog(3). По
             умолчанию эта информация отправляется в stderr.

     ssh может дополнительно получить данные конфигурации из файла конфигурации для
     каждого пользователя и общесистемного файла конфигурации. Формат файла и параметры
     конфигурации описаны в ssh_config (5).
@end table
@item AUTHENTICATION
     SSSS-клиент OpenSSH поддерживает протоколы SSH 1 и 2. По умолчанию
     используется только протокол 2, хотя это можно изменить с помощью
     параметра Protocol в параметрах ssh_config(5) или -1 и -2 (см. Выше).
     Протокол 1 не должен использоваться и предлагается только для поддержки
     устаревших устройств. Он страдает от ряда криптографических недостатков и
     не поддерживает многие расширенные функции, доступные для протокола 2.

     Для аутентификации доступны следующие методы: аутентификация на основе
     GSSAPI, аутентификация на основе хоста, аутентификация с открытым ключом,
     аутентификация по запросу и аутентификации по паролю. Методы аутентификации
     пробуются в указанном выше порядке, хотя PreferredAuthentications может
     использоваться для изменения порядка по умолчанию.

     Аутентификация на основе хоста работает следующим образом: если машина,
     с которой пользователь входит в систему, указана в списке /etc/hosts.equiv
     или /etc/ssh/shosts.equiv на удаленном компьютере, а имена пользователей
     совпадают с обеих сторон или если файлы ~/.rhosts или ~/.shosts существуют
     в домашнем хранилище пользователя каталог на удаленном компьютере и содержит
     строку, содержащую имя клиентского компьютера и имя пользователя на этом
     компьютере, пользователь считается для входа в систему. Кроме того, сервер
     должен иметь возможность проверять ключ хоста клиента (см. Описание
     /etc/ssh/ssh_known_hosts и ~/.ssh/known_hosts ниже), чтобы разрешить вход
     в систему. Этот метод аутентификации закрывает дыры в безопасности из-за
     спуфинга IP, спуфинга DNS и спуфинга маршрутизации. [Примечание для
     администратора: /etc/hosts.equiv, ~/.rhosts и протокол rlogin/rsh в целом
     являются изначально опасными и должны быть отключены, если требуется
     безопасность.]

     Аутентификация с открытым ключом работает следующим образом: схема основана
     на криптографии с открытым ключом, использующей криптосистемы, где шифрование
     и дешифрование выполняются с использованием отдельных ключей, и невозможно
     получить ключ дешифрования из ключа шифрования. Идея состоит в том, что каждый
     пользователь создает пару открытый/закрытый ключ для аутентификации. Сервер
     знает открытый ключ, и только пользователь знает закрытый ключ. ssh
     автоматически реализует протокол аутентификации с открытым ключом, используя
     один из алгоритмов DSA, ECDSA, Ed25519 или RSA. Раздел HISTORY в ssl(8)
     (на не-OpenBSD системах,  смотри
     http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&sektion=8#HISTORY) содержит
     краткое обсуждение алгоритмов DSA и RSA.

     В файле ~/.ssh/authorized_keys перечислены открытые ключи, которые разрешены
     для входа. Когда пользователь входит в систему, программа ssh сообщает серверу,
     какую пару ключей он хотел бы использовать для аутентификации. Клиент подтверждает,
     что у него есть доступ к закрытому ключу, а сервер проверяет, разрешено ли
     соответствующему открытому ключу принять учетную запись.

     Пользователь создает свою пару ключей, запустив ssh-keygen(1). Это хранит закрытый
     ключ в:
@display
           ~/.ssh/identity (protocol 1),
           ~/.ssh/id_dsa (DSA),
           ~/.ssh/id_ecdsa (ECDSA),
           ~/.ssh/id_ed25519 (Ed25519), или
           ~/.ssh/id_rsa (RSA)

     и хранит открытый ключ в:
           ~/.ssh/identity.pub (protocol 1),
           ~/.ssh/id_dsa.pub (DSA),
           ~/.ssh/id_ecdsa.pub (ECDSA),
           ~/.ssh/id_ed25519.pub (Ed25519), или
           ~/.ssh/id_rsa.pub (RSA)
@end display
     в домашнем каталоге пользователя. Затем пользователь должен скопировать
     открытый ключ в ~/.ssh/authorized_keys в своем домашнем каталоге на
     удаленном компьютере. Файл author_keys соответствует обычному ~/.rhosts file
     и имеет один ключ на строку, хотя строки могут быть очень длинными. После
     этого пользователь может войти без указания пароля.

     Вариант аутентификации с открытым ключом доступен в форме аутентификации: вместо
     набора открытых/закрытых ключей используются подписанные сертификаты. Преимущество
     этого заключается в том, что вместо многих открытых/закрытых ключей можно
     использовать один доверенный центр сертификации. См. Раздел CERTIFICATES в
     ssh-keygen(1) для получения дополнительной информации.

     Наиболее удобный способ использовать открытый ключ или проверку подлинности
     сертификата может быть с агентом проверки подлинности. См. Ssh-agent (1) и
     (необязательно) директиву AddKeysToAgent в ssh_config(5) для получения
     дополнительной информации.

     Аутентификация по запросу-ответу работает следующим образом: сервер
     отправляет произвольный текст "challenge" и запрашивает ответ. Примеры
     аутентификации «запрос-ответ» включают BSD Authentication (см. login.conf(5))
     и PAM (некоторые не-OpenBSD системы).

     Наконец, в случае сбоя других методов аутентификации ssh запрашивает у
     пользователя пароль. Пароль отправляется на удаленный хост для проверки;
     однако, так как все коммуникации зашифрованы, пароль не может быть виден
     кем-то, кто слушает в сети.

     ssh автоматически поддерживает и проверяет базу данных, содержащую идентификацию
     всех хостов, с которыми она когда-либо использовалась. Ключи хоста хранятся в
     ~/.ssh/known_hosts в домашнем каталоге пользователя. Кроме того, файл
     /etc/ssh/ssh_known_hosts автоматически проверяется на наличие известных хостов.
     Любые новые хосты автоматически добавляются в файл пользователя.  Если
     идентификация хоста когда-либо изменяется, ssh предупреждает об этом и
     отключает аутентификацию по паролю, чтобы предотвратить подделку сервера или
     атаки «человек посередине», которые в противном случае могли бы использоваться
     для обхода шифрования. Опция StrictHostKeyChecking может использоваться
     для управления входами в систему на компьютерах, ключ хоста которых
     неизвестен или изменился.

     Когда идентификация пользователя была принята сервером, сервер либо
     выполняет данную команду в неинтерактивном сеансе, либо, если команда
     не указана, входит в систему на компьютере и предоставляет пользователю
     обычную оболочку в виде интерактивного сеанса. Вся связь с удаленной
     командой или оболочкой будет автоматически зашифрована.

     Если интерактивный сеанс запрашивается, ssh по умолчанию будет запрашивать
     псевдотерминал (pty) только для интерактивных сеансов, когда он у клиента.
     Флаги -T и -t могут быть использованы для переопределения этого поведения.

     Если псевдотерминал был выделен, пользователь может использовать escape-символы,
     указанные ниже.

     Если псевдотерминал не был выделен, сеанс прозрачен и может использоваться
     для надежной передачи двоичных данных. В большинстве систем установка
     escape-символа “none” также сделает сеанс прозрачным, даже если
     используется tty.

     Сеанс завершается, когда команда или оболочка на удаленной машине завершаются,
     и все соединения X11 и TCP были закрыты.

@item ESCAPE CHARACTERS
     Когда запрашивается псевдотерминал, ssh поддерживает ряд функций, используя
     escape-символ.

     Один символ тильды может быть отправлен как ~~ или после тильды за символом,
     отличным от описанного ниже. Экранирующий символ всегда должен следовать за
     новой строкой, чтобы интерпретироваться как специальный. Экранирующий символ
     может быть изменен в файлах конфигурации с помощью директивы конфигурации
     EscapeChar или в командной строке с помощью опции -e.

     Поддерживаемое экранирование (при условии использования ‘~’ по умолчанию):
@table @asis
@item    ~.
             Отключить.

@item     ~^Z
             SSH в фоновом режиме.

@item     ~#
             Список переадресованных соединений.

@item     ~&
             Фоновый ssh ​​при выходе из системы при ожидании завершения сеансов
             переадресованного соединения/X11.

@item     ~?
             Показать список escape-символов.

@item     ~B
             Отправьте BREAK в удаленную систему (полезно только в том случае, если
             узел поддерживает его).

@item     ~C
             Откройте командную строку. В настоящее время это позволяет добавлять
             переадресацию портов с использованием параметров -L, -R и -D (см. Выше).
             Это также позволяет отменять существующие переадресации портов с помощью:
@display
             -KL[bind_address:]port для локальных,
             -KR[bind_address:]port для удаленных и
             -KD[bind_address:]port для динамических переадресаций портов.
@end display
             !command позволяет пользователю выполнять локальную команду, если в
             ssh_config(5) включена опция PermitLocalCommand. Базовая помощь
             доступна с использованием опции -h.

@item     ~R
             Запросить повторное соединение (полезно, только если узел поддерживает его).

@item     ~V
             Уменьшите детализацию (LogLevel), когда ошибки записываются в stderr.

@item     ~v
             Увеличьте детализацию (LogLevel), когда ошибки записываются в stderr.
@end table
@item TCP FORWARDING
     Пересылка произвольных TCP-соединений по безопасному каналу может быть указана
     либо в командной строке, либо в файле конфигурации. Одним из возможных применений
     пересылки TCP является защищенное соединение с почтовым сервером; другой проходит
     через брандмауэры.

     В приведенном ниже примере мы рассмотрим шифрование связи между клиентом и
     сервером IRC, даже если сервер IRC не поддерживает напрямую зашифрованную связь.
     Это работает следующим образом: пользователь подключается к удаленному хосту,
     используя ssh, указывая порт, который будет использоваться для переадресации
     соединений на удаленный сервер. После этого можно запустить службу, которая
     должна быть зашифрована на клиентском компьютере, подключаясь к тому же
     локальному порту, и ssh зашифрует и перешлет соединение.

     В следующем примере туннелируется сеанс IRC с клиентского компьютера
     “127.0.0.1” (localhost) на удаленный сервер “server.example.com”:
@display
         $ ssh -f -L 1234:localhost:6667 server.example.com sleep 10
         $ irc -c '#users' -p 1234 pinky 127.0.0.1
@end display
     Это туннелирует соединение с IRC-сервером “server.example.com”, соединяя
     канал “#users” с псевдонимом «pinky», используя порт 1234. Неважно, какой
     порт используется, если он больше 1023 (помните, только root может открывать
     сокеты на привилегированных портах ) и не конфликтует с портами, которые
     уже используются. Соединение перенаправляется на порт 6667 на удаленном
     сервере, поскольку это стандартный порт для служб IRC.

     Опция -f запускает в фоне ssh и удаленную команду “sleep 10”, чтобы дать время
     (10 секунд, в примере) для запуска службы, которая должна быть туннелирована.
     Если в течение указанного времени соединения не установлены, ssh завершит работу.

@item X11 FORWARDING
     Если для переменной ForwardX11 установлено значение “yes” (или см. Описание
     параметров -X, -x, и -Y выше), а пользователь использует X11 (установлена ​​
     переменная окружения DISPLAY), соединение с дисплеем X11 автоматически
     перенаправляется на удаленную сторону таким образом, что любые программы X11,
     запущенные из оболочки (или команды), будут проходить через зашифрованный
     канал, а соединение с реальным сервером X будет осуществляться с локальной
     машины. Пользователь не должен вручную устанавливать DISPLAY. Переадресацию
     соединений X11 можно настроить в командной строке или в файлах конфигурации.

     Значение DISPLAY, установленное ssh, будет указывать на сервер, но с
     номером дисплея больше нуля. Это нормально и происходит потому, что
     ssh создает сервер “proxy” X на сервере для пересылки соединений по
     зашифрованному каналу.

     ssh также автоматически настроит данные Xauthority на компьютере сервера. Для
     этого он сгенерирует случайный cookie-файл авторизации, сохранит его в
     Xauthority на сервере и проверит, что все переадресованные соединения содержат
     этот cookie-файл, и заменит его реальным cookie-файлом при открытии соединения.
     Настоящий куки-файл аутентификации никогда не отправляется на сервер (и в
     обычном режиме куки не отправляются).

     Если для переменной ForwardAgent задано значение “yes” (или см. Описание
     параметров -A и -a выше) и пользователь использует агент аутентификации,
     соединение с агентом автоматически перенаправляется на удаленную сторону.

@item VERIFYING HOST KEYS
     При первом подключении к серверу пользователю предоставляется отпечаток
     открытого ключа сервера (если не включена опция StrictHostKeyChecking).
     Отпечатки ключа могут быть определены с помощью ssh-keygen(1):
@display
           $ ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key
@end display
     Если отпечаток ключа уже известен, его можно сопоставить, а ключ можно принять
     или отклонить. Если для сервера доступны только устаревшие (MD5) отпечатки
     ключей, можно использовать опцию ssh-keygen (1) -E для понижения алгоритма
     идентификации для соответствия.

     Из-за сложности сравнения ключей хоста, просто взглянув на строки отпечатка ключа,
     существует также поддержка визуального сравнения ключей хоста с использованием
     произвольной графики. Если для параметра VisualHostKey установлено значение “yes”,
     при каждом входе на сервер небольшое изображение ASCII отображается независимо от
     того, является ли сеанс интерактивным или нет. Изучая шаблон, который создает
     известный сервер, пользователь может легко обнаружить, что ключ хоста изменился,
     когда отображается совершенно другой шаблон. Однако, поскольку эти шаблоны не
     являются однозначными, шаблон, который похож на запомненный шаблон, только дает
     хорошую вероятность того, что ключ хоста является тем же, а не гарантированным
     доказательством.

     Чтобы получить список отпечатков ключей и их случайный рисунок для всех
     известных хостов, можно использовать следующую командную строку:
@display
           $ ssh-keygen -lv -f ~/.ssh/known_hosts
@end display
     Если отпечаток пальца неизвестен, доступен альтернативный метод проверки: отпечатки
     ключей SSH проверяются DNS. Дополнительная запись ресурса (RR), SSHFP, добавляется
     в файл зоны, и подключающийся клиент может сопоставить отпечаток с указанным ключом.

     В этом примере мы подключаем клиента к серверу “host.example.com”. Записи
     ресурса SSHFP сначала должны быть добавлены в файл зоны для host.example.com:
@display
           $ ssh-keygen -r host.example.com.
@end display
     Выходные строки должны быть добавлены в файл зоны. Чтобы убедиться, что зона
     отвечает на запросы отпечатков ключей:
@display
           $ dig -t SSHFP host.example.com
@end display
     Наконец клиент подключается:
@display
           $ ssh -o "VerifyHostKeyDNS ask" host.example.com
           [...]
           Matching host key fingerprint found in DNS.
           Are you sure you want to continue connecting (yes/no)?
           (Соответствующий отпечаток ключа хоста найден в DNS. Вы
           уверены, что хотите продолжить подключение (да/нет)?)
@end display
     См. Параметр VerifyHostKeyDNS в ssh_config(5) для получения
     дополнительной информации.

@item SSH-BASED VIRTUAL PRIVATE NETWORKS
     ssh поддерживает туннелирование виртуальной частной сети (VPN) с использованием
     псевдоустройства tun(4), что позволяет безопасно соединять две сети. Параметр
     конфигурации sshd_config (5) PermitTunnel контролирует, поддерживает ли сервер
     это и на каком уровне (трафик уровня 2 или 3).

     В следующем примере клиентская сеть 10.0.50.0/24 соединяется с удаленной сетью
     10.0.99.0/24, используя двухточечное соединение от 10.1.1.1 до 10.1.1.2, при
     условии, что сервер SSH, работающий на шлюзе с удаленной сетью на 192.168.1.15,
     разрешает это.

     На клиенте:
@display
           # ssh -f -w 0:1 192.168.1.15 true
           # ifconfig tun0 10.1.1.1 10.1.1.2 netmask 255.255.255.252
           # route add 10.0.99.0/24 10.1.1.2
@end display
     На сервере:
@display
           # ifconfig tun1 10.1.1.2 10.1.1.1 netmask 255.255.255.252
           # route add 10.0.50.0/24 10.1.1.1
@end display
     Клиентский доступ может быть более точно настроен с помощью файла
     /root/.ssh/authorized_keys (см. Ниже) и опции сервера PermitRootLogin.
     Следующая запись разрешает соединения на устройстве tun (4) 1 от
     пользователя “jane” и на устройстве tun 2 от пользователя “john”,
     если для PermitRootLogin установлено значение “forced-commands-only”:
@display
       tunnel="1",command="sh /etc/netstart tun1" ssh-rsa ... jane
       tunnel="2",command="sh /etc/netstart tun2" ssh-rsa ... john
@end display
     Поскольку настройка на основе SSH влечет за собой значительные издержки,
     она может быть более подходящей для временных настроек, таких как
     беспроводные VPN. Больше постоянных VPN лучше предоставляют такие
     инструменты, как ipsecctl(8) и isakmpd(8).

@item ENVIRONMENT
     ssh обычно устанавливает следующие переменные окружения:
@table @asis
@item     DISPLAY @anchor{man_ssh_peremen_okruj DISPLAY}
                           Переменная DISPLAY указывает местоположение
                           сервера X11. Он автоматически устанавливает ssh
                           для указания значения в форме “hostname:n”, где
                           “hostname” указывает хост, на котором работает
                           оболочка, а ‘n’ - целое число ≥ 1. ssh использует
                           как специальное значение для пересылки соединений X11
                           по защищенному каналу. Пользователь обычно не должен явно
                           устанавливать DISPLAY, так как это сделает соединение X11
                           небезопасным (и потребует от пользователя вручную
                           скопировать все необходимые куки авторизации).

@item     HOME @anchor{man_ssh_peremen_okruj HOME}
                           Установите путь к домашнему каталогу пользователя.

@item     LOGNAME @anchor{man_ssh_peremen_okruj LOGNAME}
                           Синоним для USER; установить для совместимости с
                           системами, которые используют эту переменную.

@item       MAIL @anchor{man_ssh_peremen_okruj MAIL}
                           Установите путь к почтовому ящику пользователя.

@item     PATH @anchor{man_ssh_peremen_okruj PATH}
                           Установите значение по умолчанию PATH, как указано при
                           компиляции ssh.

@item     SSH_ASKPASS @anchor{man_ssh_peremen_okruj SSH_ASKPASS}
                           Если ssh требуется фраза-пароль, она будет считывать
                           фразу-пароль с текущего терминала, если она была запущена
                           с терминала. Если ssh не имеет связанного с ним терминала,
                           но установлены DISPLAY и SSH_ASKPASS, он выполнит программу,
                           указанную SSH_ASKPASS, и откроет окно X11, чтобы прочитать
                           фразу-пароль. Это особенно полезно при вызове ssh из
                           .xsession или связанного скрипта. (Обратите внимание, что
                           на некоторых машинах может потребоваться перенаправить ввод
                           с /dev/null для выполнения этой работы.)

@item     SSH_AUTH_SOCK @anchor{man_ssh_peremen_okruj SSH_AUTH_SOCK}
                           Определяет путь к сокету UNIX-домена, используемому
                           для связи с агентом.

@item     SSH_CONNECTION @anchor{man_ssh_peremen_okruj SSH_CONNECTION}
                           Определяет клиентскую и серверную стороны соединения.
                           Переменная содержит четыре значения, разделенных пробелом:
                           IP-адрес клиента, номер порта клиента, IP-адрес сервера и
                           номер порта сервера.

@item     SSH_ORIGINAL_COMMAND @anchor{man_ssh_peremen_okruj SSH_ORIGINAL_COMMAND}
                           Эта переменная содержит исходную командную строку, если
                           выполняется принудительная команда. Может использоваться
                           для извлечения исходных аргументов.

@item     SSH_TTY @anchor{man_ssh_peremen_okruj SSH_TTY}
                           Для него задается имя tty (путь к устройству), связанного с
                           текущей оболочкой или командой. Если текущий сеанс не имеет
                           tty, эта переменная не установлена.

@item     TZ @anchor{man_ssh_peremen_okruj TZ}
                           Эта переменная указывает текущую часовую зону, если она
                           была установлена ​​при запуске демона (то есть демон передает
                           значение новым соединениям).

@item     USER @anchor{man_ssh_peremen_okruj USER}
                           Установите имя пользователя, входящего в систему.
@end table
     Кроме того, ssh читает ~/.ssh/environment и добавляет строки формата
     “VARNAME=value” в среду, если файл существует, и пользователям разрешено
     изменять свою среду. Для получения дополнительной информации см. Параметр
     PermitUserEnvironment в sshd_config(5).

@item FILES
@table @asis
@item     ~/.rhosts @anchor{man_ssh_peremen_okruj ~/.rhosts}
             Этот файл используется для аутентификации на основе хоста (см. Выше). На
             некоторых машинах этот файл может потребоваться для чтения всем, если
             домашний каталог пользователя находится в разделе NFS, потому что sshd(8)
             читает его как root. Кроме того, этот файл должен принадлежать пользователю
             и не должен иметь права на запись для кого-либо еще. Рекомендуемое
             разрешение для большинства машин - чтение и запись для пользователя
             и недоступно для других.

@item     ~/.shosts @anchor{man_ssh_peremen_okruj ~/.shosts}
             Этот файл используется точно так же, как .rhosts, но разрешает
             аутентификацию на основе хоста без разрешения входа с помощью rlogin/rsh.

@item     ~/.ssh/ @anchor{man_ssh_peremen_okruj ~/.ssh/}
             Этот каталог является местоположением по умолчанию для всей
             пользовательской информации о конфигурации и аутентификации. Не
             существует общего требования хранить все содержимое этого каталога
             в секрете, но рекомендуемые разрешения чтения/записи/выполнения для
             пользователя и недоступны для других.

@item     ~/.ssh/authorized_keys @anchor{man_ssh_peremen_okruj ~/.ssh/authorized_keys}
             Перечисляет открытые ключи (DSA, ECDSA, Ed25519, RSA), которые можно
             использовать для входа в систему от имени этого пользователя. Формат
             этого файла описан на странице руководства sshd(8). Этот файл не
             является высокочувствительным, но рекомендуемые разрешения для чтения
             и записи для пользователя и недоступны для других.

@item     ~/.ssh/config @anchor{man_ssh_peremen_okruj ~/.ssh/config}
             Это файл конфигурации для каждого пользователя. Формат файла и параметры
             конфигурации описаны в ssh_config(5). Из-за возможного злоупотребления
             этот файл должен иметь строгие разрешения: чтение/запись для пользователя
             и недоступность для записи другими. Это может быть доступно для записи
             в группе при условии, что рассматриваемая группа содержит только пользователя.

@item     ~/.ssh/environment @anchor{man_ssh_peremen_okruj ~/.ssh/environment}
             Содержит дополнительные определения для переменных среды;
             см. ENVIRONMENT, выше.
@item Файлы закрытых частей ключа аунтификации @anchor{man_ssh_peremen_okruj Файлы закрытых частей ключа аунтификации}
@display
     ~/.ssh/identity
     ~/.ssh/id_dsa
     ~/.ssh/id_ecdsa
     ~/.ssh/id_ed25519
     ~/.ssh/id_rsa
@end display
             Содержит закрытый ключ для аутентификации. Эти файлы содержат
             конфиденциальные данные и должны быть доступны для чтения
             пользователем, но недоступны для других (чтение/запись/выполнение).
             ssh просто проигнорирует файл закрытого ключа, если он доступен другим.
             Можно указать ключевую фразу при создании ключа, который будет
             использоваться для шифрования конфиденциальной части этого файла
             с использованием 3DES.
@item Файлы открытой части ключа аунтификации @anchor{man_ssh_peremen_okruj Файлы открытой части ключа аунтификации}
@display
     ~/.ssh/identity.pub
     ~/.ssh/id_dsa.pub
     ~/.ssh/id_ecdsa.pub
     ~/.ssh/id_ed25519.pub
     ~/.ssh/id_rsa.pub
@end display
             Содержат открытый ключ для аутентификации. Эти файлы не являются
             конфиденциальными и могут (но не обязательно) быть доступными для
             чтения любому.

@item     ~/.ssh/known_hosts @anchor{man_ssh_peremen_okruj ~/.ssh/known_hosts}
             Содержит список ключей хоста для всех хостов, в которые вошел пользователь,
             которых еще нет в общесистемном списке известных ключей хоста. Смотрите
             sshd(8) для более подробной информации о формате этого файла.

@item     ~/.ssh/rc @anchor{man_ssh_peremen_okruj ~/.ssh/rc}
             Команды в этом файле выполняются ssh, когда пользователь входит в систему,
             непосредственно перед запуском оболочки пользователя (или команды).
             Обратитесь к странице справочника sshd(8) за дополнительной информацией.

@item     /etc/hosts.equiv @anchor{man_ssh_peremen_okruj /etc/hosts.equiv}
             Этот файл предназначен для аутентификации на основе хоста (см. Выше). Это
             должно быть доступно для записи только пользователю root.

@item     /etc/ssh/shosts.equiv @anchor{man_ssh_peremen_okruj /etc/ssh/shosts.equiv}
             Этот файл используется точно так же, как hosts.equiv, но допускает
             аутентификацию на основе хоста без разрешения входа с помощью
             rlogin/rsh.

@item     /etc/ssh/ssh_config @anchor{man_ssh_peremen_okruj /etc/ssh/ssh_config}
             Общесистемный файл конфигурации. Формат файла и параметры конфигурации
             описаны в ssh_config(5).
@item Файлы закрытой части ключей аунтификации на основании хоста @anchor{man_ssh_peremen_okruj Файлы закрытой части ключей аунтификации на основании хоста}
@display
     /etc/ssh/ssh_host_key
     /etc/ssh/ssh_host_dsa_key
     /etc/ssh/ssh_host_ecdsa_key
     /etc/ssh/ssh_host_ed25519_key
     /etc/ssh/ssh_host_rsa_key
@end display
             Эти файлы содержат приватные части ключей хоста и используются для
             аутентификации на основе хоста.

@item     /etc/ssh/ssh_known_hosts @anchor{man_ssh_peremen_okruj /etc/ssh/ssh_known_hosts}
             Общесистемный список известных ключей хоста. Этот файл должен быть
             подготовлен системным администратором, чтобы он содержал открытые
             ключи хостов всех компьютеров в организации. Это должно быть читаемым
             во всем мире. Смотрите sshd (8) для более подробной информации о
             формате этого файла.

@item     /etc/ssh/sshrc @anchor{man_ssh_peremen_okruj /etc/ssh/sshrc}
             Команды в этом файле выполняются ssh, когда пользователь входит в
             систему, непосредственно перед запуском оболочки пользователя
             (или команды). Обратитесь к странице справочника sshd(8) за
             дополнительной информацией.
@end table
@item EXIT STATUS
     ssh завершается со статусом выхода удаленной команды или с 255, если
     произошла ошибка.

@item SEE ALSO
     scp(1), sftp(1), ssh-add(1), ssh-agent(1), ssh-argv0(1), ssh-keygen(1),
     ssh-keyscan(1), tun(4), ssh_config(5), ssh-keysign(8), sshd(8)

@item STANDARDS
     S. Lehtinen and C. Lonvick, The Secure Shell (SSH) Protocol Assigned
     Numbers, RFC 4250, January 2006.

     T. Ylonen and C. Lonvick, The Secure Shell (SSH) Protocol Architecture,
     RFC 4251, January 2006.

     T. Ylonen and C. Lonvick, The Secure Shell (SSH) Authentication Protocol,
     RFC 4252, January 2006.

     T. Ylonen and C. Lonvick, The Secure Shell (SSH) Transport Layer
     Protocol, RFC 4253, January 2006.

     T. Ylonen and C. Lonvick, The Secure Shell (SSH) Connection Protocol, RFC
     4254, January 2006.

     J. Schlyter and W. Griffin, Using DNS to Securely Publish Secure Shell
     (SSH) Key Fingerprints, RFC 4255, January 2006.

     F. Cusack and M. Forssen, Generic Message Exchange Authentication for the
     Secure Shell Protocol (SSH), RFC 4256, January 2006.

     J. Galbraith and P. Remaker, The Secure Shell (SSH) Session Channel Break
     Extension, RFC 4335, January 2006.

     M. Bellare, T. Kohno, and C. Namprempre, The Secure Shell (SSH) Transport
     Layer Encryption Modes, RFC 4344, January 2006.

     B. Harris, Improved Arcfour Modes for the Secure Shell (SSH) Transport
     Layer Protocol, RFC 4345, January 2006.

     M. Friedl, N. Provos, and W. Simpson, Diffie-Hellman Group Exchange for
     the Secure Shell (SSH) Transport Layer Protocol, RFC 4419, March 2006.

     J. Galbraith and R. Thayer, The Secure Shell (SSH) Public Key File
     Format, RFC 4716, November 2006.

     D. Stebila and J. Green, Elliptic Curve Algorithm Integration in the
     Secure Shell Transport Layer, RFC 5656, December 2009.

     A. Perrig and D. Song, Hash Visualization: a New Technique to improve
     Real-World Security, 1999, International Workshop on Cryptographic
     Techniques and E-Commerce (CrypTEC '99).

@item AUTHORS
     OpenSSH is a derivative of the original and free ssh 1.2.12 release by
     Tatu Ylonen.  Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos, Theo
     de Raadt and Dug Song removed many bugs, re-added newer features and cre‐
     ated OpenSSH.  Markus Friedl contributed the support for SSH protocol
     versions 1.5 and 2.0.

BSD                            February 17, 2016                           BSD
@end table
