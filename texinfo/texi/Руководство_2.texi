@node  Руководство 2, , Руководство 1, Top
@chapter Руководство 2
@ifinfo
@heading Руководство 2
@end ifinfo


Secure Shell [SSH], вероятно, является наиболее важным инструментом
административного доступа к вашим серверам. Это также одна из наименее
защищенных критически важных служб на большинстве серверов UNIX. Почему?
Потому что по какой-то причине люди все еще используют простые пароли
для защиты своих корневых учетных записей. Это не так плохо, как при
использовании telnet, но не слишком. Вы могли бы также использовать
обычный FTP для передачи данных на ваш сервер ... о, подождите, это
другая статья.

Использование паролей для ваших удаленных серверов подвергает вас
целому классу ненужных угроз безопасности, которых легко избежать,
переключаясь на идентификаторы SSH или сертификаты SSH. Эта статья
будет охватывать оба, так как они концептуально очень похожи. Мы
будем очень тесно работать с файлами конфигурации OpenSSH, надеясь
объяснить некоторые из более пугающих опций, с которыми вы можете
столкнуться.

@menu
* Почему пароли плохо для вас::
* Подготовка сервера::
* Отключение аутентификации на основе пароля::
* Сертификаты SSH::
* Создание корневого сертификата::
* Подписание ключей хоста::
* Использование сертификатов ключей хоста::
* Подписание ключей пользователя::
* Использование пользовательских сертификатов::
* Отдельные пользовательские и хост СА::
* Отзыв ключей и сертификатов::
* Дальнейшие улучшения безопасности::
* Укрепить оставшиеся ключи::
* Что еще почитать::
@end menu

@node Почему пароли плохо для вас
@section Почему пароли плохо для вас
@ifinfo
@heading Почему пароли плохо для вас
@end ifinfo

Мне будет нелегко объяснить энтропийную часть лучше, чем этот xkcd, но я
бы хотел подключиться к той части, где люди пытаются угадать ваши пароли. Если вы
недавно настроили новый сервер с SSH, вы, вероятно, обнаружили много шума в
системном журнале об ошибках аутентификации. Большинство из них будут вызваны
ботами, которые пытаются угадать общие сочетания имени пользователя и пароля - и
часто также пытаются использовать известные уязвимости в определенных версиях
OpenSSH. Вы можете устранить первые из этих проблем с помощью таких программ,
как Fail2Ban, однако вы должны помнить, что надежда не является стратегией, а
подобные бандиты только отсрочивают неизбежное: бот получает достаточно догадок,
чтобы угадать ваш пароль.
Введение SSH-идентичностей

К счастью, SSH включает функцию, позволяющую значительно повысить безопасность
и потенциально сделать ее более удобной для вас. Это маленькое волшебство
называется SSH-идентификатором или, чаще, SSH-ключами. Ключи работают следующим
образом: вместо аутентификации на сервере с помощью пароля вы генерируете пару
открытых/закрытых ключей, как в PGP/GPG. Вы сохраняете свой закрытый ключ в
безопасности при загрузке открытого ключа на свой сервер. Преимущество? Вы
увеличиваете энтропию с менее чем 50 бит до длины вашего ключа: обычно 4096 бит
или более. Это примерно на два порядка.
Preparing the Client

Использовать ключи SSH очень и очень просто. Вот как это делается:
вы генерируете новый ключ на клиентском компьютере с помощью такой команды:
@example
$ ssh-keygen -b 4096 -t rsa -f ~/.ssh/id_rsa
@end example
Это создаст два файла: ваш закрытый ключ ~/.ssh/id_rsa и ваш открытый
ключ ~/.ssh/id_rsa.pub. Команда попросит вас ввести пароль для защиты
вашего закрытого ключа - вам решать, удобно ли вам, чтобы этот файл не
попал в чужие руки, поэтому выбирайте осторожно, если вы установили пароль
или нет. Мы использовали следующие варианты:
@example
-b 4096
@end example
    Это инструктирует ssh-keygen генерировать 4096-битный ключ. Не стесняйтесь
    увеличивать это до желаемой длины ключа - не забывайте использовать степени двух.
@example
-t rsa
@end example
    Заставляет ssh-keygen генерировать ключи RSA. Согласно справочной странице,
    допустимыми алгоритмами являются rsa, dsa, ecdsa и ed25519. ed25519 - это новый
    алгоритм, основанный на эллиптических кривых, который был представлен в OpenSSH 6.5,
    тогда как ecdsa - это старая реализация DSA на эллиптических кривых, которая, как
    известно, имеет серьезные уязвимости. Криптография с эллиптической кривой
    основывается на невозможности найти дискретный логарифм для элемента случайной
    эллиптической кривой и считается математически сложнее, чем первичная факторизация,
    на которую опирается RSA, поэтому в теории она должна быть более надежной даже
    при значительно более низких значениях силы ключа. Однако единственная реализация
    этого, доступная в SSH - до недавнего времени - была ошибочной, как и DSA, и
    ed25519 может быть недоступен на многих машинах, на которых вы можете захотеть
    использовать ключ. Наконец, dsa - стандартный вариант DSA без эллиптической кривой -
    имеет много известных векторов атаки, поэтому вам следует избегать этого.
@example
-f ~/.ssh/id_rsa
@end example
    Опция -f устанавливает имя выходного файла для вашего нового закрытого ключа.
    .ssh/id_rsa в вашем домашнем каталоге используется по умолчанию для
    идентификаторов SSH RSA, поэтому он будет использоваться автоматически. Вы
    можете использовать любое выбранное вами место, однако вы должны убедиться,
    что ваш файл закрытого ключа доступен для чтения только вашей учетной записи,
    иначе OpenSSH откажется от его использования. Кроме того, открытый ключ находится
    рядом с этим файлом с расширением .pub.

    После того, как ваш ключ будет сгенерирован, вам будет представлено небольшое
    изображение ASCII randomart. Не стесняйтесь запоминать это изображение, так как
    вы можете использовать его позже для визуальной идентификации подозрительного ключа.
    Чтобы получить это изображение позже, используйте эту команду:
@display
$ ssh-keygen -lv -f .ssh/id_rsa.pub 
2048 fa:86:25:1d:9c:c9:89:58:b2:dd:a5:5c:17:5b:f1:5f  user@@some-host.example.com (RSA)
+--[ RSA 2048]----+
|            ..o. |
|    . .   o .o . |
|     * * B ..   E|
|    o o @       o|
|       .S.      .|
|      ..o        |
|      .+         |
|      ...        |
|       ..        |
+-----------------+
@end display
Сгенерированный randomart довольно отчетливый - этот, в частности, выглядит как пальма
с кокосовым орехом, падающим с правой стороны, не так ли? Вы, вероятно, сможете выбрать
свой, увидев его несколько раз. Однако вы редко будете определять такие открытые ключи.
Эта опция скорее предназначена для идентификации ключей хоста благодаря настройке
VisualHostKey в конфигурационном файле SSH. Вам следует включить этот параметр в вашем
~/.ssh/config file - или в общесистемном /etc/ssh/ssh_config, если у вас есть доступ
для записи в него - добавив следующую строку в начале:
@example
VisualHostKey yes
@end example
Это будет отображать изображение randomart удаленной системы каждый раз, когда вы
входите в систему - и если вы используете пароль, он сделает это до того, как вы
введете его, что позволит вам визуально сравнить ключ удаленного хоста с тем, как
он обычно выглядит Посмотрите, если что-то не так, прежде чем раздавать секретные
пароли. Это работает с помощью ключей хоста SSH, в значительной степени просто являясь
парой закрытого/открытого ключа, подобной той, которую вы только что сгенерировали,
уникальной для каждой машины.

@node Подготовка сервера
@section Подготовка сервера
@ifinfo
@heading Подготовка сервера
@end ifinfo


Теперь, когда у вас есть файл идентификации, вам нужно будет войти на сервер и
добавить содержимое файла ~/.ssh/id_rsa.pub в список ~/.ssh/authorized_keys вашего
сервера. Если на удаленном хосте нет каталога ~/.ssh, создайте его. Ваш открытый
ключ будет просто одной строкой, хотя и длинной, и этот список авторизованных ключей
займет столько открытых ключей, сколько вы захотите. Кстати, вы должны создать новую
пару секретных/открытых ключей на каждом хосте - не так уж много людей, кажется, на
самом деле делают это, заметьте, но если бы вы сделали это, вы могли бы очень легко
отозвать доступ с определенного, скомпрометированные машины, удалив соответствующую
запись в списке авторизованных ключей. Также обратите внимание, что список ключей
зависит от пользователя. Это означает, что любой пользователь, для которого ваш
открытый ключ находится в файле ~/.ssh/authorized_keys пользователя, является
пользователем, с которым вы можете войти в систему, что также означает, что вы можете
легко предоставить кому-то еще доступ к своей учетной записи из другой машины, не
выдавая никаких паролей и не будучи root.

После добавления ключа вы можете просто войти в систему с помощью инструмента
командной строки ssh, как обычно. Если для вашего ключа требуется пароль, вам будет
предложено ввести его - в противном случае для входа в систему достаточно иметь файл
закрытого ключа. Чтобы убедиться, что ключ действительно использовался, и чтобы
проверить, какой ключ использовался, вы можете использовать -v флаг в OpenSSH, вот так:
@example
$ ssh -v magnus@@stinger.becquerel.org
[...]
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Trying private key: /Users/magnusdeininger/.ssh/id_rsa
debug1: read PEM private key done: type RSA
debug1: Authentication succeeded (publickey).
Authenticated to stinger.becquerel.org ([46.226.106.4]:22).
[...]
magnus@@stinger:~$ 
@end example
В этом примере я вошел на свой веб-сервер. Я сократил несколько строк вывода,
так как они не актуальны. Выделенные сообщения debug1 указывают, какой файл
закрытого ключа OpenSSH пытался использовать и, что более важно, он пытался -
и успешно - войти в систему, используя метод аутентификации publickey. Сканируйте
выходные данные отладки на наличие подобных строк, чтобы убедиться, что они работают,
прежде чем переходить к следующему разделу.

@node Отключение аутентификации на основе пароля
@section Отключение аутентификации на основе пароля
@ifinfo
@heading Отключение аутентификации на основе пароля
@end ifinfo

Теперь, когда вы можете войти в систему с использованием идентификатора SSH, а не
обычного пароля, вам следует полностью отключить аутентификацию на основе пароля.
Делайте это только после того, как вы убедились, что можете войти в систему с учетной
записью, которая может перейти в root, или что у вас есть альтернативный способ вернуться
на свою машину. Чтобы заблокировать ваш сервер, отредактируйте ваш /etc/sshd/sshd_config
и установите следующие параметры:
@example
Protocol 2
PermitRootLogin without-password
PubkeyAuthentication yes
ChallengeResponseAuthentication no
PasswordAuthentication no
UsePAM yes
@end example
Это устанавливает довольно строгий набор значений по умолчанию, которые должны
заставить большинство ботов сдаваться сразу после подключения. Варианты, которые
мы использовали:
@table @asis
@item Protocol
    Убедитесь, что разрешена только версия протокола 2. Нет смысла поддерживать
    довольно устаревшую версию 1, и вы открываете себя только для старых ошибок.
    Если здесь установлено 1 или 1,2, измените его на 2.
@item PermitRootLogin
    Настройка без пароля немного ошибочна. То, что он делает, это разрешает вход в
    систему root, но только если механизм аутентификации не был паролем - то есть
    он включает входы root, но только для аутентификации с открытым ключом. Это
    хорошо. Никогда не устанавливайте это на no.
@item PubkeyAuthentication
    Убедитесь, что установлено значение «Да», иначе вы не сможете войти в систему
    после отключения паролей.
@item ChallengeResponseAuthentication
    Установите для этого параметра no, чтобы отключить не входящие в систему учетные
    записи, которые в противном случае могли бы обрабатываться через PAM.
@item PasswordAuthentication
    Это то, для чего мы были здесь: установите это в no, чтобы отключить туннельные
    пароли в виде открытого текста.
@item UsePAM
    Если в вашей системе настроен PAM, все равно будет полезно оставить этот параметр
    включенным, даже если вы отключили аутентификацию на основе пароля. Это связано с
    тем, что PAM также обеспечивает управление сеансами и учетными записями, поэтому
    установите для него значение yes.
@end table
Все, что вам нужно сделать сейчас, это перезапустить сервер SSH, вот так:
@example
# /etc/init.d/ssh restart
@end example
Обратите внимание, что перезапуск SSH не уничтожит ваш активный сеанс, поэтому вы
должны убедиться, что новые настройки действительно позволят вам войти в систему,
прежде чем закрывать текущий сеанс, - и снова вернуться и перезапустить SSH, если
этого не произойдет.

Для достижения максимального эффекта убедитесь, что SSH является единственным способом
входа на ваш сервер. По крайней мере, убедитесь, что у вас не включен telnet! Теперь вы
готовы и можете быть уверены, что боты не смогут получить доступ к вашим машинам
через SSH. Но подождите, это еще не все!

@node Сертификаты SSH
@section Сертификаты SSH
@ifinfo
@heading Сертификаты SSH
@end ifinfo

Сертификаты SSH - это новейшее и лучшее усовершенствование аутентификации с
использованием открытого и закрытого ключей, которое может предложить SSH. Они
работают, внедряя новый центр сертификации, который подписывает ваш хост или
пользовательские ключи, что добавляет несколько существенных улучшений концепции,
таких как:
@table @asis
@item CA
    Вероятно, у вас есть более одного сервера и более одной учетной записи пользователя -
    например, root и ваша любимая учетная запись без полномочий root для нормальной
    повседневной работы. Если вы генерируете новый ключ или пытаетесь предоставить
    новому пользователю доступ к вашим машинам, вам придется добавить этот ключ ко
    многим файлам authorized_keys, что является медленным и подверженным ошибкам
    раздражающим процессом. Используя сертификаты SSH, вы можете сократить это,
    просто один раз подписав разрешенные ключи, и тогда все готово.
@item Срок действия ключа
    Когда-нибудь создавали ключ PGP/GPG и впоследствии теряли закрытый ключ, пока
    люди все еще отправляли вам сообщения, используя ваш старый открытый ключ? Да,
    вот почему вы должны установить срок годности для ваших ключей. К сожалению,
    вы не можете сделать это с обычными парами открытого/закрытого ключей в SSH -
    но вы можете сделать это с подписанными ключами.
@item Ключи подписанного хоста
    Обратите внимание, как всякий раз, когда вы настраиваете новый компьютер и
    подключаетесь к нему в первый раз, SSH просит вас принять или отклонить его
    ключ хоста? Если вы были достаточно параноиком, на самом деле вы должны были
    распространять ключ хоста через какую-то физическую среду и очень-очень боялись
    принимать новые ключи хоста. Поскольку это нецелесообразно, сертификаты SSH также
    позволяют подписывать ключи хоста, поэтому вам нужно только доверять центру
    сертификации для домена, и тогда вы не увидите никаких предупреждений о неизвестных
    ключах хоста при подключении к новым машинам в этой сети. ,
@end table
Сертификаты SSH являются относительно новой функцией. Как таковые они используются недостаточно. Теперь, когда вы знаете, почему они хороши, давайте настроим их, начиная с корневого сертификата.

@node Создание корневого сертификата
@section Создание корневого сертификата
@ifinfo
@heading Создание корневого сертификата
@end ifinfo


Чтобы подписать что-либо, вам нужен центр сертификации. SSH не использует более
распространенные сертификаты X.509, используемые в SSL, поскольку они в основном
являются просто расширением концепции идентификации, уже существующей в SSH. Таким
образом, вам не нужно возиться с непонятными командами OpenSSL; как с личностями,
ssh-keygen твой друг! Чтобы создать новый корневой сертификат, сначала создайте
новую пару ключей:
@example
$ ssh-keygen -b 4096 -t rsa -f example-com-ca -C "CA key for example.com"
@end example
Параметры, которые мы использовали, практически одинаковы, за исключением того, что
на этот раз мы не поместили сертификаты в вашу папку ~/.ssh/. Зачем? Потому что эти
ключи не предназначены для использования в качестве идентификаторов. Есть одна новая
опция, которую мы не использовали в прошлый раз:
@example
-C "CA key for example.com"
@end example
    Опция -C устанавливает комментарий в вашем файле ключей. По умолчанию используется
    user@@host, но, поскольку теперь вы будете иметь дело с большим количеством ключей,
    может быть лучше дать ключи с описательными именами.

О, и, пожалуйста, обратите внимание, что большинство других руководств скажут вам сделать
эти шаги как root. Нет необходимости генерировать ключи от имени пользователя root -
подойдет любой обычный пользователь. Так что, вероятно, лучше всего использовать обычную
учетную запись пользователя. Кроме того, не имеет значения, где вы генерируете пару
ключей - делайте это на своей рабочей станции, если можете, а не на своем сервере.
Просто не забудьте сохранить ключи подписи в безопасности - этот, вероятно, один из тех,
с которыми вам следует использовать пароль, потому что этот ключ действительно мощный,
и вам не нужно использовать его очень часто.

@node Подписание ключей хоста
@section Подписание ключей хоста
@ifinfo
@heading Подписание ключей хоста
@end ifinfo
Подписание ключей хоста

Самое простое использование вашего нового ключа подписи - это подпись ключей хоста.
В SSH нет реального различия между ключами пользователя и хоста, и, как обычно, мы
будем использовать для этого ssh-keygen. Команда выглядит следующим образом:
@example
$ ssh-keygen -s example-com-ca -h -n host.example.com -V +52w -I host.example.com-key host-key.pub
@end example
Эта команда содержит довольно много новых флагов, поэтому давайте посмотрим на них:
@table @asis
@item -s example-com-ca
    Говорит ssh-keygen подписать открытый ключ закрытым ключом example-com-ca.
    Замените example-com-ca тем ключом подписи, который вы хотите использовать.
@item -h
    Подпишите ключ хоста. Без этого флага вы бы подписывали сертификат пользователя.
    Мы вернемся к этому позже.
@item -n host.example.com
    Устанавливает имя хоста для этого нового подписанного ключа равным
    host.example.com. Замените на имя хоста любого компьютера, для которого
    предназначен ключ хоста. Вы можете указать несколько имен хостов, разделяя
    их запятыми, например, -n host.example.com,ssh.example.com.
@item -V +52w
    Как долго сертификат будет действителен. +52w означает, что срок действия
    сертификата истекает через 52 недели, то есть через год. Вы также можете
    указать диапазон, например, +2w,+52w для ключа, который вступит в силу через
    две недели и истекает через год. Применяется стандартный формат даты SSH,
    поэтому вы можете использовать дополнительные суффиксы, отличные от w, а
    также указывать явные даты. См. Раздел «Форматы времени» на справочной
    странице sshd_config для получения дополнительной информации об этом.
@item -I host.example.com-key
    Установите идентификатор для подписанного ключа, который используется при
    ведении журнала (и отзыв сертификата, описано ниже).
@end table
Последний аргумент, host-key.pub, является открытым ключом для подписи. Вы
всегда подписываете открытые ключи, а не закрытые ключи! Сертификат будет помещен
в новый файл host-key-cert.pub. Например, если вы подпишете ключ хоста RSA компьютера,
на котором вы сейчас находитесь, вы можете сделать это следующим образом:
@example
# ssh-keygen -s example-com-ca -h -n host.example.com -V +52w \
-I host.example.com-key /etc/ssh/ssh_host_rsa_key.pub
@end example
Обратите внимание, что вам нужно сделать это как root, так как команда попытается
записать новый файл /etc/ssh/ssh_host_rsa_key-cert.pub, и этот каталог, вероятно,
будет доступен для записи только root.

@node Использование сертификатов ключей хоста
@section Использование сертификатов ключей хоста
@ifinfo
@heading Использование сертификатов ключей хоста
@end ifinfo
Использование сертификатов ключей хоста

Независимо от того, где вы подписали ключ, скопируйте сертификат в соответствующее
место на вашем хосте SSH; то есть скопируйте его в /etc/ssh/ssh_host_rsa_key-cert.pub,
если это ключ RSA, и замените часть rsa правильным алгоритмом, если вы подписали ключ
другим типом. Затем вы должны указать демону OpenSSH на вашем SSH-сервере использовать
новый сертификат, отредактировав /etc/ssh/sshd_config:
@example
HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub
@end example
Обратите внимание, что вам не нужно ничего рассказывать демону OpenSSH об CA - это не
нужно, поскольку клиентская сторона проверяет ключ хоста сервера, поэтому серверу
просто необходимо знать, где находится его подпись.

Это все, что нужно сделать на стороне сервера. На стороне клиента вам нужно добавить
открытый ключ подписи в файл ~/.ssh/known_hosts вашего пользователя. Добавьте новую
строку, как показано ниже:
@example
@@cert-authority *.example.com contents-of-public-key-file
@end example
Все это должно быть в одной строке, как всегда в файле known_hosts. Отдельные
части линии следующие:
@table @asis
@item @@cert-authority
    Сообщает SSH, что следующий ключ не является ключом для одного хоста, а является
    ожидаемым ключом подписи для набора хостов.
@item *.example.com
    Разделенный запятыми набор шаблонов имен хостов, для которых этот ключ подписи
    является действительным. Это обычный формат шаблона, используемый SSH, где
    звездочки обозначают произвольные строки символов. IP-адреса также действительны.
@item contents-of-public-key-file
    Это буквально открытый ключ в вашей паре ключей подписи.
@end table
Помните, что все это должно быть в одной строке. Например, в нижней части нашей
страницы открытых ключей перечислены строки, которые нужно добавить для сети
becquerel.org, где размещен этот сайт. Если бы вы добавили именно эту строку и
протестировали ее ...
@display
$ ssh stinger.becquerel.org
Host key fingerprint is 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
+--[RSA-CERT 819--+
|                 |
|         . . .   |
|        + o E    |
|         * o     |
|      o S *      |
|   . = o + .     |
|  . * * + .      |
|   o *   +       |
|         .o      |
+-----------------+

Permission denied (publickey).
@end display
Конечно, вы бы не увидели последнюю строку, если бы у вас был мой закрытый ключ.
Обратите внимание, что ssh не просит вас добавить новый ключ хоста - это потому,
что он проверен на соответствие подписи открытого ключа. Чтобы убедиться, что это
действительно так, флаг -v - это ваш код:
@display
$ ssh -v stinger.becquerel.org
[...]
debug1: ssh_rsa_verify: signature correct
debug1: Server host key: RSA-CERT 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
debug1: Host 'stinger.becquerel.org' is known and matches the RSA-CERT host certificate.
debug1: Found CA key in /Users/mdeininger/.ssh/known_hosts:11
[...]
@end display
Обратите внимание, что он говорит, что подпись верна и что он нашел ключ [the] CA в
[the known_hosts file]. Вот как вы проверяете, что он использовал сертификаты; если бы
он не знал о подписи открытого ключа, он вместо этого показал бы:
@display
$ ssh -v stinger.becquerel.org
[...]
debug1: ssh_rsa_verify: signature correct
debug1: Server host key: RSA-CERT 62:2e:78:67:72:68:dd:05:2f:fb:0e:17:09:2d:1f:9d
debug1: No matching CA found. Retry with plain key
[...]
@end display
Вывод, подобный этому, означает, что вы не добавили правильный ключ CA в ваш
~/.ssh/known_hosts или что шаблон хоста был неверным.

@node Подписание ключей пользователя
@section Подписание ключей пользователя
@ifinfo
@heading Подписание ключей пользователя
@end ifinfo


Этот последний шаг концептуально очень похож на сертификаты хоста: пользовательские
сертификаты. Мы снова используем ssh-keygen, вот так:
@example
$ ssh-keygen -s example-com-ca -n user -V +52w -I example.com-user id_rsa.pub
@end example
Обратите внимание, что эта команда очень похожа на ту, которую мы использовали для
подписи ключей хоста. Единственное отличие состоит в том, что флаг -n теперь указывает
пользователей, а не имена хостов, и на этот раз вам нужно передать его открытым ключом
вашей идентификационной информации пользователя. Как и в прошлый раз, он создаст файл
с именем id_rsa-cert.pub. Если бы вы подписали свой собственный ключ пользователя,
команда была бы такой:
@example
$ ssh-keygen -s example-com-ca -n user -V +52w -I example.com-user ~/.ssh/id_rsa.pub
@end example
И это все, что нужно для подписи ключей пользователя. Если бы ваш сервер был настроен
так, чтобы вы могли входить в систему с ключами, подписанными этим сертификатом, у вас
все было бы в порядке, если бы вам не пришлось вручную заполнять любые файлы
author_keys. Вот что вы будете делать дальше.

@node Использование пользовательских сертификатов
@section Использование пользовательских сертификатов
@ifinfo
@heading Использование пользовательских сертификатов
@end ifinfo


На стороне клиента все, что вам нужно сделать, это убедиться, что id_rsa-cert.pub
находится рядом с вашим файлом id_rsa.pub, поэтому мы закончили с этой частью.
Однако нам все же нужно сообщить серверу, чтобы он принимал ключи, подписанные вашим
CA. Для этого вам нужно скопировать ваш example-com-ca.pub на ваш сервер -
/etc/ssh будет хорошим местом, поэтому я предполагаю, что вы скопировали его туда.
Затем вам нужно снова отредактировать файл /etc/ssh/sshd_config и добавить опцию,
подобную этой:
@example
TrustedUserCAKeys /etc/ssh/example-com-ca.pub
@end example
Вы можете поместить несколько открытых ключей в файл, на который ссылается
TrustedUserCAKeys - по одному на CA, которому разрешено подписывать доверенные
пользовательские ключи. Как обычно, перезапустите сервер SSH, чтобы эта опция вступила
в силу. И это все, что вам нужно было сделать, теперь вы можете войти в систему,
используя подписанный ключ, без необходимости обновлять файл authorized_keys для каждого
пользователя, для которого вы хотите войти в систему. Конечно, вы можете сделать это, в
дополнение к использованию CA.

@node Отдельные пользовательские и хост СА
@section Отдельные пользовательские и хост СА
@ifinfo
@heading Отдельные пользовательские и хост СА
@end ifinfo


Часто рекомендуется использовать отдельные центры сертификации пользователей и хостов.
Это не является строго необходимым, но это может повысить безопасность, если один из
секретных ключей будет скомпрометирован или если пользователи и хосты будут управляться
различными отделами. Не стесняйтесь просто сгенерировать второй CA для своих
пользователей, как вы это делали до создания ключей хоста, и при необходимости
заменить ключ подписи.

@node Отзыв ключей и сертификатов
@section Отзыв ключей и сертификатов
@ifinfo
@heading Отзыв ключей и сертификатов
@end ifinfo


Последнее, что нужно знать об использовании удостоверений и сертификатов, это то, что
вы можете отозвать их. Для этого вам снова нужно отредактировать ваш /etc/ssh/sshd_config
и добавить следующую опцию:
@example
RevokedKeys /etc/ssh/revoked-keys
@end example
Убедитесь, что файл, указанный здесь, существует и доступен для чтения, иначе в
аутентификации с открытым ключом будет вообще отказано! В зависимости от того,
использовали ли вы прямые идентификаторы или сертификаты, вы можете либо заполнить этот
файл списком отозванных открытых ключей, либо использовать ssh-keygen, чтобы заполнить
этот файл списком отзыва ключей OpenSSH или, для краткости, KRL. Любым ключам, указанным
в этом файле, будет отказано в доступе при попытке аутентификации. Это как инвертированый
файл author_keys. Это не особенно полезно для принудительного оборота ключей, но полезно,
если у вас есть, который который был украден - или для блокировки ключей, которые,
как известно, страдают от старой ошибки RNG и по своей природе небезопасны.

Если вы хотите использовать KRL вместо прямого списка отозванных открытых ключей,
швейцарский армейский нож OpenSSH ssh-keygen, как обычно, ваш друг. Чтобы создать или
обновить KRL, используйте следующую команду:
@example
$ ssh-keygen -k -f revoked-keys -u -s example-com-ca public-key-or-file(s)
@end example
Это использование имеет несколько новых опций, поэтому давайте посмотрим на них:
@table @asis
@item -k
    Этот флаг переводит ssh-keygen в режим KRL, сообщая ему о создании или
    обновлении Key Revocation List (Список Отзыва Ключей). Новый KRL помещается в
    файл, указанный флагом -f, поэтому в этом примере он будет помещен в файл
    revoked-keys.
@item -u
    Если вы укажете этот флаг, выходной KRL будет дописан вместо того, чтобы
    создать новый только с содержимым указанных файлов. Вы должны использовать
    это, если у вас уже есть KRL и вы просто хотите быстро отозвать другой открытый
    ключ. Обратите внимание, что если вы укажете этот флаг и выходной файл не
    существует, то ssh-keygen завершится с ошибкой, поэтому при первом запуске вы
    должны сбросить этот флаг.

@item -s
    Этот флаг является необязательным, и вам нужно использовать его, только если вы
    хотите отозвать сертификат по серийному номеру или идентификатору. Если вы хотите
    отозвать только открытые ключи, то вам не нужно указывать CA.
    public-key-or-file(s) - это список файлов, которые содержат открытые ключи
    (один ключ на строку) или спецификации отзыва. Итак, если вы хотите создать KRL
    со своим собственным открытым ключом, вы должны вызвать следующую команду:
@end table
@example
$ ssh-keygen -k -f revoked-keys ~/.ssh/id_rsa.pub
@end example
... и теперь у вас есть новый файл revoked-keys в вашем текущем каталоге, который
содержит этот ключ. Если вы хотите отозвать сертификат OpenSSH с помощью ID, вы должны
создать новый файл ids-to-revoke со следующим содержимым:
@example
id: example.com-user
@end example
И команда превратить это в KRL будет:
@example
$ ssh-keygen -k -f revoked-keys -s example-com-ca ids-to-revoke
@end example
Такое использование позволяет вам использовать revoke-keys, фактически не имея
буквального сертификата или идентификационного файла под рукой. Вы можете указать
несколько строк в файле ids-to-revoke с несколькими id: commands. Вместо id:
вы также можете использовать serial:, key: или sha1: для указания серийного
номера ключа, простого открытого ключа или хэша SHA1 ключа.

Не забудьте использовать флаг -u при обновлении KRL и фактически распространять KRL
на серверы. scp и rsync ваши друзья, как обычно.

@node Дальнейшие улучшения безопасности
@section Дальнейшие улучшения безопасности
@ifinfo
@heading Дальнейшие улучшения безопасности
@end ifinfo


Теперь, когда вы являетесь экспертом в области сертификатов, вы можете сделать еще
несколько вещей, чтобы повысить безопасность своих серверов. Начиная с их ключей хоста.

Отключить неиспользуемые типы ключей хоста

В файле /etc/ssh/sshd_config ваших серверов вы заметите несколько директив HostKey.
Вы должны отключить все ключи хоста с помощью алгоритмов, которые вы не используете
или которым вы не доверяете. Например, на моих серверах блок с ключами хоста
выглядит так:
@display
HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_dsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
@end display
Как видите, ключи DSA и ECDSA закомментированы, то есть сервер SSH не будет их
использовать. Вы можете - и должны - также удалить эти другие закрытые ключи вместе
с их открытыми ключами из /etc/ssh, поскольку они не соответствуют задачи. Хотя
некоторые сценарии распространения могут перегенерировать их при перезапуске SSH.

Помните: чем меньше функций вы включите, тем меньше функций можно будет использовать,
если окажется, что где-то скрывается ошибка.

@node Укрепить оставшиеся ключи
@section Укрепить оставшиеся ключи
@ifinfo
@heading Укрепить оставшиеся ключи
@end ifinfo


Ключи хоста по умолчанию обычно составляют 1024 бита. Поэтому,
если вы параноик, вам следует создать новые ключи хоста, которые сильнее:
@example
# ssh-keygen -b 8192 -t rsa /etc/ssh/ssh_host_rsa_key
@end example
Вам также следует сгенерировать ключи хоста, если вы подозреваете, что ключи хоста
были сгенерированы, когда действовала слабая ошибка RNG, или если вы подозреваете,
что закрытый ключ был взломан. Также не забудьте подписать открытый ключ заново и
загрузить сертификат при создании нового ключа, иначе все будет работать не так, как
задумано.

Имейте в виду, что использование ключей со значением более 8192 битов с сертификатами
приведет к тому, что некоторые версии OpenSSH будут игнорировать ключи и давать сбой.
Некоторые старые версии могут быть ограничены до 4096 бит. Вы получите очень странные
сообщения об ошибках, в которых говорится, что ваш сертификат вообще не был
действительным. Так что пока лучше держаться за эти действительно сильные клавиши.
Также обратите внимание, что вам не следует назначать пароль этим ключам, так как вы
хотите, чтобы ваш сервер загружался автоматически с включенным и работающим SSH.

Не храните копии сертификатов, которые вы подписали

Некоторые руководства скажут вам сохранить копии сертификатов, которые вы подписали,
или даже сгенерировать пару открытых/закрытых ключей для вашего пользователя и передать
им закрытый ключ и сертификат по безопасному каналу и хранить файлы, чтобы вы могли
отозвать их позже.

В этом нет необходимости, и на самом деле это проблема безопасности. Вам не нужно иметь
доступ к закрытым ключам ваших пользователей, и вам на самом деле не нужно этого делать,
так как это позволит вам имитировать их. Пусть ваши пользователи генерируют свои
собственные пары ключей и запрашивайте у них только открытый ключ - это единственное,
что вам нужно подписать. Также нет необходимости хранить копию сертификата; пока у вас
есть личный ключ CA и идентификатор назначенного вами ключа, вы можете отозвать ключ с
помощью KRL. Поскольку вам не нужна другая информация, лучше всего удалить файл открытого
ключа и сертификат после того, как вы их выпустили.

@node Что еще почитать
@section Что еще почитать
@ifinfo
@heading Что еще почитать
@end ifinfo


Поздравляем, теперь у вас настроен SSH-сервер на уровне так себе.

Для получения дополнительной информации о том, что вы можете настроить в
OpenSSH, прочитайте следующие справочные страницы:
@example
$ man 5 ssh_config
$ man 5 sshd_config
$ man 1 ssh-keygen
@end example
